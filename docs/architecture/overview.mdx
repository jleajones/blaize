# ğŸ›ï¸ BlaizeJS Architecture

> Understanding how BlaizeJS works under the hood

This document explains the internal architecture of BlaizeJS for contributors, senior developers evaluating the framework, and anyone curious about how the "magic" works. You'll learn about the request lifecycle, type system design, plugin architecture, event-driven patterns, and the reasoning behind key design decisions.

---

## ğŸ“‹ Table of Contents

- [System Overview](#-system-overview)
- [Request Lifecycle](#-request-lifecycle)
- [Type System Architecture](#-type-system-architecture)
- [Event-Driven Architecture](#-event-driven-architecture)
- [Plugin System](#-plugin-system)
- [File-Based Router](#-file-based-router)
- [Error System](#-error-system)
- [Real-Time (SSE) Architecture](#-real-time-sse-architecture)
- [Background Jobs Architecture](#-background-jobs-architecture)
- [Package Dependencies](#-package-dependencies)
- [Design Decisions](#-design-decisions)
- [Future Architecture Considerations](#-future-architecture-considerations)

---

## ğŸŒ System Overview

BlaizeJS is built as a layered architecture where each layer has a single responsibility and clear boundaries:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          HTTP/2 Server                                  â”‚
â”‚                    (with HTTP/1.1 fallback)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         Event Bus                                       â”‚
â”‚                  (in-memory with distributed adapter)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         Plugin System                                   â”‚
â”‚         (lifecycle: register â†’ initialize â†’ start â†’ stop)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Middleware Pipeline                                â”‚
â”‚              (composable, typed, onion-style execution)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                       File-Based Router                                 â”‚
â”‚     (auto-discovery, dynamic parameters, multipart parsing, exports)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Context (AsyncLocalStorage)                          â”‚
â”‚         (request, response, state, services, correlation ID)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        Error Boundary                                   â”‚
â”‚          (catches all errors, formats responses, adds IDs)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Layer Responsibilities:**

| Layer | Responsibility | Key Files |
|-------|----------------|-----------|
| **HTTP Server** | Accept connections, TLS, protocol negotiation | `server/http2-server.ts` |
| **Event Bus** | Pub/sub messaging, cross-component communication | `events/memory-event-bus.ts` |
| **Plugin System** | Lifecycle management, service injection | `plugins/plugin-manager.ts` |
| **Middleware** | Request/response transformation, cross-cutting concerns | `middleware/pipeline.ts` |
| **Router** | URL â†’ Handler mapping, parameter extraction, **multipart parsing** | `router/file-router.ts`, **`upload/multipart-parser.ts`** |
| **Context** | Request-scoped state, async propagation | `context/context.ts` |
| **Error Boundary** | Exception handling, response formatting | `errors/boundary.ts` |

---

## ğŸ“„ Request Lifecycle

Every HTTP request flows through these phases:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           REQUEST LIFECYCLE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Request â”‚â”€â”€â”€â–¶â”‚   Context   â”‚â”€â”€â”€â–¶â”‚   Global   â”‚â”€â”€â”€â–¶â”‚    Route      â”‚  â”‚
â”‚  â”‚ Arrives â”‚    â”‚  Creation   â”‚    â”‚ Middleware â”‚    â”‚   Matching    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚           â”‚
â”‚                                                              â–¼           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Response â”‚â—€â”€â”€â”€â”€â”‚   Error     â”‚â—€â”€â”€â”€â”€â”‚  Handler   â”‚â—€â”€â”€â”€â”€â”‚    Route      â”‚  â”‚
â”‚  â”‚  Sent   â”‚    â”‚  Boundary   â”‚    â”‚ Execution  â”‚    â”‚  Middleware   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                           â”‚                              â”‚
â”‚                                           â–¼                              â”‚
â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚                                    â”‚   Schema   â”‚                        â”‚
â”‚                                    â”‚ Validation â”‚                        â”‚
â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Phase 1: Context Creation

When a request arrives, BlaizeJS immediately creates a `Context` object and stores it in `AsyncLocalStorage`:

```typescript
// Simplified internal flow
const context = {
  request: parseRequest(req),      // Parse headers, body, params
  response: createResponse(res),   // Response helpers
  state: {},                       // Request-scoped data
  services: {},                    // Plugin-injected services
  correlationId: generateId(),     // Unique request ID
};

asyncLocalStorage.run(context, async () => {
  await processRequest(context);
});
```

**Key points:**
- Correlation ID is generated immediately for tracing
- Body parsing is deferred until first access (lazy)
- AsyncLocalStorage enables context access anywhere without prop drilling
- Context includes access to the event bus for publishing events during request processing

### Phase 2: Middleware Execution

Middleware executes in an "onion" pattern â€” each middleware wraps the next:

```
Request â”€â”€â–¶ Middleware A â”€â”€â–¶ Middleware B â”€â”€â–¶ Middleware C â”€â”€â–¶ Handler
                â”‚                 â”‚                 â”‚              â”‚
                â”‚                 â”‚                 â”‚              â”‚
Response â—€â”€â”€â”€â”€ Middleware A â—€â”€â”€â”€â”€ Middleware B â—€â”€â”€â”€â”€ Middleware C â—€â”€â”€â”€â”€â”€â”€â”˜
```

```typescript
// Middleware implementation pattern
const loggingMiddleware = createMiddleware({
  name: 'logger',
  handler: async (ctx, next) => {
    const start = Date.now();
    console.log(`â†’ ${ctx.request.method} ${ctx.request.path}`);
    
    await next();  // Call next middleware or handler
    
    const duration = Date.now() - start;
    console.log(`â† ${ctx.response.statusCode} (${duration}ms)`);
  },
});
```

**Execution order:**
1. Global middleware (server-level, in registration order)
2. Route middleware (route-level, in array order)
3. Route handler
4. Middleware post-processing (reverse order)

### Phase 3: Route Resolution

The file-based router maps URL paths to handler files:

```typescript
// Internal route resolution
const match = router.match('GET', '/users/123/posts');
// Returns:
// {
//   handler: getUserPosts,
//   params: { userId: '123' },
//   middleware: [authMiddleware],
// }
```

### Phase 4: Schema Validation

Before handler execution, Zod schemas validate the request:

```typescript
// Validation sequence
const validatedParams = paramsSchema.parse(match.params);
const validatedQuery = querySchema.parse(ctx.request.query);
const validatedBody = bodySchema.parse(ctx.request.body);
const validatedFiles = filesSchema.parse(ctx.request.files);  // â† NEW

// TypeScript knows exact types of validated data
handler(ctx, validatedParams);
```

**File validation** includes:
- Size constraints (min/max in human-readable format: '5MB', '100KB')
- MIME type validation with wildcard support ('image/*')
- Custom refinements via Zod combinators

### Phase 5: Handler Execution

The route handler runs with fully validated, typed data:

```typescript
const handler = async (ctx, params) => {
  // params.userId is string (inferred from schema)
  const user = await db.users.find(params.userId);
  
  // Can publish events during handler execution
  await ctx.eventBus.publish('user:accessed', {
    userId: params.userId,
    timestamp: Date.now(),
  });
  
  return user;
};
```

### Phase 6: Error Handling

If any error occurs, it's caught by the error boundary:

```typescript
try {
  await handler(ctx, params);
} catch (error) {
  if (error instanceof BlaizeError) {
    // Format as RFC 9457 Problem Details
    ctx.response.status(error.statusCode).json(error.toJSON());
  } else {
    // Unknown error â†’ 500 Internal Server Error
    ctx.response.status(500).json({
      type: 'INTERNAL_SERVER_ERROR',
      title: 'Internal Server Error',
      status: 500,
      correlationId: ctx.correlationId,
    });
  }
}
```

### File Upload Flow

File uploads follow a specialized path through the system with automatic multipart detection:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Client detects File/Blob objects                            â”‚
â”‚    â†’ Auto-switches to multipart/form-data                      â”‚
â”‚    â†’ FormData created automatically                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. Server receives multipart request                           â”‚
â”‚    â†’ Content-Type: multipart/form-data; boundary=...           â”‚
â”‚    â†’ Multipart parser extracts files + fields                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Request Validator validates files                           â”‚
â”‚    â†’ File size checked (maxSize: '5MB')                        â”‚
â”‚    â†’ MIME type validated (accept: ['image/*'])                 â”‚
â”‚    â†’ Returns ValidationError if invalid                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Handler receives typed files                                â”‚
â”‚    â†’ ctx.request.files.avatar (typed as UploadedFile)          â”‚
â”‚    â†’ ctx.request.body (typed from body schema)                 â”‚
â”‚    â†’ Full type safety from schema to handler                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Components:**

- **Client:** Auto-detection (`containsFileObjects()`) + FormData builder
- **Server:** Multipart parser + file validator + type inference
- **Types:** `File`/`Blob` (client) â†’ `UploadedFile` (server)

**Implementation Details:**

```typescript
// Client-side: Automatic detection
// blaize-client/src/file-detection.ts
export function containsFileObjects(value: unknown, depth = 0): boolean {
  // Recursively checks for File/Blob objects (max depth: 2)
  // Used by request-options-builder to switch encoding
}

// Server-side: Multipart parsing
// blaize-core/src/upload/multipart-parser.ts
export async function parseMultipartRequest(
  request: UnifiedRequest,
  options: Partial<ParseOptions> = {}
): Promise<MultipartData> {
  // Streams request body, extracts boundary
  // Parses files and fields into separate objects
  // Returns { fields, files } with validated data
}

// Validation: Type-safe file schemas
// blaize-core/src/upload/schema.ts
export function file(options?: FileSchemaOptions): z.ZodType<UploadedFile> {
  // Creates Zod schema with custom refinements
  // Validates size, MIME type at request validation phase
  // Integrates with router's validation system
}
```

---

## ğŸ¯ Type System Architecture

BlaizeJS achieves end-to-end type safety without code generation through clever use of TypeScript's type inference.

### Route Type Inference

```typescript
// Route definition
export const getUser = createGetRoute({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    response: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  },
  handler: async (ctx, params) => {
    // params is { userId: string } (inferred from schema)
    return { 
      id: params.userId,
      name: 'John',
      email: 'john@example.com',
    };
    // Return type is validated against response schema
  },
});
```

### File Upload Type Flow

File uploads add a fourth generic parameter `F` to the type system:

```typescript
// RouteSchema with files parameter
interface RouteSchema<P, Q, B, F, R> {
  params?: P;
  query?: Q;
  body?: B;
  files?: F;    // â† NEW
  response?: R;
}

// Server route definition
export const uploadAvatar = route.post({
  schema: {
    files: z.object({
      avatar: file({
        maxSize: '5MB',
        accept: ['image/jpeg', 'image/png', 'image/webp'],
      }),
    }),
    response: z.object({
      url: z.string().url(),
    }),
  },
  handler: async ({ ctx }) => {
    const { avatar } = ctx.request.files;
    // avatar is typed as UploadedFile
    console.log(avatar.originalname);  // Fully typed!
    console.log(avatar.size);          // Fully typed!
  },
});
```

**Client-side type mapping:**

```typescript
// On server: files schema defines UploadedFile types
files: z.object({
  avatar: file({ maxSize: '5MB' }),  // Validates UploadedFile
})

// On client: same schema maps to File/Blob
await client.$post.uploadAvatar({
  files: {
    avatar: new File(['...'], 'avatar.jpg')  // Expects File/Blob
  }
});
```

**Type transformation:**

| Location | Type | Description |
|----------|------|-------------|
| **Client schema** | `File` or `Blob` | Browser native file objects |
| **Wire format** | `multipart/form-data` | HTTP encoding |
| **Server schema** | `UploadedFile` | Parsed file with buffer/stream |
| **Handler context** | Same as schema | Type-safe access via `ctx.request.files` |

The `file()` helper creates a Zod schema that:
1. **Server-side:** Validates `UploadedFile` objects (after multipart parsing)
2. **Client-side:** Accepts `File`/`Blob` objects (inferred by client proxy)
3. **Type-safe:** Full inference across the boundary automatically

### Client Type Inference

```typescript
// Client automatically infers types from route registry
const client = bc.create('https://api.example.com', routes);

// TypeScript knows exact parameter and return types
const user = await client.$get.getUser({ 
  params: { userId: '123' }  // Type error if not UUID string
});
// user is { id: string; name: string; email: string }
```

### Middleware Type Composition

Middleware can extend context types, and these extensions compose automatically:

```typescript
// Auth middleware adds user to state
const authMiddleware = createMiddleware<
  { user: User },      // State additions
  { auth: AuthService } // Service additions
>({
  handler: async (ctx, next) => {
    ctx.state.user = await verifyToken(ctx.request.header('authorization'));
    ctx.services.auth = authService;
    await next();
  },
});

// Route using auth middleware
export const getProfile = createGetRoute({
  middleware: [authMiddleware],
  handler: async (ctx) => {
    // TypeScript knows ctx.state.user exists and is type User
    // TypeScript knows ctx.services.auth exists and is type AuthService
    return ctx.state.user;
  },
});
```

### How Type Inference Works

BlaizeJS uses TypeScript's `infer` keyword and conditional types:

```typescript
// Simplified internal type extraction
type InferParams<T> = T extends { schema: { params: infer P } }
  ? z.infer<P>
  : never;

type InferResponse<T> = T extends { schema: { response: infer R } }
  ? z.infer<R>
  : never;

type InferFiles<T> = T extends { schema: { files: infer F } }
  ? z.infer<F>
  : never;

// These types flow through to the client automatically
type RouteReturnType<T> = Promise<InferResponse<T>>;
```

---

## ğŸ“¡ Event-Driven Architecture

BlaizeJS features a built-in event bus that enables decoupled communication between components, services, and servers. The event bus is a core architectural primitive that powers real-time features, inter-plugin communication, and distributed coordination.

> **ğŸ“– Deep Dive:** For detailed information about the event bus implementation, patterns, and best practices, see the [Event Bus Architecture Guide](./event-bus.md).

### Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         EVENT BUS ARCHITECTURE                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      MemoryEventBus (Core)                         â”‚  â”‚
â”‚  â”‚  â€¢ Pattern matching (exact, glob, regex)                           â”‚  â”‚
â”‚  â”‚  â€¢ Local pub/sub within process                                    â”‚  â”‚
â”‚  â”‚  â€¢ Handler error isolation                                         â”‚  â”‚
â”‚  â”‚  â€¢ Automatic metadata population                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚               â”‚                                   â”‚                      â”‚
â”‚               â–¼                                   â–¼                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  TypedEventBus         â”‚       â”‚   EventBusAdapter (Optional)     â”‚  â”‚
â”‚  â”‚  â€¢ Zod schema validationâ”‚       â”‚   â€¢ Cross-server propagation    â”‚  â”‚
â”‚  â”‚  â€¢ Type-safe pub/sub   â”‚       â”‚   â€¢ Redis, RabbitMQ, etc.        â”‚  â”‚
â”‚  â”‚  â€¢ Compile-time safety â”‚       â”‚   â€¢ Self-filtering               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Event Flow

Every event in BlaizeJS follows this lifecycle:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           EVENT LIFECYCLE                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  Publisher                  EventBus                    Subscribers      â”‚
â”‚     â”‚                          â”‚                            â”‚            â”‚
â”‚     â”‚ publish(type, data)      â”‚                            â”‚            â”‚
â”‚     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                            â”‚            â”‚
â”‚     â”‚                          â”‚                            â”‚            â”‚
â”‚     â”‚                          â”‚ 1. Add metadata            â”‚            â”‚
â”‚     â”‚                          â”‚    (timestamp, serverId,   â”‚            â”‚
â”‚     â”‚                          â”‚     correlationId)         â”‚            â”‚
â”‚     â”‚                          â”‚                            â”‚            â”‚
â”‚     â”‚                          â”‚ 2. Match patterns          â”‚            â”‚
â”‚     â”‚                          â”‚    (exact, glob, regex)    â”‚            â”‚
â”‚     â”‚                          â”‚                            â”‚            â”‚
â”‚     â”‚                          â”‚ 3. Invoke handlers         â”‚            â”‚
â”‚     â”‚                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚            â”‚
â”‚     â”‚                          â”‚                            â”‚ handler()  â”‚
â”‚     â”‚                          â”‚                            â”‚            â”‚
â”‚     â”‚                          â”‚ 4. Send to adapter         â”‚            â”‚
â”‚     â”‚                          â”‚    (if configured)         â”‚            â”‚
â”‚     â”‚                          â”‚                            â”‚            â”‚
â”‚     â”‚                          â–¼                            â”‚            â”‚
â”‚     â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚            â”‚
â”‚     â”‚                   â”‚   Adapter   â”‚                     â”‚            â”‚
â”‚     â”‚                   â”‚   (Redis)   â”‚                     â”‚            â”‚
â”‚     â”‚                   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                     â”‚            â”‚
â”‚     â”‚                          â”‚                            â”‚            â”‚
â”‚     â”‚                          â”‚ 5. Propagate to other      â”‚            â”‚
â”‚     â”‚                          â”‚    server instances        â”‚            â”‚
â”‚     â”‚                          â”‚                            â”‚            â”‚
â”‚     â”‚                          â–¼                            â”‚            â”‚
â”‚     â”‚                   Other Servers                       â”‚            â”‚
â”‚     â”‚                   (receive & handle)                  â”‚            â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pattern Matching

The event bus supports three pattern types:

```typescript
// 1. Exact match
eventBus.subscribe('user:created', handler);
// Matches: 'user:created'
// Doesn't match: 'user:updated', 'user:created:verified'

// 2. Wildcard (glob) - namespace-aware
eventBus.subscribe('user:*', handler);
// Matches: 'user:created', 'user:updated', 'user:deleted'
// Doesn't match: 'admin:created', 'user:profile:updated'

// 3. Regular expression
eventBus.subscribe(/^(user|admin):created$/, handler);
// Matches: 'user:created', 'admin:created'
// Doesn't match: 'user:updated', 'guest:created'

// 4. Match all events
eventBus.subscribe('*', handler);
// Matches: Every event
```

### Type-Safe Events

BlaizeJS provides a `TypedEventBus` wrapper for compile-time type safety:

```typescript
// Define event schemas
const eventSchemas = {
  'user:created': z.object({
    userId: z.string(),
    email: z.string().email(),
  }),
  'user:updated': z.object({
    userId: z.string(),
    changes: z.record(z.unknown()),
  }),
};

// Create typed event bus
const typedBus = createTypedEventBus(baseBus, {
  schemas: eventSchemas,
  unknownEventBehavior: 'warn', // 'error' | 'warn' | 'allow'
});

// Type-safe publish
await typedBus.publish('user:created', {
  userId: '123',
  email: 'user@example.com',
  // TypeScript error if data doesn't match schema
});

// Type-safe subscribe
typedBus.subscribe('user:created', async (event) => {
  // event.data is typed as { userId: string; email: string }
  await sendWelcomeEmail(event.data.email);
});
```

### Distributed Mode

For multi-server deployments, BlaizeJS supports distributed event propagation via adapters:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      DISTRIBUTED EVENT PROPAGATION                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚  Server A    â”‚     â”‚  Server B    â”‚     â”‚  Server C    â”‚             â”‚
â”‚  â”‚  (serverId)  â”‚     â”‚  (serverId)  â”‚     â”‚  (serverId)  â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚         â”‚                    â”‚                    â”‚                      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                              â”‚                                           â”‚
â”‚                       â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚                       â”‚   Adapter   â”‚                                    â”‚
â”‚                       â”‚   (Redis    â”‚                                    â”‚
â”‚                       â”‚   Pub/Sub)  â”‚                                    â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                                                                          â”‚
â”‚  Features:                                                               â”‚
â”‚  â€¢ Self-filtering: Servers ignore their own events                       â”‚
â”‚  â€¢ Channel-based routing: Events published to pattern-specific channels  â”‚
â”‚  â€¢ Automatic reconnection: Subscriptions restored on reconnect           â”‚
â”‚  â€¢ Circuit breaker: Protects against cascading failures                 â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Example with Redis adapter:**

```typescript
import { RedisEventBusAdapter } from '@blaizejs/adapter-redis';

// Create adapter
const adapter = new RedisEventBusAdapter(redisClient, {
  channelPrefix: 'myapp:events',
});

// Attach to event bus
await server.eventBus.setAdapter(adapter);

// Events now propagate across all connected servers
await server.eventBus.publish('cache:invalidate', {
  key: 'user:123',
});
// All servers receive this event and can invalidate their local caches
```

### Plugin Integration

Plugins use the event bus for coordination and observability:

```typescript
export const createCachePlugin = (config) => {
  return createPlugin({
    name: 'cache',
    setup: async ({ eventBus, logger }) => {
      const cache = new CacheService();
      
      // Publish cache events
      cache.on('set', async (key, value) => {
        await eventBus.publish('cache:set', { key, size: value.length });
      });
      
      cache.on('delete', async (key) => {
        await eventBus.publish('cache:delete', { key });
      });
      
      // Subscribe to invalidation events from other servers
      eventBus.subscribe('cache:invalidate', async (event) => {
        await cache.delete(event.data.key);
        logger.info('Cache invalidated', { key: event.data.key });
      });
      
      return {
        services: { cache },
        initialize: () => cache.connect(),
        terminate: () => cache.disconnect(),
      };
    },
  });
};
```

### SSE Integration

The event bus powers real-time updates via Server-Sent Events:

```typescript
export const getNotifications = createSSERoute({
  schema: {
    params: z.object({ userId: z.string() }),
    events: {
      notification: z.object({
        id: z.string(),
        message: z.string(),
        type: z.enum(['info', 'warning', 'error']),
      }),
    },
  },
  handler: async ({ stream, ctx, params, logger, eventBus }) => {
    // Subscribe to events and stream to client
    const unsubscribe = eventBus.subscribe('notification:*', (event) => {
      stream.send('notification', event.data);
    });
    
    // Cleanup on disconnect
    stream.onClose(() => {
      unsubscribe();
      logger.info('Client disconnected');
    });
  },
});
```

---

## ğŸ”Œ Plugin System

Plugins extend BlaizeJS with additional functionality through a well-defined lifecycle.

### Plugin Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         PLUGIN LIFECYCLE                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  createServer()          server.listen()         server.close()          â”‚
â”‚       â”‚                        â”‚                       â”‚                 â”‚
â”‚       â–¼                        â–¼                       â–¼                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ setup() â”‚â”€â”€â”€â–¶â”‚initialize()â”‚â”€â”€â”€â–¶â”‚onServerStartâ”‚â”€â”€â”€â–¶â”‚terminate â”‚      â”‚
â”‚  â”‚         â”‚    â”‚            â”‚    â”‚     ()      â”‚    â”‚   ()     â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚       â”‚                â”‚                  â”‚                 â”‚            â”‚
â”‚       â”‚                â”‚                  â”‚                 â”‚            â”‚
â”‚  â€¢ Config        â€¢ Connect to      â€¢ Start         â€¢ Disconnect         â”‚
â”‚    merge           external          background      from external      â”‚
â”‚  â€¢ Service         services          tasks           services           â”‚
â”‚    creation      â€¢ Database        â€¢ Subscribe      â€¢ Cleanup           â”‚
â”‚  â€¢ Middleware      init              to events        resources         â”‚
â”‚    register      â€¢ Resource        â€¢ Health         â€¢ Save state        â”‚
â”‚  â€¢ Event           allocation        checks                             â”‚
â”‚    schemas                                                               â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Plugin Structure

```typescript
export const createQueuePlugin = (userConfig?: Partial<QueueConfig>) => {
  return createPlugin<QueueConfig>({
    name: 'queue',
    version: '1.0.0',
    
    setup: async ({ config, logger, eventBus }) => {
      logger.info('Queue plugin setting up');
      
      // Create service
      const queueService = new QueueService({
        queues: config.queues,
        eventBus,  // Plugin receives event bus
        logger,
      });
      
      // Subscribe to events
      eventBus.subscribe('queue:job:*', (event) => {
        logger.debug('Job event', { type: event.type });
      });
      
      return {
        // Inject service into ctx.services
        services: { queue: queueService },
        
        // Called before server starts listening
        initialize: async () => {
          await queueService.connect();
          logger.info('Queue service connected');
        },
        
        // Called after server is listening
        onServerStart: async () => {
          queueService.startWorkers();
          logger.info('Queue workers started');
        },
        
        // Called before server shutdown
        onServerStop: async () => {
          queueService.stopWorkers();
        },
        
        // Called during server shutdown
        terminate: async () => {
          await queueService.disconnect();
          logger.info('Queue service disconnected');
        },
      };
    },
    
    config: {
      ...DEFAULT_CONFIG,
      ...userConfig,
    },
  });
};
```

### Service Injection

Plugins inject services into the context, making them available in routes:

```typescript
// Plugin provides ctx.services.queue
const queuePlugin = createQueuePlugin();

const server = createServer({
  plugins: [queuePlugin],
});

// Route handler can access queue service
export const POST = createPostRoute({
  handler: async (ctx) => {
    // ctx.services.queue is type-safe
    const jobId = await ctx.services.queue.add('default', 'send-email', {
      to: 'user@example.com',
      subject: 'Welcome!',
    });
    
    return { jobId };
  },
});
```

---

## ğŸ—‚ï¸ File-Based Router

Routes are discovered automatically from the file system, following Next.js-style conventions.

### Route File Structure

```
routes/
â”œâ”€â”€ index.ts              â†’ GET /
â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ index.ts          â†’ GET /users
â”‚   â”œâ”€â”€ [userId]/
â”‚   â”‚   â”œâ”€â”€ index.ts      â†’ GET /users/:userId
â”‚   â”‚   â”œâ”€â”€ posts/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts  â†’ GET /users/:userId/posts
â”‚   â”‚   â””â”€â”€ settings.ts   â†’ GET /users/:userId/settings
â”‚   â””â”€â”€ create.ts         â†’ POST /users/create
```

### Route Exports

Each route file exports HTTP method handlers:

```typescript
// routes/users/[userId]/index.ts
import { z } from 'zod';
import { createGetRoute, createPutRoute, createDeleteRoute } from 'blaizejs';

// GET /users/:userId
export const GET = createGetRoute({
  schema: {
    params: z.object({ userId: z.string() }),
    response: userSchema,
  },
  handler: async (ctx, params) => {
    return await db.users.findById(params.userId);
  },
});

// PUT /users/:userId
export const PUT = createPutRoute({
  schema: {
    params: z.object({ userId: z.string() }),
    body: updateUserSchema,
    response: userSchema,
  },
  handler: async (ctx, params) => {
    return await db.users.update(params.userId, ctx.request.body);
  },
});

// DELETE /users/:userId
export const DELETE = createDeleteRoute({
  schema: {
    params: z.object({ userId: z.string() }),
  },
  handler: async (ctx, params) => {
    await db.users.delete(params.userId);
    ctx.response.status(204);
  },
});
```

### File Upload Routes

Routes can accept file uploads alongside regular body data:

```typescript
// routes/users/[userId]/avatar.ts
import { file } from 'blaizejs';

export const PATCH = createPatchRoute({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    files: z.object({
      avatar: file({
        maxSize: '5MB',
        accept: ['image/jpeg', 'image/png', 'image/webp'],
      }),
    }),
    response: z.object({
      avatarUrl: z.string().url(),
    }),
  },
  handler: async ({ ctx, params }) => {
    const { avatar } = ctx.request.files;
    
    // avatar is typed as UploadedFile
    const url = await ctx.services.storage.upload(avatar);
    
    return { avatarUrl: url };
  },
});
```

### Named Exports for RPC

For type-safe RPC, export routes with custom names:

```typescript
// routes/users/[userId]/index.ts
export const getUser = createGetRoute({
  schema: { params: z.object({ userId: z.string() }) },
  handler: async (ctx, params) => {
    return await db.users.findById(params.userId);
  },
});

export const updateUser = createPutRoute({
  schema: {
    params: z.object({ userId: z.string() }),
    body: updateUserSchema,
  },
  handler: async (ctx, params) => {
    return await db.users.update(params.userId, ctx.request.body);
  },
});

export const updateAvatar = createPatchRoute({
  schema: {
    params: z.object({ userId: z.string() }),
    files: z.object({
      avatar: file({ maxSize: '5MB', accept: ['image/*'] }),
    }),
  },
  handler: async ({ ctx, params }) => {
    const { avatar } = ctx.request.files;
    const url = await uploadToStorage(avatar);
    return { avatarUrl: url };
  },
});

// Register in route registry for client
// app-routes.ts
export const routes = {
  getUser,
  updateUser,
  updateAvatar,
} as const;
```

---

## âš ï¸ Error System

BlaizeJS provides 12 semantic error classes that automatically format responses according to RFC 9457 Problem Details.

### Error Class Hierarchy

```typescript
class BlaizeError extends Error {
  type: string;           // Error type identifier
  title: string;          // Human-readable error title
  statusCode: number;     // HTTP status code
  details?: unknown;      // Additional error details
  correlationId: string;  // Request correlation ID
  
  toJSON(): ProblemDetails;
}

// All semantic errors extend BlaizeError
class NotFoundError extends BlaizeError {}
class ValidationError extends BlaizeError {}
class UnauthorizedError extends BlaizeError {}
// ... 9 more error classes
```

### Error Types

| Class | Status | Use Case |
|-------|--------|----------|
| `ValidationError` | 400 | Schema validation failures |
| `UnauthorizedError` | 401 | Missing/invalid authentication |
| `ForbiddenError` | 403 | Authenticated but not authorized |
| `NotFoundError` | 404 | Resource doesn't exist |
| `ConflictError` | 409 | Resource state conflict |
| `UnprocessableEntityError` | 422 | Valid syntax, invalid semantics |
| `PayloadTooLargeError` | 413 | Request body too large |
| `RequestTimeoutError` | 408 | Request took too long |
| `UnsupportedMediaTypeError` | 415 | Wrong content type |
| `RateLimitError` | 429 | Too many requests |
| `InternalServerError` | 500 | Unexpected server error |
| `ServiceNotAvailableError` | 503 | Dependency unavailable |

### Automatic Error Formatting

```typescript
// Route handler throws error
export const getUser = createGetRoute({
  handler: async (ctx, params) => {
    const user = await db.users.findById(params.userId);
    
    if (!user) {
      throw new NotFoundError('User not found', {
        resourceType: 'user',
        resourceId: params.userId,
      });
    }
    
    return user;
  },
});

// Automatic HTTP response:
// HTTP 404 Not Found
// {
//   "type": "NOT_FOUND",
//   "title": "User not found",
//   "status": 404,
//   "correlationId": "req_abc123",
//   "timestamp": "2024-01-15T10:30:00.000Z",
//   "details": {
//     "resourceType": "user",
//     "resourceId": "123"
//   }
// }
```

---

## ğŸ“¡ Real-Time (SSE) Architecture

Server-Sent Events provide typed, unidirectional streaming.

### SSE Route Definition

```typescript
export const getEvents = createSSERoute({
  schema: {
    query: z.object({ pattern: z.string().optional() }),
    events: {
      'data.changed': z.object({
        key: z.string(),
        type: z.enum(['set', 'delete']),
        timestamp: z.number(),
      }),
      heartbeat: z.object({
        timestamp: z.number(),
      }),
    },
  },
  handler: async (stream, ctx, params, logger) => {
    const pattern = ctx.request.query.pattern || '*';
    
    // Subscribe to events and stream to client
    const unsubscribe = ctx.eventBus.subscribe(pattern, (event) => {
      stream.send('data.changed', event.data);
    });
    
    // Send heartbeat every 30 seconds
    const heartbeat = setInterval(() => {
      stream.send('heartbeat', { timestamp: Date.now() });
    }, 30000);
    
    // Cleanup on disconnect
    stream.onClose(() => {
      clearInterval(heartbeat);
      unsubscribe();
      logger.info('Client disconnected');
    });
  },
});
```

### SSE Handler Signature

```typescript
handler: async (
  stream: TypedSSEStream,  // Send typed events
  ctx: Context,            // Request context
  params: ValidatedParams, // Validated params
  logger: BlaizeLogger     // Logger instance
) => {
  // SSE handler body
}
```

### Event Schema Validation

Events are validated at send time:

```typescript
// stream.send validates against the event schema
stream.send('data.changed', {
  key: 'user:123',
  type: 'set',
  timestamp: Date.now(),
  // TypeScript error if data doesn't match schema
});
```

### SSE Connection Flow

```
Client connects (EventSource)
    â”‚
    â–¼
Server sends headers (text/event-stream)
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Connection maintained                    â”‚
â”‚   â”‚                                       â”‚
â”‚   â”œâ”€â”€â–¶ stream.send('event', data) â”€â”€â–¶ Client receives
â”‚   â”œâ”€â”€â–¶ stream.send('event', data) â”€â”€â–¶ Client receives
â”‚   â”œâ”€â”€â–¶ stream.send('event', data) â”€â”€â–¶ Client receives
â”‚   â”‚                                       â”‚
â”‚   â”‚  Client disconnects or network fails  â”‚
â”‚   â–¼                                       â”‚
â”‚  stream.onClose() fires                   â”‚
â”‚  Cleanup subscriptions                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš™ï¸ Background Jobs Architecture

The queue plugin provides integrated background job processing with SSE progress streaming.

### Job Processing Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          JOB PROCESSING FLOW                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  POST /jobs                                                              â”‚
â”‚      â”‚                                                                   â”‚
â”‚      â–¼                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚  Enqueue Job â”‚â”€â”€â”€â”€â–¶â”‚  Job Storage â”‚â—€â”€â”€â”€â”€â”‚    Worker    â”‚             â”‚
â”‚  â”‚  (priority)  â”‚     â”‚   (in-memory â”‚     â”‚   Process    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚   or Redis)  â”‚     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚                      â”‚
â”‚                                                   â”‚                      â”‚
â”‚                                                   â–¼                      â”‚
â”‚                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚                                        â”‚  Job Handler     â”‚              â”‚
â”‚                                        â”‚  â€¢ ctx.progress()â”‚              â”‚
â”‚                                        â”‚  â€¢ ctx.logger    â”‚              â”‚
â”‚                                        â”‚  â€¢ ctx.data      â”‚              â”‚
â”‚                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                 â”‚                        â”‚
â”‚                                                 â”‚ Publishes events       â”‚
â”‚                                                 â–¼                        â”‚
â”‚                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚                                        â”‚   Event Bus     â”‚               â”‚
â”‚                                        â”‚  â€¢ job:started  â”‚               â”‚
â”‚                                        â”‚  â€¢ job:progress â”‚               â”‚
â”‚                                        â”‚  â€¢ job:completedâ”‚               â”‚
â”‚                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                 â”‚                        â”‚
â”‚                                                 â–¼                        â”‚
â”‚  GET /jobs/:jobId/stream                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚      â”‚                                   â”‚ SSE Route   â”‚                 â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Streams    â”‚                 â”‚
â”‚                                          â”‚   Events    â”‚                 â”‚
â”‚                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Job Handler Context

```typescript
const emailHandler = async (ctx: JobContext<EmailData>) => {
  // ctx.data: Validated job data
  // ctx.logger: Logger with job context
  // ctx.progress(percent, message): Report progress
  
  ctx.progress(10, 'Fetching template');
  const template = await getTemplate(ctx.data.templateId);
  
  ctx.progress(40, 'Rendering email');
  const html = await renderTemplate(template, ctx.data.params);
  
  ctx.progress(70, 'Sending email');
  await sendEmail(ctx.data.to, html);
  
  ctx.progress(100, 'Complete');
  
  return { sentAt: Date.now() };
};
```

### Job Events

The queue plugin publishes these events:

| Event | When | Data |
|-------|------|------|
| `queue:job:enqueued` | Job added to queue | `{ jobId, jobType, priority }` |
| `queue:job:started` | Job execution begins | `{ jobId, jobType }` |
| `queue:job:progress` | Progress reported | `{ jobId, percent, message }` |
| `queue:job:completed` | Job finishes successfully | `{ jobId, result }` |
| `queue:job:failed` | Job throws error | `{ jobId, error }` |
| `queue:job:cancelled` | Job cancelled | `{ jobId, reason }` |

### SSE Progress Streaming

```typescript
export const getJobStream = createSSERoute({
  schema: {
    query: z.object({ jobId: z.string() }),
    events: {
      'job.started': z.object({ jobId: z.string() }),
      'job.progress': z.object({ 
        jobId: z.string(),
        percent: z.number(),
        message: z.string().optional(),
      }),
      'job.completed': z.object({ 
        jobId: z.string(),
        result: z.unknown(),
      }),
    },
  },
  handler: async (stream, ctx, params, logger) => {
    const { jobId } = ctx.request.query;
    
    // Subscribe to job events
    const unsubscribe = ctx.eventBus.subscribe('queue:job:*', (event) => {
      if (event.data.jobId === jobId) {
        stream.send(event.type.replace('queue:', ''), event.data);
      }
    });
    
    stream.onClose(() => {
      unsubscribe();
    });
  },
});
```

---

## ğŸ“¦ Package Dependencies

The BlaizeJS packages have these relationships:

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ @blaizejs/types â”‚
                    â”‚   (shared TS    â”‚
                    â”‚     types)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚              â”‚              â”‚
              â–¼              â–¼              â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ blaizejs  â”‚  â”‚ @blaizejs/    â”‚  â”‚ @blaizejs/         â”‚
      â”‚  (core)   â”‚  â”‚    client     â”‚  â”‚  testing-utils     â”‚
      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â”‚ Peer dependency
            â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚         â”‚                 â”‚                    â”‚
  â–¼         â–¼                 â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ @blaizejs/      â”‚  â”‚ @blaizejs/      â”‚  â”‚ @blaizejs/      â”‚
â”‚  plugin-queue   â”‚  â”‚  plugin-cache   â”‚  â”‚  plugin-metrics â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                             â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚              â”‚              â”‚
              â–¼              â–¼              â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ @blaizejs/  â”‚  â”‚ @blaizejs/  â”‚  â”‚ @blaizejs/  â”‚
      â”‚ adapter-    â”‚  â”‚ adapter-    â”‚  â”‚ middleware- â”‚
      â”‚  redis      â”‚  â”‚  postgres   â”‚  â”‚  security   â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Package roles:**

| Package | Role | Dependencies |
|---------|------|--------------|
| `@blaizejs/types` | Shared TypeScript types | None |
| `blaizejs` | Core framework | `@blaizejs/types`, `zod` |
| `@blaizejs/client` | RPC client | `@blaizejs/types` |
| `@blaizejs/testing-utils` | Test helpers | `blaizejs` (peer) |
| `@blaizejs/plugin-*` | Feature plugins | `blaizejs` (peer) |
| `@blaizejs/adapter-*` | Storage/event adapters | Plugin-specific |
| `@blaizejs/middleware-*` | Middleware packages | `blaizejs` (peer) |

---

## ğŸ—ï¸ Design Decisions

### Why HTTP/2 by Default?

**Decision:** BlaizeJS uses HTTP/2 as the default protocol.

**Rationale:**
- **Multiplexing:** Multiple requests over single connection reduces latency
- **Header compression:** HPACK reduces overhead for API calls with similar headers
- **Server push ready:** Future optimization path for preloading resources
- **Modern baseline:** All modern browsers and clients support HTTP/2

**Tradeoffs:**
- Requires HTTPS (self-signed cert generated for local dev)
- Slightly more complex debugging (need HTTP/2-aware tools)
- Some corporate proxies still struggle with HTTP/2

**Fallback:** HTTP/1.1 is fully supported via `{ http2: false }` option.

### Why AsyncLocalStorage for Context?

**Decision:** Request context is stored in Node.js AsyncLocalStorage.

**Rationale:**
- **No prop drilling:** Access context anywhere without passing through every function
- **Automatic propagation:** Works across async boundaries, promises, callbacks
- **Clean handler signatures:** Handlers don't need context passed through middleware chain
- **Event bus integration:** Correlation IDs automatically propagate through event handlers

**Tradeoffs:**
- Node.js specific (not portable to edge runtimes yet)
- Small performance overhead (~2-5% in microbenchmarks)
- Debugging can be confusing without understanding async context

**Alternative considered:** Explicit context passing (like Koa). Rejected due to verbosity.

### Why File-Based Routing?

**Decision:** Routes are discovered from the file system.

**Rationale:**
- **Convention over configuration:** URL structure is visible in file tree
- **Colocation:** Route, schema, and middleware live together
- **Familiarity:** Developers coming from Next.js, Remix, SvelteKit feel at home
- **Tooling friendly:** Static analysis can understand routes

**Tradeoffs:**
- Less flexible than programmatic routing
- Dynamic route registration requires workarounds
- IDE support for route linking varies

**Escape hatch:** Programmatic route registration is possible via `server.register()`.

### Why Zod for Schemas?

**Decision:** Zod is the default (and currently only) schema library.

**Rationale:**
- **Best-in-class inference:** `z.infer<>` provides accurate types
- **Runtime + compile time:** Same schema validates and types
- **Ecosystem:** Most popular TypeScript validation library
- **Composable:** Schemas can extend, merge, and transform

**Tradeoffs:**
- Locked to Zod (no Yup, Joi, ArkType support yet)
- Bundle size (~10kb gzipped)
- Learning curve for complex schemas

**Future:** May add adapter pattern for alternative schema libraries.

### Why Not WebSockets?

**Decision:** Real-time features use SSE instead of WebSockets.

**Rationale:**
- **Simpler protocol:** SSE is just HTTP with streaming
- **Unidirectional sufficient:** Most real-time needs are server â†’ client
- **HTTP/2 compensates:** Multiplexing eliminates SSE's connection limit
- **Easier debugging:** Standard HTTP tools work
- **Better compatibility:** Works through more proxies and load balancers

**Tradeoffs:**
- No bidirectional real-time (use POST + SSE pattern)
- Browser EventSource API is less flexible than WebSocket
- Some use cases genuinely need WebSocket (games, collaborative editing)

**Pattern:** For bidirectional communication, use POST requests for client â†’ server and SSE for server â†’ client. This pattern covers most real-time application needs.

### Why Built-In Event Bus?

**Decision:** BlaizeJS includes a first-class event bus as a core primitive.

**Rationale:**
- **Decoupled architecture:** Plugins and services communicate without direct dependencies
- **Real-time foundation:** SSE routes naturally integrate with event subscriptions
- **Distributed coordination:** Optional adapters enable cross-server event propagation
- **Developer experience:** No need to integrate external pub/sub libraries
- **Type safety:** TypedEventBus provides compile-time guarantees

**Tradeoffs:**
- Adds complexity to core framework
- Another pattern developers need to learn
- May be overkill for simple applications

**Alternative:** External event bus libraries (Redis pub/sub, EventEmitter3). Rejected because tight integration with SSE, plugins, and correlation IDs provides better DX.

### Why Memory-Based File Upload Strategy?

**Decision:** BlaizeJS buffers uploaded files in memory by default.

**Rationale:**
- **Simplicity:** Handler receives complete `Buffer` object, no stream handling needed
- **Type safety:** `UploadedFile` interface is consistent and predictable
- **Fast access:** No disk I/O for validation or processing
- **Cloud-native:** Most deployments stream directly to S3/R2 anyway
- **Validation first:** Size/MIME checks happen before handler execution

**Tradeoffs:**
- Memory usage scales with file size and concurrency
- Not suitable for very large files (>100MB)
- Serverless environments have memory limits

**Future:** Streaming strategy for large files, temp file strategy for disk-based processing.

**Best practice:** Set reasonable `maxSize` limits (5-50MB) and stream large uploads directly to object storage.

---

## ğŸ”® Future Architecture Considerations

These are potential future directions being considered:

### Edge Runtime Support

Adapting the core to run on edge platforms:
- Cloudflare Workers
- Deno Deploy
- Vercel Edge Functions
- Bun

This requires abstracting Node.js-specific APIs (AsyncLocalStorage, file system) behind platform adapters.

### HTTP/2 Hosting Solutions

Improving deployment options for HTTP/2:
- Simplified reverse proxy configurations
- Cloud provider integration guides
- Container-ready HTTP/2 setups
- Load balancer compatibility patterns

### Plugin & Middleware Ecosystem

Expanding the official plugin ecosystem:
- Additional storage adapters (DynamoDB, MongoDB, etc.)
- Authentication plugins (OAuth, JWT, session)
- Rate limiting middleware
- Compression middleware
- Request validation enhancements

### External Queue Workers

Enhancing the queue plugin for distributed processing:
- External worker process support
- Redis-backed job storage
- Cross-service job coordination
- Horizontal scaling patterns

### Streaming File Upload Strategy

Alternative upload strategies for different use cases:
- **Stream strategy:** Direct S3 upload without buffering
- **Temp file strategy:** Disk-based processing for large files
- **Chunked uploads:** Resume support for unreliable networks
- **Progress callbacks:** Real-time upload progress via SSE

### AI Integrations

Deeper integration with AI/ML workflows:
- Streaming response helpers for LLM outputs
- Token-aware rate limiting
- AI provider SDK integrations
- Prompt management patterns

### Distributed Tracing

OpenTelemetry integration for:
- Automatic span creation per request
- Trace propagation to downstream services
- Metric export to observability platforms
- Correlation ID integration with traces
- Event bus span tracking

### Event Bus Enhancements

Potential improvements to the event bus:
- Dead letter queue support
- Event replay capabilities
- Event sourcing patterns
- Saga/workflow orchestration
- Event schema versioning

---

## ğŸ“š Further Reading

- [Getting Started Guide](../docs/getting-started.md) â€” Build your first BlaizeJS app
- [Event Bus Architecture](./event-bus.md) â€” Deep dive into event-driven patterns
- [File Uploads Guide](../docs/guides/file-uploads.md) â€” Complete file upload examples
- [Core Package API](../packages/blaize-core/README.md) â€” Full API reference
- [Plugin Development Guide](../docs/guides/plugins.md) â€” Create custom plugins
- [Contributing Guide](../CONTRIBUTING.md) â€” Help improve BlaizeJS