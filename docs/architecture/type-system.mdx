# ğŸ”· Type system

> Types flow from your Zod schemas through your handlers to your client â€” no code generation, no manual syncing, no runtime overhead.

---

## The big picture

BlaizeJS achieves end-to-end type safety through a chain of TypeScript inference. Each step passes types to the next, creating an unbroken flow from server to client:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Zod Schema    â”‚â”€â”€â”€â”€â–¶â”‚  Route Factory  â”‚â”€â”€â”€â”€â–¶â”‚  Route Export   â”‚
â”‚   (Runtime)     â”‚     â”‚   route.get()   â”‚     â”‚   getUser       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                       â”‚                       â”‚
        â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  z.infer<T>     â”‚     â”‚ InferContext<>  â”‚     â”‚ typeof routes   â”‚
â”‚  Params, Body   â”‚     â”‚ State, Services â”‚     â”‚   Registry      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                        â”‚
                                                        â–¼
                                                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                â”‚  Client Proxy   â”‚
                                                â”‚  bc.create()    â”‚
                                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                        â”‚
                                                        â–¼
                                                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                â”‚  Autocomplete   â”‚
                                                â”‚  & Type Check   â”‚
                                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**The key insight:** TypeScript infers types at each step without generating any code. The types exist only at compile time â€” zero runtime overhead.

---

## Schema-driven types

Zod schemas define both runtime validation and TypeScript types. The `z.infer<T>` utility extracts the TypeScript type from any Zod schema:

```typescript
import { z } from 'zod';

// Define a schema
const userSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  email: z.string().email(),
  role: z.enum(['admin', 'user', 'guest']),
  createdAt: z.coerce.date(),
});

// Extract the TypeScript type
type User = z.infer<typeof userSchema>;
// Equivalent to:
// type User = {
//   id: string;
//   name: string;
//   email: string;
//   role: 'admin' | 'user' | 'guest';
//   createdAt: Date;
// }
```

### Schema in routes

When you provide schemas to a route, BlaizeJS infers types for:

| Schema Property | Infers Type For     | Used In                    |
| --------------- | ------------------- | -------------------------- |
| `params`        | `params` argument   | `handler({ ctx, params })` |
| `query`         | `ctx.request.query` | Handler body               |
| `body`          | `ctx.request.body`  | Handler body               |
| `files`         | `ctx.request.files` | Handler body               |
| `response`      | Return type         | Handler return             |

```typescript
export const getUser = route.get({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    query: z.object({ include: z.array(z.string()).optional() }),
    response: z.object({
      id: z.string(),
      name: z.string(),
      posts: z.array(postSchema).optional(),
    }),
  },
  handler: async ({ ctx, params }) => {
    // params.userId is typed as string âœ…
    // ctx.request.query.include is typed as string[] | undefined âœ…

    const user = await ctx.services.db.users.findById(params.userId);

    // Return type must match response schema âœ…
    return {
      id: user.id,
      name: user.name,
      posts: ctx.request.query.include?.includes('posts') ? user.posts : undefined,
    };
  },
});
```

### Transforms work too

Zod's `.transform()` method modifies the output type, and BlaizeJS respects this:

```typescript
export const getUser = route.get({
  schema: {
    params: z.object({
      // Input: string from URL â†’ Output: number after transform
      userId: z.string().transform(s => parseInt(s, 10)),
    }),
    query: z.object({
      // "true" string â†’ true boolean
      includeDeleted: z
        .string()
        .optional()
        .transform(val => val === 'true'),
    }),
  },
  handler: async ({ ctx, params }) => {
    params.userId; // number (not string!)
    ctx.request.query.includeDeleted; // boolean | undefined
  },
});
```

### Coercion helpers

Zod's `z.coerce` is especially useful for query parameters:

```typescript
const paginationSchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  sortDesc: z.coerce.boolean().default(false),
});

export const listUsers = route.get({
  schema: { query: paginationSchema },
  handler: async ({ ctx }) => {
    // All typed as their final types, not strings
    ctx.request.query.page; // number
    ctx.request.query.limit; // number
    ctx.request.query.sortDesc; // boolean
  },
});
```

---

## File upload type flow

File uploads introduce a fourth type parameter that flows through the entire system with automatic client-server type transformation.

### Type parameter evolution

The route schema includes a `files` property that works alongside `body`:

```typescript
// Route schema with file uploads
export const uploadAvatar = route.post({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    files: z.object({
      avatar: file({
        maxSize: '5MB',
        accept: ['image/jpeg', 'image/png', 'image/webp'],
      }),
    }),
    response: z.object({
      url: z.string().url(),
      filename: z.string(),
      size: z.number(),
    }),
  },
  handler: async ({ ctx, params }) => {
    // ctx.request.files.avatar is typed as UploadedFile
    const { avatar } = ctx.request.files;

    // All properties are fully typed
    console.log(avatar.originalname); // string
    console.log(avatar.mimetype); // string
    console.log(avatar.size); // number
    console.log(avatar.buffer); // Buffer | undefined

    const url = await uploadToStorage(avatar);

    return {
      url,
      filename: avatar.originalname,
      size: avatar.size,
    };
  },
});
```

### Client-server type transformation

The same schema creates different types on client vs server:

```typescript
// Client code
import bc from '@blaizejs/client';
import { routes } from './app-type';

const client = bc.create('https://api.example.com', routes);

// Client expects File/Blob (browser native)
const file = document.querySelector('input[type="file"]').files[0];

const result = await client.$post.uploadAvatar({
  params: { userId: 'user-123' },
  files: {
    avatar: file, // Type: File (browser native)
  },
});

// result is fully typed from response schema
console.log(result.url); // string (known at compile time)
console.log(result.filename); // string
console.log(result.size); // number
```

### Type transformation flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CLIENT (Browser/Node)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  file() schema â†’ ClientFilesType<F>                             â”‚
â”‚  - Extracts schema shape                                         â”‚
â”‚  - Maps to File/Blob types                                       â”‚
â”‚  - Handles optional/array modifiers                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
                    FormData serialization
                  (multipart/form-data)
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SERVER (BlaizeJS)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Multipart parser â†’ { fields, files }                            â”‚
â”‚  file() schema â†’ z.ZodType<UploadedFile>                        â”‚
â”‚  - Validates MIME type                                           â”‚
â”‚  - Validates file size                                           â”‚
â”‚  - Custom refinements                                            â”‚
â”‚  â†“                                                               â”‚
â”‚  Handler receives typed UploadedFile                             â”‚
â”‚  - originalname: string                                          â”‚
â”‚  - mimetype: string                                              â”‚
â”‚  - size: number                                                  â”‚
â”‚  - buffer: Buffer                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Type transformation table

| Location             | Type                  | Source              | Description                              |
| -------------------- | --------------------- | ------------------- | ---------------------------------------- |
| **Client schema**    | `File` or `Blob`      | Browser API         | Native browser file objects              |
| **Wire format**      | `multipart/form-data` | HTTP protocol       | Binary encoding with boundary            |
| **Multipart parser** | `UploadedFile`        | Server-side parsing | Parsed file with buffer/stream           |
| **Validation layer** | `UploadedFile`        | Zod schema          | Validated against size/MIME constraints  |
| **Handler context**  | `UploadedFile`        | Type inference      | Type-safe access via `ctx.request.files` |

### Complex file schema patterns

```typescript
// Pattern 1: Single required file
files: z.object({
  avatar: file({ maxSize: '5MB' }),
});
// Client: { files: { avatar: File } }
// Server: { avatar: UploadedFile }

// Pattern 2: Optional file
files: z.object({
  avatar: file({ maxSize: '5MB' }).optional(),
});
// Client: { files: { avatar?: File } }
// Server: { avatar?: UploadedFile }

// Pattern 3: Array of files
files: z.object({
  photos: file({ maxSize: '5MB' }).array(),
});
// Client: { files: { photos: File[] } }
// Server: { photos: UploadedFile[] }

// Pattern 4: Multiple different files
files: z.object({
  avatar: file({ maxSize: '5MB', accept: ['image/*'] }),
  resume: file({ maxSize: '10MB', accept: ['application/pdf'] }),
  portfolio: file({ maxSize: '50MB' }).array().optional(),
});
// Client: { files: { avatar: File, resume: File, portfolio?: File[] } }
// Server: { avatar: UploadedFile, resume: UploadedFile, portfolio?: UploadedFile[] }
```

### Mixed body + files type flow

When combining body data with file uploads, both are fully typed:

```typescript
export const createPost = route.post({
  schema: {
    body: z.object({
      title: z.string().min(1),
      content: z.string(),
      category: z.enum(['tech', 'design', 'business']),
      tags: z.array(z.string()).optional(),
    }),
    files: z.object({
      coverImage: file({ maxSize: '2MB', accept: ['image/*'] }),
      attachments: file({ maxSize: '10MB' }).array().optional(),
    }),
  },
  handler: async ({ ctx }) => {
    // Body is typed
    const { title, content, category, tags } = ctx.request.body;
    // title: string
    // content: string
    // category: 'tech' | 'design' | 'business'
    // tags: string[] | undefined

    // Files are typed
    const { coverImage, attachments } = ctx.request.files;
    // coverImage: UploadedFile
    // attachments: UploadedFile[] | undefined

    // Both validate before handler execution
  },
});

// Client usage - both typed
await client.$post.createPost({
  body: {
    title: 'My Post',
    content: '...',
    category: 'tech',
    tags: ['typescript', 'backend'],
  },
  files: {
    coverImage: imageFile,
    attachments: [doc1, doc2],
  },
});
```

---

## Context type composition

The `InferContext` utility type extracts the combined state and services types from your server:

```typescript
import { Blaize, type InferContext } from 'blaizejs';

// Server with middleware that adds to state/services
const server = Blaize.createServer({
  middleware: [authMiddleware, loggingMiddleware],
  plugins: [databasePlugin(), cachePlugin()],
});

// Extract the composed context type
type AppContext = InferContext<typeof server>;

// AppContext has two key properties:
// - AppContext['state']    â†’ Combined state from all middleware
// - AppContext['services'] â†’ Combined services from all plugins
```

### Type accumulation: Recommended approach

**Best practice:** Pass middleware and plugins directly to `createServer()`:

```typescript
const server = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
  middleware: [authMiddleware, loggingMiddleware],
  plugins: [databasePlugin(), cachePlugin()],
});

type AppContext = InferContext<typeof server>;
// All types included âœ…
```

**Why this is best:**

- âœ… Types accumulate automatically
- âœ… All configuration in one place
- âœ… Clear, declarative setup
- âœ… No risk of forgetting to capture return values

### Alternative: Chaining

Chain `.use()` and `.register()` calls, capturing the final result:

```typescript
const server = Blaize.createServer({ port: 7485, routesDir: './src/routes' })
  .use(authMiddleware)
  .use(loggingMiddleware)
  .register(databasePlugin())
  .register(cachePlugin());

type AppContext = InferContext<typeof server>;
// All types included âœ…
```

**Best for:** Clean, readable setup when order matters.

### Special cases: Reassignment

Capture each return value in a new variable:

```typescript
const base = Blaize.createServer({ port: 7485, routesDir: './src/routes' });
const serverWithAuth = base.use(authMiddleware);
const serverWithLogging = serverWithAuth.use(loggingMiddleware);
const serverWithDb = serverWithLogging.register(databasePlugin());
const server = serverWithDb.register(cachePlugin());

type AppContext = InferContext<typeof server>;
// All types included âœ…
```

**Best for:** Conditional middleware, complex setup logic, debugging.

```typescript
// Example: Conditional middleware
const base = Blaize.createServer({ port: 7485, routesDir: './src/routes' });
const withAuth = base.use(authMiddleware);

const server =
  process.env.NODE_ENV === 'production'
    ? withAuth.use(rateLimitMiddleware).register(metricsPlugin())
    : withAuth;

type AppContext = InferContext<typeof server>;
```

### âŒ What NOT to do

Don't ignore the return value â€” types will be lost:

```typescript
const server = Blaize.createServer({ port: 7485, routesDir: './src/routes' });
server.use(authMiddleware); // âŒ Return value ignored!
server.register(databasePlugin()); // âŒ Return value ignored!

type AppContext = InferContext<typeof server>;
// AppContext['state'] = {}       â† Missing user!
// AppContext['services'] = {}    â† Missing db!
```

**Why this happens:** `.use()` and `.register()` return a _new_ server instance with updated types. They don't mutate the original. TypeScript tracks types through return values, so ignoring them means losing the type information.

### How types compose

Each middleware declares what it adds:

```typescript
// Auth middleware adds user to state
const authMiddleware = createMiddleware<
  { user: User; isAuthenticated: boolean },  // State additions
  { auth: AuthService }                       // Service additions
>({ ... });

// Logging middleware adds requestId to state
const loggingMiddleware = createMiddleware<
  { requestId: string; startTime: number },
  { logger: Logger }
>({ ... });

// Database plugin adds db to services (via internal middleware)
const databasePlugin = createPlugin<{}, {}, { db: Database }>({
  name: 'database',
  version: '1.0.0',
  setup: (config, logger) => ({
    register: async (server) => {
      server.use(createMiddleware<{}, { db: Database }>({ ... }));
    },
  }),
});
```

When combined on the server, TypeScript intersects all the types:

```typescript
const server = Blaize.createServer({
  middleware: [authMiddleware, loggingMiddleware],
  plugins: [databasePlugin()],
});

type AppContext = InferContext<typeof server>;
// AppContext['state'] = {
//   user: User;
//   isAuthenticated: boolean;
//   requestId: string;
//   startTime: number;
// }
// AppContext['services'] = {
//   auth: AuthService;
//   logger: Logger;
//   db: Database;
// }
```

---

## Route factory pattern

The route factory carries context types to all routes:

```typescript
// 1. Create server using recommended approach
const server = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
  middleware: [authMiddleware],
  plugins: [databasePlugin()],
});

// 2. Extract context types from final server
type AppContext = InferContext<typeof server>;

// 3. Create route factory with those types
export const route = Blaize.Router.createRouteFactory<
  AppContext['state'], // Passed to all route handlers
  AppContext['services'] // Passed to all route handlers
>();

// 4. Start the server
await server.listen();
```

Now in route files, types flow automatically:

```typescript
// src/routes/users.ts
import { route } from '../app';

export const listUsers = route.get({
  handler: async ({ ctx, params }) => {
    ctx.state.user; // âœ… Typed as User
    ctx.services.db; // âœ… Typed as Database
  },
});
```

### Why a factory?

The factory pattern solves a key problem: how do route files know about types defined in the server file?

```
src/
â”œâ”€â”€ app.ts              â† Server created, types inferred
â”‚   â””â”€â”€ route exported  â† Factory carries types
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ users.ts        â† Imports route, gets types
â”‚   â””â”€â”€ posts.ts        â† Imports route, gets types
```

Each route file imports the same `route` factory, ensuring consistent types everywhere:

```typescript
// src/routes/users.ts
import { route } from '../app';

export const listUsers = route.get({
  handler: async ({ ctx }) => {
    // Types available because route factory was created
    // with AppContext['state'] and AppContext['services']
    ctx.state.user;
    ctx.services.db;
  },
});
```

### Factory methods

The route factory provides methods for all HTTP verbs:

| Method            | HTTP Verb | Body | Files | Common Use         |
| ----------------- | --------- | ---- | ----- | ------------------ |
| `route.get()`     | GET       | No   | No    | Fetch resources    |
| `route.post()`    | POST      | Yes  | Yes   | Create resources   |
| `route.put()`     | PUT       | Yes  | Yes   | Replace resources  |
| `route.patch()`   | PATCH     | Yes  | Yes   | Partial update     |
| `route.delete()`  | DELETE    | No   | No    | Remove resources   |
| `route.head()`    | HEAD      | No   | No    | Headers only       |
| `route.options()` | OPTIONS   | No   | No    | CORS preflight     |
| `route.sse()`     | GET       | No   | No    | Server-Sent Events |

---

## Middleware type flow

Middleware declares its type contributions via generics:

```typescript
const authMiddleware = createMiddleware<
  { user: User }, // Adds to ctx.state
  { auth: AuthService } // Adds to ctx.services
>({
  name: 'auth',
  handler: async ({ ctx, next }) => {
    // Before: ctx.state.user doesn't exist
    ctx.state.user = await validateToken(/*...*/);
    ctx.services.auth = authService;
    // After: ctx.state.user exists for downstream
    await next();
  },
});
```

### Type safety within middleware

Inside the middleware handler, you can safely assign to the declared types:

```typescript
const authMiddleware = createMiddleware<{ user: User; permissions: string[] }, {}>({
  handler: async ({ ctx, next }) => {
    // âœ… TypeScript knows these properties should be assigned
    ctx.state.user = await getUser();
    ctx.state.permissions = await getPermissions(ctx.state.user.id);

    // âŒ TypeScript would error if you tried:
    // ctx.state.wrongProperty = 'value';

    await next();
  },
});
```

### Composition at server level

When you add middleware to the server, types compose automatically â€” but remember to capture return values or use server config:

```typescript
// Recommended: Server config
const server = Blaize.createServer({
  middleware: [
    authMiddleware, // Adds { user } to state
    loggingMiddleware, // Adds { requestId } to state
    cacheMiddleware, // Adds { cache } to services
  ],
});

// Types are intersected on `server`
type AppContext = InferContext<typeof server>;
// state: { user: User } & { requestId: string }
// services: { cache: CacheService }
```

```typescript
// Alternative: Chaining
const server = Blaize.createServer()
  .use(authMiddleware) // Adds { user } to state
  .use(loggingMiddleware) // Adds { requestId } to state
  .use(cacheMiddleware); // Adds { cache } to services

type AppContext = InferContext<typeof server>;
```

```typescript
// Special cases: Step-by-step (useful for conditional middleware)
const base = Blaize.createServer();
const withAuth = base.use(authMiddleware);
const withLogging = withAuth.use(loggingMiddleware);
const server = process.env.ENABLE_CACHE ? withLogging.use(cacheMiddleware) : withLogging;

type AppContext = InferContext<typeof server>;
```

---

## Plugin type flow

Plugins add types through the middleware they register:

```typescript
const databasePlugin = createPlugin<
  { url: string }, // Config
  {}, // State (none)
  { db: Database } // Services
>({
  name: 'database',
  version: '1.0.0',
  setup: (config, logger) => {
    let db: Database; // Singleton via closure

    return {
      // Plugin registers middleware that provides the service
      register: async server => {
        server.use(
          createMiddleware<{}, { db: Database }>({
            name: 'database-provider',
            handler: async ({ ctx, next }) => {
              ctx.services.db = db; // Inject the singleton
              await next();
            },
          })
        );
      },
      initialize: async () => {
        db = await Database.connect(config.url);
        logger.info('Database connected');
      },
      terminate: async () => {
        await db.disconnect();
        logger.info('Database disconnected');
      },
    };
  },
});
```

When the plugin is added to the server, its middleware types flow through:

```typescript
const server = Blaize.createServer({
  plugins: [databasePlugin({ url: process.env.DATABASE_URL })],
});

type AppContext = InferContext<typeof server>;
// AppContext['services'] includes { db: Database }
```

---

## Client type inference

The client infers types from your route exports:

### Step 1: Export routes with names

```typescript
// src/app-type.ts
import { getUser } from './routes/users/[userId]';
import { listUsers, createUser } from './routes/users';
import { updateAvatar } from './routes/users/[userId]/avatar';
import { login } from './routes/auth/login';

// Export with meaningful names â€” these become method names
export const routes = {
  getUser,
  listUsers,
  createUser,
  updateAvatar,
  login,
} as const; // as const is important!
```

### Step 2: Create typed client

```typescript
// client.ts
import bc from '@blaizejs/client';
import { routes } from './server/app-type';

// Client infers all types from routes
const client = bc.create('https://api.example.com', routes);
```

### Step 3: Use with full type safety

```typescript
// âœ… Method name from export name
const user = await client.$get.getUser({
  params: { userId: '123' }, // Typed from params schema
});
// user is typed from response schema

// âœ… Body typed from schema
const newUser = await client.$post.createUser({
  body: {
    name: 'Alice', // Required
    email: 'a@b.com', // Required, must be email
  },
});

// âœ… Files typed from schema - client auto-detects and uses multipart
const file = document.querySelector('input[type="file"]').files[0];
await client.$patch.updateAvatar({
  params: { userId: '123' },
  files: { avatar: file },
});

// âŒ TypeScript catches errors
await client.$get.getUser({
  params: { wrongParam: '123' }, // Error: 'wrongParam' not in params
});

await client.$post.createUser({
  body: { name: 'Alice' }, // Error: 'email' is required
});
```

### Why export names matter

The client method names come from your export names, not file paths:

```typescript
// File: src/routes/users/[userId].ts
export const getUser = route.get({ ... });

// In app-type.ts, you use the export name directly:
import { getUser } from './routes/users/[userId]';
export const routes = { getUser } as const;

// Client uses that name:
client.$get.getUser({ ... });  // Not "getUserId" or "[userId]"
```

This gives you control over the client API regardless of file structure.

---

## Type boundaries

Understanding where inference works vs. where you need explicit types:

### Inference works

| Scenario                | Types Flow Automatically                        |
| ----------------------- | ----------------------------------------------- |
| Schema â†’ Handler params | `params.userId` typed from `schema.params`      |
| Schema â†’ Handler body   | `ctx.request.body` typed from `schema.body`     |
| Schema â†’ Handler files  | `ctx.request.files` typed from `schema.files`   |
| Schema â†’ Handler return | Return type checked against `schema.response`   |
| Middleware â†’ Context    | `ctx.state.user` typed from middleware generics |
| Route export â†’ Client   | Client methods typed from route exports         |

### Explicit types needed

| Scenario           | Why                                          | Solution                      |
| ------------------ | -------------------------------------------- | ----------------------------- |
| Helper functions   | Not connected to route context               | Pass `ctx` as typed parameter |
| External libraries | Not aware of your schemas                    | Cast or wrap with types       |
| Dynamic routes     | TypeScript can't follow string interpolation | Define type manually          |

```typescript
// âŒ Helper function loses types
function getUser(id: string) {
  // No access to ctx.services.db here
}

// âœ… Pass context explicitly
function getUser(ctx: Context<AppContext['state'], AppContext['services']>, id: string) {
  return ctx.services.db.users.findById(id);
}

// âœ… Or use closure in handler
export const getUser = route.get({
  handler: async ({ ctx, params }) => {
    const fetchUser = (id: string) => ctx.services.db.users.findById(id);
    return await fetchUser(params.userId);
  },
});
```

---

## Common patterns

### Pattern 1: Shared schemas

Define schemas once, reuse everywhere:

```typescript
// src/lib/schemas.ts
export const userSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  email: z.string().email(),
});

export const createUserSchema = userSchema.omit({ id: true });
export const updateUserSchema = userSchema.partial().omit({ id: true });

export type User = z.infer<typeof userSchema>;
export type CreateUser = z.infer<typeof createUserSchema>;
export type UpdateUser = z.infer<typeof updateUserSchema>;
```

```typescript
// src/routes/users.ts
import { userSchema, createUserSchema } from '../lib/schemas';

export const listUsers = route.get({
  schema: { response: z.array(userSchema) },
  handler: async ({ ctx }) => { ... },
});

export const createUser = route.post({
  schema: { body: createUserSchema, response: userSchema },
  handler: async ({ ctx }) => { ... },
});
```

### Pattern 2: Pagination schema

Reusable pagination for list endpoints:

```typescript
// src/lib/schemas.ts
export const paginationSchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
});

export function paginatedResponse<T extends z.ZodType>(itemSchema: T) {
  return z.object({
    items: z.array(itemSchema),
    total: z.number(),
    page: z.number(),
    limit: z.number(),
    pages: z.number(),
  });
}
```

```typescript
// src/routes/users.ts
import { paginationSchema, paginatedResponse, userSchema } from '../lib/schemas';

export const listUsers = route.get({
  schema: {
    query: paginationSchema,
    response: paginatedResponse(userSchema),
  },
  handler: async ({ ctx }) => {
    const { page, limit } = ctx.request.query;
    const [items, total] = await Promise.all([
      ctx.services.db.users.findMany({ skip: (page - 1) * limit, take: limit }),
      ctx.services.db.users.count(),
    ]);
    return {
      items,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit),
    };
  },
});
```

### Pattern 3: Error response types

Type-safe error handling with response unions:

```typescript
const getUserSchema = {
  params: z.object({ userId: z.string().uuid() }),
  response: z.union([
    z.object({ success: z.literal(true), user: userSchema }),
    z.object({ success: z.literal(false), error: z.string() }),
  ]),
};

export const getUser = route.get({
  schema: getUserSchema,
  handler: async ({ ctx, params }) => {
    const user = await ctx.services.db.users.findById(params.userId);

    if (!user) {
      return { success: false as const, error: 'User not found' };
    }

    return { success: true as const, user };
  },
});

// Client can discriminate:
const result = await client.$get.getUser({ params: { userId: '123' } });
if (result.success) {
  console.log(result.user.name); // âœ… TypeScript knows user exists
} else {
  console.log(result.error); // âœ… TypeScript knows error exists
}
```

### Pattern 4: File upload with type-safe metadata

Combine file uploads with structured metadata, maintaining full type safety:

```typescript
// Server route definition
export const uploadDocument = route.post({
  schema: {
    body: z.object({
      title: z.string().min(1),
      category: z.enum(['legal', 'financial', 'personal']),
      tags: z.array(z.string()).optional(),
      metadata: z.object({
        author: z.string(),
        department: z.string(),
        confidential: z.boolean().default(false),
      }),
    }),
    files: z.object({
      document: file({
        maxSize: '10MB',
        accept: ['application/pdf', 'application/msword'],
      }),
      attachments: file({ maxSize: '5MB' }).array().optional(),
    }),
    response: z.object({
      documentId: z.string().uuid(),
      documentUrl: z.string().url(),
      attachmentCount: z.number(),
      uploadedAt: z.string().datetime(),
    }),
  },
  handler: async ({ ctx }) => {
    // All types inferred from schemas
    const { title, category, tags, metadata } = ctx.request.body;
    // title: string
    // category: 'legal' | 'financial' | 'personal'
    // tags: string[] | undefined
    // metadata: { author: string; department: string; confidential: boolean }

    const { document, attachments } = ctx.request.files;
    // document: UploadedFile
    // attachments: UploadedFile[] | undefined

    // Upload main document
    const documentUrl = await storage.upload(document);

    // Upload attachments if present
    const attachmentUrls = attachments
      ? await Promise.all(attachments.map(a => storage.upload(a)))
      : [];

    return {
      documentId: generateId(),
      documentUrl,
      attachmentCount: attachmentUrls.length,
      uploadedAt: new Date().toISOString(),
    };
  },
});

// Client usage - fully typed
const pdfFile = new File(['...'], 'contract.pdf', { type: 'application/pdf' });
const images = [
  new File(['...'], 'receipt1.jpg', { type: 'image/jpeg' }),
  new File(['...'], 'receipt2.jpg', { type: 'image/jpeg' }),
];

const result = await client.$post.uploadDocument({
  body: {
    title: 'Q4 Contract',
    category: 'legal',
    tags: ['contract', 'quarterly'],
    metadata: {
      author: 'John Doe',
      department: 'Legal',
      confidential: true,
    },
  },
  files: {
    document: pdfFile,
    attachments: images,
  },
});

// Result is fully typed
console.log(result.documentId); // string (UUID format)
console.log(result.documentUrl); // string (URL format)
console.log(result.attachmentCount); // number
console.log(result.uploadedAt); // string (ISO datetime)
```

**Type Safety Guarantees:**

1. **Client compilation fails if:**

   - Wrong file property names
   - Missing required files
   - Wrong types (e.g., string instead of File)
   - Wrong body shape

2. **Server runtime validates:**

   - File sizes against maxSize
   - MIME types against accept list
   - Body shape via Zod
   - All constraints before handler runs

3. **IDE provides:**
   - Autocomplete for all properties
   - Error highlighting for mistakes
   - Type information on hover
   - Refactoring support

---

## Key takeaways

1. **Zod schemas are the source of truth** â€” They define runtime validation AND TypeScript types
2. **`InferContext` captures composed types** â€” All middleware and plugin contributions combined
3. **Use server config for type accumulation** â€” Pass middleware and plugins to `createServer()`
4. **Route factory carries types** â€” Creates the bridge from server to route files
5. **Export names become client methods** â€” You control the client API
6. **No code generation** â€” Everything is TypeScript inference at compile time
7. **Transforms work** â€” Zod `.transform()` and `.coerce` flow through correctly
8. **File schemas use `file()` helper** â€” Provides size/MIME validation with automatic type inference
9. **Client-server type mapping** â€” Same schema creates `File`/`Blob` types on client, `UploadedFile` on server
10. **Validation at the boundary** â€” Files validated before handler execution, maintaining type safety

---

## Related pages

- **[Context](/docs/architecture/context)** â€” The object that carries state and services
- **[Middleware](/docs/architecture/middleware)** â€” How middleware adds to context types
- **[Plugins](/docs/architecture/plugins)** â€” How plugins inject services
- **[Router](/docs/architecture/router)** â€” File-based routing and route exports
- **[File Uploads](/docs/guides/file-uploads)** â€” Complete guide with storage integration
