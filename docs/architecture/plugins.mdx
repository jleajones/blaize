# üîå Plugins

> Plugins manage expensive resources with lifecycle hooks ‚Äî connect once at startup, clean up at shutdown, provide access through middleware and factory functions.

---

## Plugins vs middleware: When to use which

This is the most important decision to understand:

| Need                        | Use Middleware | Use Plugin     |
| --------------------------- | -------------- | -------------- |
| Run logic on every request  | ‚úÖ             | ‚ùå             |
| Connect to database once    | ‚ùå             | ‚úÖ             |
| Add data to `ctx.state`     | ‚úÖ             | Via middleware |
| Manage connection pools     | ‚ùå             | ‚úÖ             |
| Validate authentication     | ‚úÖ             | ‚ùå             |
| Clean up on server shutdown | ‚ùå             | ‚úÖ             |
| Add routes dynamically      | ‚ùå             | ‚úÖ             |

### The key difference

**Middleware** runs on every request ‚Äî it's for per-request logic like authentication, logging, and validation.

**Plugins** run once at startup/shutdown ‚Äî they're for managing expensive resources like database connections, cache clients, and external service connections.

```typescript
// ‚ùå WRONG: Creating a database connection on every request
const dbMiddleware = createMiddleware({
  handler: async ({ ctx, next }) => {
    ctx.services.db = await Database.connect(); // Expensive! Every request!
    await next();
    await ctx.services.db.close(); // Wasteful!
  },
});

// ‚úÖ CORRECT: Plugin connects once, middleware provides access
// Internal singleton with factory function
let _db: Database | null = null;

export function getDatabase(): Database {
  if (!_db) {
    throw new Error(
      'Database not initialized. ' +
      'Make sure you have registered the database plugin.'
    );
  }
  return _db;
}

const databasePlugin = createPlugin<
  { connectionString: string }, // Config
  {}, // State (none)
  { db: Database } // Services
>({
  name: 'database',
  version: '1.0.0',
  setup: (config, logger) => {
    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { db: Database }>({
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase(); // Reference via factory
              await next();
            },
          })
        );
      },
      initialize: async () => {
        _db = await Database.connect(config.connectionString); // Connect ONCE
        logger.info('Database connected');
      },
      terminate: async () => {
        const db = getDatabase();
        await db.close(); // Clean up ONCE at shutdown
        _db = null;
        logger.info('Database disconnected');
      },
    };
  },
});
```

### Decision flowchart

```
Do you need to run code on every request?
‚îú‚îÄ‚îÄ YES ‚Üí Use Middleware
‚îî‚îÄ‚îÄ NO ‚Üí Continue...

Do you need to connect to an external resource?
‚îú‚îÄ‚îÄ YES ‚Üí Use Plugin
‚îî‚îÄ‚îÄ NO ‚Üí Continue...

Do you need cleanup when the server stops?
‚îú‚îÄ‚îÄ YES ‚Üí Use Plugin
‚îî‚îÄ‚îÄ NO ‚Üí Continue...

Do you need to add routes programmatically?
‚îú‚îÄ‚îÄ YES ‚Üí Use Plugin
‚îî‚îÄ‚îÄ NO ‚Üí Use Middleware (or neither)
```

---

## The plugin pattern

Plugins follow a specific pattern for managing services:

1. **Declare internal singleton** (private, null initially)
2. **Export factory function** for safe external access
3. **Register middleware** to provide `ctx.services` access in routes
4. **Initialize resources** in the `initialize` hook (only place to assign singleton)
5. **Clean up** in the `terminate` hook (only place to clear singleton)

```typescript
import { createPlugin, createMiddleware } from 'blaizejs';

// 1. Internal singleton (private - use _ prefix by convention)
let _myService: MyService | null = null;

// 2. Factory function for external access (public export)
/**
 * Get the MyService instance
 * 
 * Safe for use in:
 * - Job handlers
 * - Utility functions
 * - Worker processes
 * - Anywhere outside route handlers
 * 
 * @throws {Error} If called before MyPlugin is initialized
 * 
 * @example In job handlers
 * ```typescript
 * import { getMyService } from '../../plugins/my-service';
 * 
 * export const handler = createHandler(queues, 'queue', 'job',
 *   async (data, ctx) => {
 *     const service = getMyService();
 *     await service.doSomething();
 *   }
 * );
 * ```
 * 
 * @returns The initialized service instance
 */
export function getMyService(): MyService {
  if (!_myService) {
    throw new Error(
      'MyService not initialized. ' +
      'Make sure you have registered the MyPlugin.'
    );
  }
  return _myService;
}

// 3. Optional initialization check (useful for conditional logic)
/**
 * Check if MyService is initialized
 * 
 * Useful for conditional logic or startup checks.
 * 
 * @returns true if the service has been initialized
 */
export function isMyServiceInitialized(): boolean {
  return _myService !== null;
}

// 4. Plugin definition
const myPlugin = createPlugin<
  { connectionString: string }, // TConfig - plugin configuration
  {}, // TState - adds to ctx.state (usually empty for plugins)
  { myService: MyService } // TServices - adds to ctx.services
>({
  name: 'my-plugin',
  version: '1.0.0',
  setup: (config, logger) => {
    return {
      // 5. Register middleware for typed access in routes
      register: async server => {
        server.use(
          createMiddleware<{}, { myService: MyService }>({
            name: 'my-service-provider',
            handler: async ({ ctx, next }) => {
              ctx.services.myService = getMyService(); // Use factory
              await next();
            },
          })
        );
      },

      // 6. Initialize resources (ONLY place to assign _myService)
      initialize: async () => {
        logger.info('Connecting to service...');
        _myService = await MyService.connect(config.connectionString);
      },

      // 7. Clean up (ONLY place to clear _myService)
      terminate: async () => {
        logger.info('Disconnecting from service...');
        const service = getMyService();
        await service.disconnect();
        _myService = null;
      },
    };
  },
});
```

---

## Exporting services: Two access patterns

BlaizeJS plugins provide **two ways** to access services, each optimized for different contexts:

| Context | Access Method | Example |
|---------|---------------|---------|
| **Route handlers** | `ctx.services.serviceName` | `await ctx.services.db.insert(...)` |
| **Job handlers** | `getServiceName()` | `const db = getDatabase(); await db.insert(...)` |
| **Utility functions** | `getServiceName()` | `const db = getDatabase(); await db.select(...)` |
| **Worker processes** | `getServiceName()` | `const db = getDatabase(); ...` |
| **Plugin internals** | `getServiceName()` | Use for consistency |

### Why two patterns?

**Route handlers** receive context via middleware ‚Üí use `ctx.services.serviceName`

**Everything else** doesn't have context ‚Üí use factory functions

```typescript
// ‚úÖ In route handlers - use ctx.services
export const POST = createRoute({
  handler: async ({ ctx }) => {
    const user = await ctx.services.db.insert(users).values(...);
    return { user };
  }
});

// ‚úÖ In job handlers - use factory function
import { getDatabase } from '../../database';

export const cleanupOldRecords = createHandler(queues, 'cleanup', 'old-records',
  async (data, ctx) => {
    const db = getDatabase();
    await db.delete(records).where(...);
  }
);

// ‚úÖ In utility functions - use factory function
import { getDatabase } from '../database';

export async function getUserStats(userId: number) {
  const db = getDatabase();
  return await db.select().from(users).where(...);
}
```

### Factory function benefits

1. **Clear error messages** ‚Äî "Database not initialized..." instead of "Cannot read property of null"
2. **Explicit intent** ‚Äî `getDatabase()` shows you're retrieving a service
3. **Easy testing** ‚Äî Mock the factory function, not the instance
4. **Safety checks** ‚Äî Factory verifies initialization state
5. **Consistency** ‚Äî Same pattern across all plugins

---

## Naming conventions

Follow these naming patterns for consistency:

| Service Type | Factory Function | Check Function | Private Variable |
|--------------|------------------|----------------|------------------|
| `Database` | `getDatabase()` | `isDatabaseInitialized()` | `_db` |
| `EmailService` | `getEmailService()` | `isEmailServiceInitialized()` | `_emailService` |
| `CacheService` | `getCacheService()` | `isCacheServiceInitialized()` | `_cache` |
| `QueueService` | `getQueueService()` | `isQueueServiceInitialized()` | `_queueService` |
| `StorageService` | `getStorageService()` | `isStorageServiceInitialized()` | `_storage` |

**Pattern:** `get[ServiceName]()` where ServiceName is PascalCase

---

## createPlugin signature

```typescript
function createPlugin<
  TConfig = {}, // Plugin configuration type
  TState = {}, // State additions (rarely used by plugins)
  TServices = {}, // Service additions
>(options: CreatePluginOptions<TConfig, TState, TServices>): PluginFactory;
```

| Generic     | Purpose                                         | Typical Usage                                            |
| ----------- | ----------------------------------------------- | -------------------------------------------------------- |
| `TConfig`   | Shape of configuration options                  | `{ host: string; port: number }`                         |
| `TState`    | What plugin's middleware adds to `ctx.state`    | Usually `{}` ‚Äî plugins typically add services, not state |
| `TServices` | What plugin's middleware adds to `ctx.services` | `{ db: Database; cache: CacheService }`                  |

### CreatePluginOptions

```typescript
interface CreatePluginOptions<TConfig, TState, TServices> {
  name: string; // Plugin identifier
  version: string; // Semantic version
  defaultConfig?: TConfig; // Default configuration values
  setup: (config: TConfig, logger: BlaizeLogger) => Partial<PluginHooks>;
}
```

The `setup` function receives:

- `config` ‚Äî Merged configuration (defaults + user-provided)
- `logger` ‚Äî A child logger scoped to this plugin

---

## Lifecycle hooks

Plugins can implement five lifecycle hooks:

| Hook            | When It Runs                     | Use For                                |
| --------------- | -------------------------------- | -------------------------------------- |
| `register`      | During `server.register(plugin)` | Adding middleware, routes              |
| `initialize`    | Before `server.listen()`         | Connecting to resources                |
| `onServerStart` | After server is listening        | Verifying connections, starting timers |
| `onServerStop`  | When server begins shutdown      | Stopping new work, draining queues     |
| `terminate`     | During server shutdown           | Closing connections, cleanup           |

### Execution order

```
Server Startup:
  plugin1.register() ‚Üí plugin2.register() ‚Üí plugin3.register()
  plugin1.initialize() ‚Üí plugin2.initialize() ‚Üí plugin3.initialize()
  plugin1.onServerStart() ‚Üí plugin2.onServerStart() ‚Üí plugin3.onServerStart()

Server Shutdown (reverse order):
  plugin3.onServerStop() ‚Üí plugin2.onServerStop() ‚Üí plugin1.onServerStop()
  plugin3.terminate() ‚Üí plugin2.terminate() ‚Üí plugin1.terminate()
```

**Why reverse order for shutdown?** Resources registered last may depend on resources registered first. Shutting down in reverse ensures dependencies are available during cleanup.

### Hook examples

```typescript
interface DbOptions {
  connectionString: string;
  poolSize?: number;
}

// Internal singleton
let _pool: ConnectionPool | null = null;

// Factory function
export function getDatabase(): ConnectionPool {
  if (!_pool) {
    throw new Error('Database not initialized.');
  }
  return _pool;
}

export function isDatabaseInitialized(): boolean {
  return _pool !== null;
}

const databasePlugin = createPlugin<DbOptions, {}, { db: ConnectionPool }>({
  name: 'database',
  version: '1.0.0',
  defaultConfig: {
    connectionString: 'postgresql://localhost:5432/app',
    poolSize: 10,
  },
  setup: (config, logger) => {
    return {
      // Called during server.register()
      register: async server => {
        server.use(
          createMiddleware<{}, { db: ConnectionPool }>({
            name: 'database',
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase();
              await next();
            },
          })
        );
        logger.debug('Database middleware registered');
      },

      // Called before server.listen()
      initialize: async () => {
        _pool = await ConnectionPool.create({
          connectionString: config.connectionString,
          max: config.poolSize,
        });
        logger.info('Database pool created');
      },

      // Called after server is listening
      onServerStart: async () => {
        const pool = getDatabase();
        await pool.query('SELECT 1'); // Verify connection
        logger.info('Database connection verified');
      },

      // Called when server begins shutdown
      onServerStop: async () => {
        const pool = getDatabase();
        pool.stopAcceptingQueries();
        logger.info('Draining database connections...');
      },

      // Called during shutdown
      terminate: async () => {
        const pool = getDatabase();
        await pool.close();
        _pool = null;
        logger.info('Database pool closed');
      },
    };
  },
});
```

---

## Adding plugins to server

### Recommended: Configure in createServer()

The **best practice** is to pass plugins directly to `createServer()`:

```typescript
const server = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
  plugins: [databasePlugin({ url: 'postgres://...' }), cachePlugin(), metricsPlugin()],
  middleware: [authMiddleware, loggingMiddleware],
});

type AppContext = InferContext<typeof server>;
// All types included automatically ‚úÖ
```

**Why this is best:**

- ‚úÖ Types accumulate automatically
- ‚úÖ All configuration in one place
- ‚úÖ Clear, declarative setup
- ‚úÖ No risk of forgetting to capture return values

### Alternative: Chaining

For conditional setup or when order matters:

```typescript
const server = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
})
  .register(databasePlugin({ url: 'postgres://...' }))
  .register(cachePlugin());

type AppContext = InferContext<typeof server>;
// Types accumulate through chain ‚úÖ
```

### Special Cases: Reassignment

Use reassignment when you need conditional logic:

```typescript
const base = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
});

// Conditional registration
const withDb = base.register(databasePlugin());

const server = process.env.NODE_ENV === 'production' ? withDb.register(metricsPlugin()) : withDb;

type AppContext = InferContext<typeof server>;
```

**‚ö†Ô∏è Critical:** `.register()` returns a **new server instance** with updated types. Always capture the return value:

```typescript
// ‚ùå WRONG: Types lost
const server = Blaize.createServer();
server.register(databasePlugin()); // Return value ignored!
// server still has no db types

// ‚úÖ CORRECT: Capture return value
const server = Blaize.createServer().register(databasePlugin());
// server has db types ‚úÖ
```

---

## Plugin configuration

Plugins accept configuration as the first type parameter:

```typescript
interface DatabasePluginOptions {
  host: string;
  port: number;
  database: string;
  poolSize?: number;
}

let _pool: ConnectionPool | null = null;

export function getDatabase(): ConnectionPool {
  if (!_pool) {
    throw new Error('Database not initialized.');
  }
  return _pool;
}

const databasePlugin = createPlugin<
  DatabasePluginOptions, // TConfig
  {}, // TState (none)
  { db: ConnectionPool } // TServices
>({
  name: 'database',
  version: '1.0.0',
  defaultConfig: {
    host: 'localhost',
    port: 5432,
    database: 'app',
    poolSize: 10,
  },
  setup: (config, logger) => {
    const { host, port, database, poolSize } = config;

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { db: ConnectionPool }>({
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase();
              await next();
            },
          })
        );
      },
      initialize: async () => {
        _pool = await ConnectionPool.create({
          host,
          port,
          database,
          max: poolSize,
        });
        logger.info('Database connected', { host, port, database });
      },
      terminate: async () => {
        const pool = getDatabase();
        await pool.close();
        _pool = null;
        logger.info('Database disconnected');
      },
    };
  },
});

// Usage with config (overrides defaults)
const server = Blaize.createServer().register(
  databasePlugin({
    host: 'prod.db.example.com',
    port: 5432,
    database: 'production',
    poolSize: 20,
  })
);

// Usage with defaults
const devServer = Blaize.createServer().register(databasePlugin()); // Uses all defaults
```

### Default configuration

The `defaultConfig` option provides base values that user config merges into:

```typescript
let _cache: CacheService | null = null;

export function getCacheService(): CacheService {
  if (!_cache) {
    throw new Error('Cache not initialized.');
  }
  return _cache;
}

const cachePlugin = createPlugin<{ ttl: number; maxSize: number }, {}, { cache: CacheService }>({
  name: 'cache',
  version: '1.0.0',
  defaultConfig: {
    ttl: 3600, // 1 hour default
    maxSize: 1000, // 1000 items default
  },
  setup: (config, logger) => {
    // config.ttl and config.maxSize are always defined
    // (from defaults or user override)
    logger.info('Cache initialized', { ttl: config.ttl, maxSize: config.maxSize });
    
    return {
      initialize: async () => {
        _cache = new CacheService(config);
      },
      terminate: async () => {
        _cache = null;
      },
    };
  },
});

// Override just ttl
const server = Blaize.createServer().register(cachePlugin({ ttl: 60 })); // maxSize stays at 1000
```

---

## Type flow through plugins

Plugins add types via the `TState` and `TServices` generic parameters. The types flow through middleware:

```typescript
// Internal singleton + factory
let _db: Database | null = null;

export function getDatabase(): Database {
  if (!_db) {
    throw new Error('Database not initialized.');
  }
  return _db;
}

// Plugin declares its type contributions
const databasePlugin = createPlugin<
  { url: string }, // Config
  {}, // State (none)
  { db: Database } // Services
>({
  name: 'database',
  version: '1.0.0',
  setup: (config, logger) => {
    return {
      register: async server => {
        // Middleware must match the TServices generic
        server.use(
          createMiddleware<{}, { db: Database }>({
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase();
              await next();
            },
          })
        );
      },
      initialize: async () => {
        _db = await Database.connect(config.url);
        logger.info('Database connected');
      },
      terminate: async () => {
        const db = getDatabase();
        await db.close();
        _db = null;
        logger.info('Database disconnected');
      },
    };
  },
});
```

When the plugin is registered, types flow to the server:

```typescript
const server = Blaize.createServer()
  .register(databasePlugin({ url: 'postgres://...' })) // Adds { db: Database }
  .register(cachePlugin()); // Adds { cache: CacheService }

type AppContext = InferContext<typeof server>;
// AppContext['services'] = { db: Database; cache: CacheService }

// Route handlers get the types
export const getUsers = route.get({
  handler: async ({ ctx }) => {
    ctx.services.db; // ‚úÖ Typed as Database
    ctx.services.cache; // ‚úÖ Typed as CacheService
  },
});
```

---

## Adding routes from plugins

Plugins can add routes dynamically via the `register` hook:

```typescript
const healthPlugin = createPlugin<{}, {}, {}>({
  name: 'health',
  version: '1.0.0',
  setup: (config, logger) => ({
    register: async server => {
      server.router.addRoute({
        path: '/health',
        GET: {
          handler: async () => ({
            status: 'ok',
            timestamp: Date.now(),
          }),
        },
      });
      logger.info('Health route registered');
    },
  }),
});

interface MetricsOptions {
  path?: string;
}

let _collector: MetricsCollector | null = null;

export function getMetricsCollector(): MetricsCollector {
  if (!_collector) {
    throw new Error('Metrics collector not initialized.');
  }
  return _collector;
}

const metricsPlugin = createPlugin<MetricsOptions, {}, { metrics: MetricsCollector }>({
  name: 'metrics',
  version: '1.0.0',
  defaultConfig: {
    path: '/metrics',
  },
  setup: (config, logger) => {
    return {
      register: async server => {
        // Add middleware for typed access
        server.use(
          createMiddleware<{}, { metrics: MetricsCollector }>({
            handler: async ({ ctx, next }) => {
              ctx.services.metrics = getMetricsCollector();
              await next();
            },
          })
        );

        // Add metrics endpoint
        server.router.addRoute({
          path: config.path!,
          GET: {
            handler: async ({ ctx }) => {
              const metrics = await getMetricsCollector().export();
              ctx.response.header('Content-Type', 'text/plain');
              return metrics;
            },
          },
        });
        logger.info('Metrics route registered', { path: config.path });
      },
      initialize: async () => {
        _collector = new MetricsCollector();
        _collector.start();
        logger.info('Metrics collector started');
      },
      terminate: async () => {
        const collector = getMetricsCollector();
        collector.stop();
        _collector = null;
        logger.info('Metrics collector stopped');
      },
    };
  },
});
```

---

## Common plugin patterns

### Pattern 1: Database connection pool

```typescript
// src/plugins/database.ts
interface DatabaseOptions {
  connectionString: string;
  poolSize?: number;
}

// Internal singleton
let _pool: Pool | null = null;

// Factory function
export function getDatabase(): Pool {
  if (!_pool) {
    throw new Error(
      'Database not initialized. ' +
      'Make sure you have registered the database plugin.'
    );
  }
  return _pool;
}

export function isDatabaseInitialized(): boolean {
  return _pool !== null;
}

const databasePlugin = createPlugin<DatabaseOptions, {}, { db: Pool }>({
  name: 'database',
  version: '1.0.0',
  defaultConfig: {
    connectionString: 'postgresql://localhost:5432/app',
    poolSize: 10,
  },
  setup: (config, logger) => {
    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { db: Pool }>({
            name: 'database',
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase();
              await next();
            },
          })
        );
      },
      initialize: async () => {
        _pool = new Pool({
          connectionString: config.connectionString,
          max: config.poolSize,
        });
        // Verify connection
        await _pool.query('SELECT 1');
        logger.info('Database pool initialized', { poolSize: config.poolSize });
      },
      terminate: async () => {
        const pool = getDatabase();
        await pool.end();
        _pool = null;
        logger.info('Database pool closed');
      },
    };
  },
});
```

**Usage in routes:**
```typescript
export const GET = createRoute({
  handler: async ({ ctx }) => {
    // Use ctx.services in routes
    const users = await ctx.services.db.query('SELECT * FROM users');
    return users.rows;
  },
});
```

**Usage in job handlers:**
```typescript
import { getDatabase } from '../../plugins/database';

export const cleanupHandler = createHandler(queues, 'maintenance', 'cleanup',
  async (data, ctx) => {
    // Use factory function outside routes
    const db = getDatabase();
    await db.query('DELETE FROM sessions WHERE expires_at < NOW()');
  }
);
```

### Pattern 2: Redis cache

```typescript
// src/plugins/cache.ts
interface CacheOptions {
  url: string;
  ttl?: number;
}

interface CacheService {
  get: (key: string) => Promise<unknown | null>;
  set: (key: string, value: unknown, ttl?: number) => Promise<void>;
  del: (key: string) => Promise<void>;
}

let _redis: RedisClient | null = null;
let _cache: CacheService | null = null;

export function getCacheService(): CacheService {
  if (!_cache) {
    throw new Error('Cache not initialized.');
  }
  return _cache;
}

const cachePlugin = createPlugin<CacheOptions, {}, { cache: CacheService }>({
  name: 'cache',
  version: '1.0.0',
  defaultConfig: {
    url: 'redis://localhost:6379',
    ttl: 3600,
  },
  setup: (config, logger) => {
    const cache: CacheService = {
      get: async key => {
        if (!_redis) throw new Error('Redis not initialized');
        const value = await _redis.get(key);
        return value ? JSON.parse(value) : null;
      },
      set: async (key, value, ttl) => {
        if (!_redis) throw new Error('Redis not initialized');
        const serialized = JSON.stringify(value);
        const expiry = ttl ?? config.ttl;
        if (expiry) {
          await _redis.setex(key, expiry, serialized);
        } else {
          await _redis.set(key, serialized);
        }
      },
      del: async key => {
        if (!_redis) throw new Error('Redis not initialized');
        await _redis.del(key);
      },
    };

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { cache: CacheService }>({
            name: 'cache',
            handler: async ({ ctx, next }) => {
              ctx.services.cache = getCacheService();
              await next();
            },
          })
        );
      },
      initialize: async () => {
        _redis = new RedisClient(config.url);
        await _redis.connect();
        _cache = cache;
        logger.info('Redis cache connected');
      },
      terminate: async () => {
        if (_redis) {
          await _redis.quit();
          _redis = null;
        }
        _cache = null;
        logger.info('Redis cache disconnected');
      },
    };
  },
});
```

### Pattern 3: Background job queue

```typescript
// src/plugins/queue.ts
interface QueueOptions {
  concurrency?: number;
}

interface QueueService {
  add: (name: string, data: unknown) => Promise<string>;
  getStatus: (jobId: string) => Promise<string>;
}

let _queue: JobQueue | null = null;
let _queueService: QueueService | null = null;

export function getQueueService(): QueueService {
  if (!_queueService) {
    throw new Error('Queue not initialized.');
  }
  return _queueService;
}

const queuePlugin = createPlugin<QueueOptions, {}, { queue: QueueService }>({
  name: 'queue',
  version: '1.0.0',
  defaultConfig: {
    concurrency: 5,
  },
  setup: (config, logger) => {
    const queueService: QueueService = {
      add: async (name, data) => {
        if (!_queue) throw new Error('Queue not initialized');
        return _queue.add(name, data);
      },
      getStatus: async jobId => {
        if (!_queue) throw new Error('Queue not initialized');
        return _queue.getStatus(jobId);
      },
    };

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { queue: QueueService }>({
            name: 'queue',
            handler: async ({ ctx, next }) => {
              ctx.services.queue = getQueueService();
              await next();
            },
          })
        );
      },
      initialize: async () => {
        _queue = new JobQueue({ concurrency: config.concurrency });
        _queueService = queueService;
        logger.info('Job queue initialized', { concurrency: config.concurrency });
      },
      onServerStart: async () => {
        if (_queue) {
          _queue.startProcessing();
          logger.info('Job queue processing started');
        }
      },
      onServerStop: async () => {
        if (_queue) {
          await _queue.drain(); // Wait for in-flight jobs
          logger.info('Job queue drained');
        }
      },
      terminate: async () => {
        if (_queue) {
          _queue.shutdown();
          _queue = null;
        }
        _queueService = null;
        logger.info('Job queue shutdown');
      },
    };
  },
});
```

### Pattern 4: External API client

```typescript
// src/plugins/api-client.ts
interface ApiClientOptions {
  baseUrl: string;
  apiKey: string;
  timeout?: number;
}

interface ApiClient {
  get: (path: string) => Promise<unknown>;
  post: (path: string, body: unknown) => Promise<unknown>;
}

let _client: ApiClient | null = null;

export function getApiClient(): ApiClient {
  if (!_client) {
    throw new Error('API client not initialized.');
  }
  return _client;
}

const apiClientPlugin = createPlugin<ApiClientOptions, {}, { api: ApiClient }>({
  name: 'api-client',
  version: '1.0.0',
  defaultConfig: {
    baseUrl: 'https://api.example.com',
    apiKey: '',
    timeout: 30000,
  },
  setup: (config, logger) => {
    const client: ApiClient = {
      get: async path => {
        const res = await fetch(`${config.baseUrl}${path}`, {
          headers: { Authorization: `Bearer ${config.apiKey}` },
          signal: AbortSignal.timeout(config.timeout!),
        });
        return res.json();
      },
      post: async (path, body) => {
        const res = await fetch(`${config.baseUrl}${path}`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${config.apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
          signal: AbortSignal.timeout(config.timeout!),
        });
        return res.json();
      },
    };

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { api: ApiClient }>({
            name: 'api-client',
            handler: async ({ ctx, next }) => {
              ctx.services.api = getApiClient();
              await next();
            },
          })
        );
      },
      initialize: async () => {
        _client = client;
        logger.info('API client registered', { baseUrl: config.baseUrl });
      },
      terminate: async () => {
        _client = null;
      },
    };
  },
});
```

---

## Testing plugin services

### Mocking factory functions

The factory function pattern makes testing easy:

```typescript
// test/routes/users.test.ts
import { vi } from 'vitest';

// Mock the factory function
vi.mock('../../plugins/database', () => ({
  getDatabase: vi.fn(() => mockDb),
  isDatabaseInitialized: vi.fn(() => true),
}));

const mockDb = {
  insert: vi.fn().mockReturnThis(),
  values: vi.fn().mockResolvedValue({ id: 1, name: 'Test' }),
};

test('creates user', async () => {
  const response = await request(app)
    .post('/users')
    .send({ name: 'Test' });

  expect(mockDb.insert).toHaveBeenCalledWith(users);
  expect(mockDb.values).toHaveBeenCalled();
  expect(response.status).toBe(201);
});
```

### Testing initialization

```typescript
test('factory throws before initialization', () => {
  // Reset the mock to simulate uninitialized state
  vi.mocked(getDatabase).mockImplementation(() => {
    throw new Error('Database not initialized.');
  });

  expect(() => getDatabase()).toThrow('Database not initialized.');
});

test('factory returns instance after initialization', () => {
  const mockDb = { query: vi.fn() };
  vi.mocked(getDatabase).mockReturnValue(mockDb);

  expect(getDatabase()).toBe(mockDb);
  expect(isDatabaseInitialized()).toBe(true);
});
```

---

## Anti-patterns to avoid

### ‚ùå Creating resources per request

```typescript
// ‚ùå WRONG: New connection every request
const badPlugin = createPlugin<{}, {}, { db: Database }>({
  name: 'bad',
  version: '1.0.0',
  setup: () => ({
    register: async server => {
      server.use(
        createMiddleware({
          handler: async ({ ctx, next }) => {
            ctx.services.db = await Database.connect(); // Expensive!
            await next();
            await ctx.services.db.close();
          },
        })
      );
    },
  }),
});

// ‚úÖ CORRECT: Create once, reference many
let _db: Database | null = null;

export function getDatabase(): Database {
  if (!_db) throw new Error('Database not initialized.');
  return _db;
}

const goodPlugin = createPlugin<{}, {}, { db: Database }>({
  name: 'good',
  version: '1.0.0',
  setup: (config, logger) => {
    return {
      register: async server => {
        server.use(
          createMiddleware({
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase(); // Reference via factory
              await next();
            },
          })
        );
      },
      initialize: async () => {
        _db = await Database.connect();
        logger.info('Database connected');
      },
      terminate: async () => {
        const db = getDatabase();
        await db.close();
        _db = null;
        logger.info('Database disconnected');
      },
    };
  },
});
```

### ‚ùå Forgetting cleanup

```typescript
// ‚ùå WRONG: No cleanup
let _service: Service | null = null;

const leakyPlugin = createPlugin<{}, {}, {}>({
  name: 'leaky',
  version: '1.0.0',
  setup: () => {
    let interval: NodeJS.Timeout;

    return {
      initialize: async () => {
        interval = setInterval(doSomething, 1000); // Runs forever!
        _service = new Service();
      },
      // Missing terminate! _service never cleared!
    };
  },
});

// ‚úÖ CORRECT: Clean up resources
let _service: Service | null = null;

export function getService(): Service {
  if (!_service) throw new Error('Service not initialized.');
  return _service;
}

const cleanPlugin = createPlugin<{}, {}, {}>({
  name: 'clean',
  version: '1.0.0',
  setup: (config, logger) => {
    let interval: NodeJS.Timeout;

    return {
      initialize: async () => {
        interval = setInterval(doSomething, 1000);
        _service = new Service();
        logger.info('Timer started');
      },
      terminate: async () => {
        clearInterval(interval);
        _service = null; // Clear singleton!
        logger.info('Timer stopped');
      },
    };
  },
});
```

### ‚ùå Ignoring return value

```typescript
// ‚ùå WRONG: Types lost
const base = Blaize.createServer();
base.register(databasePlugin()); // Return value ignored!

type AppContext = InferContext<typeof base>;
// services = {}  ‚Üê db is missing!

// ‚úÖ CORRECT: Capture return
const server = Blaize.createServer().register(databasePlugin());

type AppContext = InferContext<typeof server>;
// services = { db: Database }  ‚úÖ
```

### ‚ùå Direct access to internal singleton

```typescript
// ‚ùå WRONG: Accessing internal variable directly
import { _db } from '../../plugins/database'; // DON'T DO THIS!

export const handler = async (data) => {
  await _db.query(...); // Might be null!
};

// ‚úÖ CORRECT: Use factory function
import { getDatabase } from '../../plugins/database';

export const handler = async (data) => {
  const db = getDatabase(); // Safe, throws clear error if not initialized
  await db.query(...);
};
```

---

## Error messages reference

### Common errors and solutions

| Error | Cause | Solution |
|-------|-------|----------|
| `Database not initialized. Make sure you have registered the database plugin.` | Factory called before plugin's `initialize()` hook | Ensure plugin is registered and server has started |
| `TypeError: getDatabase is not a function` | Import path is incorrect | Fix import: `import { getDatabase } from '../../plugins/database'` |
| `Cannot read property 'query' of null` | Accessing singleton directly instead of via factory | Use factory function: `getDatabase()` not `_db` |

### Initialization timing

```typescript
// ‚úÖ CORRECT: After server starts
const server = Blaize.createServer()
  .register(databasePlugin());

await server.listen(); // Plugins initialized here

const db = getDatabase(); // Safe ‚úÖ

// ‚ùå WRONG: Before initialization
const server = Blaize.createServer()
  .register(databasePlugin());

const db = getDatabase(); // Error: not initialized ‚ùå

await server.listen();
```

---

## Official plugins

BlaizeJS provides official plugins:

| Plugin  | Package                    | Purpose                                     |
| ------- | -------------------------- | ------------------------------------------- |
| Queue   | `@blaizejs/plugin-queue`   | Background job processing with SSE progress |
| Cache   | `@blaizejs/plugin-cache`   | Memory and Redis caching                    |
| Metrics | `@blaizejs/plugin-metrics` | Prometheus metrics collection               |

```typescript
import { createQueuePlugin } from '@blaizejs/plugin-queue';
import { createCachePlugin } from '@blaizejs/plugin-cache';
import { createMetricsPlugin } from '@blaizejs/plugin-metrics';

const server = Blaize.createServer()
  .register(
    createQueuePlugin({
      /* options */
    })
  )
  .register(
    createCachePlugin({
      /* options */
    })
  )
  .register(
    createMetricsPlugin({
      /* options */
    })
  );
```

---

## Key takeaways

1. **Two access patterns** ‚Äî `ctx.services` for routes, `getService()` for jobs/utilities/workers
2. **Factory function pattern** ‚Äî Export `getService()` for safe external access
3. **Use plugins for resources** ‚Äî Database connections, cache clients, external APIs
4. **Use middleware for requests** ‚Äî Authentication, logging, validation
5. **Singleton pattern** ‚Äî Internal `_service` variable, public factory function
6. **Lifecycle hooks** ‚Äî `initialize` to create & assign, `terminate` to cleanup & clear
7. **Type accumulation** ‚Äî Capture `.register()` return value for types
8. **Reverse shutdown** ‚Äî Plugins terminate in reverse registration order
9. **Clear errors** ‚Äî Factory functions provide explicit error messages
10. **Easy testing** ‚Äî Mock factory functions, not internal variables

---

## Related pages

- **[Middleware](/docs/architecture/middleware)** ‚Äî For per-request logic
- **[Type System](/docs/architecture/type-system)** ‚Äî How plugin types flow
- **[Context](/docs/architecture/context)** ‚Äî Where services are accessed
- **[Router](/docs/architecture/router)** ‚Äî How plugins add routes
- **[Database Integration](/docs/guides/database-integration)** ‚Äî Full example with Drizzle, Prisma, TypeORM