# üîå Plugins

> Plugins manage expensive resources with lifecycle hooks ‚Äî connect once at startup, clean up at shutdown, provide access through middleware.

---

## Plugins vs middleware: When to use which

This is the most important decision to understand:

| Need                        | Use Middleware | Use Plugin     |
| --------------------------- | -------------- | -------------- |
| Run logic on every request  | ‚úÖ             | ‚ùå             |
| Connect to database once    | ‚ùå             | ‚úÖ             |
| Add data to `ctx.state`     | ‚úÖ             | Via middleware |
| Manage connection pools     | ‚ùå             | ‚úÖ             |
| Validate authentication     | ‚úÖ             | ‚ùå             |
| Clean up on server shutdown | ‚ùå             | ‚úÖ             |
| Add routes dynamically      | ‚ùå             | ‚úÖ             |

### The key difference

**Middleware** runs on every request ‚Äî it's for per-request logic like authentication, logging, and validation.

**Plugins** run once at startup/shutdown ‚Äî they're for managing expensive resources like database connections, cache clients, and external service connections.

```typescript
// ‚ùå WRONG: Creating a database connection on every request
const dbMiddleware = createMiddleware({
  handler: async ({ ctx, next }) => {
    ctx.services.db = await Database.connect(); // Expensive! Every request!
    await next();
    await ctx.services.db.close(); // Wasteful!
  },
});

// ‚úÖ CORRECT: Plugin connects once, middleware provides access
const databasePlugin = createPlugin<
  { connectionString: string }, // Config
  {}, // State (none)
  { db: Database } // Services
>({
  name: 'database',
  version: '1.0.0',
  setup: (config, logger) => {
    let db: Database; // Singleton in closure

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { db: Database }>({
            handler: async ({ ctx, next }) => {
              ctx.services.db = db; // Just a reference ‚Äî no connection!
              await next();
            },
          })
        );
      },
      initialize: async () => {
        db = await Database.connect(config.connectionString); // Connect ONCE
        logger.info('Database connected');
      },
      terminate: async () => {
        await db.close(); // Clean up ONCE at shutdown
        logger.info('Database disconnected');
      },
    };
  },
});
```

### Decision flowchart

```
Do you need to run code on every request?
‚îú‚îÄ‚îÄ YES ‚Üí Use Middleware
‚îî‚îÄ‚îÄ NO ‚Üí Continue...

Do you need to connect to an external resource?
‚îú‚îÄ‚îÄ YES ‚Üí Use Plugin
‚îî‚îÄ‚îÄ NO ‚Üí Continue...

Do you need cleanup when the server stops?
‚îú‚îÄ‚îÄ YES ‚Üí Use Plugin
‚îî‚îÄ‚îÄ NO ‚Üí Continue...

Do you need to add routes programmatically?
‚îú‚îÄ‚îÄ YES ‚Üí Use Plugin
‚îî‚îÄ‚îÄ NO ‚Üí Use Middleware (or neither)
```

---

## The plugin pattern

Plugins follow a specific pattern:

1. **Declare resource variables in a closure** (singleton)
2. **Register middleware** to provide typed access
3. **Initialize resources** in the `initialize` hook
4. **Clean up** in the `terminate` hook

```typescript
import { createPlugin, createMiddleware } from 'blaizejs';

const myPlugin = createPlugin<
  { connectionString: string }, // TConfig - plugin configuration
  {}, // TState - adds to ctx.state (usually empty for plugins)
  { myService: MyService } // TServices - adds to ctx.services
>({
  name: 'my-plugin',
  version: '1.0.0',
  setup: (config, logger) => {
    // 1. Declare resources in closure
    let service: MyService;

    return {
      // 2. Register middleware for typed access
      register: async server => {
        server.use(
          createMiddleware<{}, { myService: MyService }>({
            name: 'my-service-provider',
            handler: async ({ ctx, next }) => {
              ctx.services.myService = service; // Reference to singleton
              await next();
            },
          })
        );
      },

      // 3. Initialize resources
      initialize: async () => {
        logger.info('Connecting to service...');
        service = await MyService.connect(config.connectionString);
      },

      // 4. Clean up
      terminate: async () => {
        logger.info('Disconnecting from service...');
        await service.disconnect();
      },
    };
  },
});
```

### createPlugin signature

```typescript
function createPlugin<
  TConfig = {}, // Plugin configuration type
  TState = {}, // State additions (rarely used by plugins)
  TServices = {}, // Service additions
>(options: CreatePluginOptions<TConfig, TState, TServices>): PluginFactory;
```

| Generic     | Purpose                                         | Typical Usage                                            |
| ----------- | ----------------------------------------------- | -------------------------------------------------------- |
| `TConfig`   | Shape of configuration options                  | `{ host: string; port: number }`                         |
| `TState`    | What plugin's middleware adds to `ctx.state`    | Usually `{}` ‚Äî plugins typically add services, not state |
| `TServices` | What plugin's middleware adds to `ctx.services` | `{ db: Database; cache: CacheService }`                  |

### CreatePluginOptions

```typescript
interface CreatePluginOptions<TConfig, TState, TServices> {
  name: string; // Plugin identifier
  version: string; // Semantic version
  defaultConfig?: TConfig; // Default configuration values
  setup: (config: TConfig, logger: BlaizeLogger) => Partial<PluginHooks>;
}
```

The `setup` function receives:

- `config` ‚Äî Merged configuration (defaults + user-provided)
- `logger` ‚Äî A child logger scoped to this plugin

---

## Lifecycle hooks

Plugins can implement five lifecycle hooks:

| Hook            | When It Runs                     | Use For                                |
| --------------- | -------------------------------- | -------------------------------------- |
| `register`      | During `server.register(plugin)` | Adding middleware, routes              |
| `initialize`    | Before `server.listen()`         | Connecting to resources                |
| `onServerStart` | After server is listening        | Verifying connections, starting timers |
| `onServerStop`  | When server begins shutdown      | Stopping new work, draining queues     |
| `terminate`     | During server shutdown           | Closing connections, cleanup           |

### Execution order

```
Server Startup:
  plugin1.register() ‚Üí plugin2.register() ‚Üí plugin3.register()
  plugin1.initialize() ‚Üí plugin2.initialize() ‚Üí plugin3.initialize()
  plugin1.onServerStart() ‚Üí plugin2.onServerStart() ‚Üí plugin3.onServerStart()

Server Shutdown (reverse order):
  plugin3.onServerStop() ‚Üí plugin2.onServerStop() ‚Üí plugin1.onServerStop()
  plugin3.terminate() ‚Üí plugin2.terminate() ‚Üí plugin1.terminate()
```

**Why reverse order for shutdown?** Resources registered last may depend on resources registered first. Shutting down in reverse ensures dependencies are available during cleanup.

### Hook examples

```typescript
interface DbOptions {
  connectionString: string;
  poolSize?: number;
}

const databasePlugin = createPlugin<DbOptions, {}, { db: ConnectionPool }>({
  name: 'database',
  version: '1.0.0',
  defaultConfig: {
    connectionString: 'postgresql://localhost:5432/app',
    poolSize: 10,
  },
  setup: (config, logger) => {
    let pool: ConnectionPool;

    return {
      // Called during server.register()
      register: async server => {
        server.use(
          createMiddleware<{}, { db: ConnectionPool }>({
            name: 'database',
            handler: async ({ ctx, next }) => {
              ctx.services.db = pool;
              await next();
            },
          })
        );
        logger.debug('Database middleware registered');
      },

      // Called before server.listen()
      initialize: async () => {
        pool = await ConnectionPool.create({
          connectionString: config.connectionString,
          max: config.poolSize,
        });
        logger.info('Database pool created');
      },

      // Called after server is listening
      onServerStart: async () => {
        await pool.query('SELECT 1'); // Verify connection
        logger.info('Database connection verified');
      },

      // Called when server begins shutdown
      onServerStop: async () => {
        pool.stopAcceptingQueries();
        logger.info('Draining database connections...');
      },

      // Called during shutdown
      terminate: async () => {
        await pool.close();
        logger.info('Database pool closed');
      },
    };
  },
});
```

---

## Adding plugins to server

### Recommended: Configure in createServer()

The **best practice** is to pass plugins directly to `createServer()`:

```typescript
const server = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
  plugins: [databasePlugin({ url: 'postgres://...' }), cachePlugin(), metricsPlugin()],
  middleware: [authMiddleware, loggingMiddleware],
});

type AppContext = InferContext<typeof server>;
// All types included automatically ‚úÖ
```

**Why this is best:**

- ‚úÖ Types accumulate automatically
- ‚úÖ All configuration in one place
- ‚úÖ Clear, declarative setup
- ‚úÖ No risk of forgetting to capture return values

### Alternative: Chaining

For conditional setup or when order matters:

```typescript
const server = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
})
  .register(databasePlugin({ url: 'postgres://...' }))
  .register(cachePlugin());

type AppContext = InferContext<typeof server>;
// Types accumulate through chain ‚úÖ
```

### Special Cases: Reassignment

Use reassignment when you need conditional logic:

```typescript
const base = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
});

// Conditional registration
const withDb = base.register(databasePlugin());

const server = process.env.NODE_ENV === 'production' ? withDb.register(metricsPlugin()) : withDb;

type AppContext = InferContext<typeof server>;
```

**‚ö†Ô∏è Critical:** `.register()` returns a **new server instance** with updated types. Always capture the return value:

```typescript
// ‚ùå WRONG: Types lost
const server = Blaize.createServer();
server.register(databasePlugin()); // Return value ignored!
// server still has no db types

// ‚úÖ CORRECT: Capture return value
const server = Blaize.createServer().register(databasePlugin());
// server has db types ‚úÖ
```

---

## Plugin configuration

Plugins accept configuration as the first type parameter:

```typescript
interface DatabasePluginOptions {
  host: string;
  port: number;
  database: string;
  poolSize?: number;
}

const databasePlugin = createPlugin<
  DatabasePluginOptions, // TConfig
  {}, // TState (none)
  { db: ConnectionPool } // TServices
>({
  name: 'database',
  version: '1.0.0',
  defaultConfig: {
    host: 'localhost',
    port: 5432,
    database: 'app',
    poolSize: 10,
  },
  setup: (config, logger) => {
    // config is typed as DatabasePluginOptions
    const { host, port, database, poolSize } = config;

    let pool: ConnectionPool;

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { db: ConnectionPool }>({
            handler: async ({ ctx, next }) => {
              ctx.services.db = pool;
              await next();
            },
          })
        );
      },
      initialize: async () => {
        pool = await ConnectionPool.create({
          host,
          port,
          database,
          max: poolSize,
        });
        logger.info('Database connected', { host, port, database });
      },
      terminate: async () => {
        await pool.close();
        logger.info('Database disconnected');
      },
    };
  },
});

// Usage with config (overrides defaults)
const server = Blaize.createServer().register(
  databasePlugin({
    host: 'prod.db.example.com',
    port: 5432,
    database: 'production',
    poolSize: 20,
  })
);

// Usage with defaults
const devServer = Blaize.createServer().register(databasePlugin()); // Uses all defaults
```

### Default configuration

The `defaultConfig` option provides base values that user config merges into:

```typescript
const cachePlugin = createPlugin<{ ttl: number; maxSize: number }, {}, { cache: CacheService }>({
  name: 'cache',
  version: '1.0.0',
  defaultConfig: {
    ttl: 3600, // 1 hour default
    maxSize: 1000, // 1000 items default
  },
  setup: (config, logger) => {
    // config.ttl and config.maxSize are always defined
    // (from defaults or user override)
    logger.info('Cache initialized', { ttl: config.ttl, maxSize: config.maxSize });
    // ...
  },
});

// Override just ttl
const server = Blaize.createServer().register(cachePlugin({ ttl: 60 })); // maxSize stays at 1000
```

---

## Type flow through plugins

Plugins add types via the `TState` and `TServices` generic parameters. The types flow through middleware:

```typescript
// Plugin declares its type contributions
const databasePlugin = createPlugin<
  { url: string }, // Config
  {}, // State (none)
  { db: Database } // Services
>({
  name: 'database',
  version: '1.0.0',
  setup: (config, logger) => {
    let db: Database;

    return {
      register: async server => {
        // Middleware must match the TServices generic
        server.use(
          createMiddleware<{}, { db: Database }>({
            handler: async ({ ctx, next }) => {
              ctx.services.db = db;
              await next();
            },
          })
        );
      },
      initialize: async () => {
        db = await Database.connect(config.url);
        logger.info('Database connected');
      },
      terminate: async () => {
        await db.close();
        logger.info('Database disconnected');
      },
    };
  },
});
```

When the plugin is registered, types flow to the server:

```typescript
const server = Blaize.createServer()
  .register(databasePlugin({ url: 'postgres://...' })) // Adds { db: Database }
  .register(cachePlugin()); // Adds { cache: CacheService }

type AppContext = InferContext<typeof server>;
// AppContext['services'] = { db: Database; cache: CacheService }

// Route handlers get the types
export const getUsers = route.get({
  handler: async ({ ctx }) => {
    ctx.services.db; // ‚úÖ Typed as Database
    ctx.services.cache; // ‚úÖ Typed as CacheService
  },
});
```

---

## Adding routes from plugins

Plugins can add routes dynamically via the `register` hook:

```typescript
const healthPlugin = createPlugin<{}, {}, {}>({
  name: 'health',
  version: '1.0.0',
  setup: (config, logger) => ({
    register: async server => {
      server.router.addRoute({
        path: '/health',
        GET: {
          handler: async () => ({
            status: 'ok',
            timestamp: Date.now(),
          }),
        },
      });
      logger.info('Health route registered');
    },
  }),
});

interface MetricsOptions {
  path?: string;
}

const metricsPlugin = createPlugin<MetricsOptions, {}, { metrics: MetricsCollector }>({
  name: 'metrics',
  version: '1.0.0',
  defaultConfig: {
    path: '/metrics',
  },
  setup: (config, logger) => {
    let collector: MetricsCollector;

    return {
      register: async server => {
        // Add middleware for typed access
        server.use(
          createMiddleware<{}, { metrics: MetricsCollector }>({
            handler: async ({ ctx, next }) => {
              ctx.services.metrics = collector;
              await next();
            },
          })
        );

        // Add metrics endpoint
        server.router.addRoute({
          path: config.path!,
          GET: {
            handler: async ({ ctx }) => {
              const metrics = await collector.export();
              ctx.response.header('Content-Type', 'text/plain');
              return metrics;
            },
          },
        });
        logger.info('Metrics route registered', { path: config.path });
      },
      initialize: async () => {
        collector = new MetricsCollector();
        collector.start();
        logger.info('Metrics collector started');
      },
      terminate: async () => {
        collector.stop();
        logger.info('Metrics collector stopped');
      },
    };
  },
});
```

---

## Common plugin patterns

### Pattern 1: Database connection pool

```typescript
interface DatabaseOptions {
  connectionString: string;
  poolSize?: number;
}

const databasePlugin = createPlugin<DatabaseOptions, {}, { db: Pool }>({
  name: 'database',
  version: '1.0.0',
  defaultConfig: {
    connectionString: 'postgresql://localhost:5432/app',
    poolSize: 10,
  },
  setup: (config, logger) => {
    let pool: Pool;

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { db: Pool }>({
            name: 'database',
            handler: async ({ ctx, next }) => {
              ctx.services.db = pool;
              await next();
            },
          })
        );
      },
      initialize: async () => {
        pool = new Pool({
          connectionString: config.connectionString,
          max: config.poolSize,
        });
        // Verify connection
        await pool.query('SELECT 1');
        logger.info('Database pool initialized', { poolSize: config.poolSize });
      },
      terminate: async () => {
        await pool.end();
        logger.info('Database pool closed');
      },
    };
  },
});
```

### Pattern 2: Redis cache

```typescript
interface CacheOptions {
  url: string;
  ttl?: number;
}

interface CacheService {
  get: (key: string) => Promise<unknown | null>;
  set: (key: string, value: unknown, ttl?: number) => Promise<void>;
  del: (key: string) => Promise<void>;
}

const cachePlugin = createPlugin<CacheOptions, {}, { cache: CacheService }>({
  name: 'cache',
  version: '1.0.0',
  defaultConfig: {
    url: 'redis://localhost:6379',
    ttl: 3600,
  },
  setup: (config, logger) => {
    let redis: RedisClient;

    const cache: CacheService = {
      get: async key => {
        const value = await redis.get(key);
        return value ? JSON.parse(value) : null;
      },
      set: async (key, value, ttl) => {
        const serialized = JSON.stringify(value);
        const expiry = ttl ?? config.ttl;
        if (expiry) {
          await redis.setex(key, expiry, serialized);
        } else {
          await redis.set(key, serialized);
        }
      },
      del: async key => {
        await redis.del(key);
      },
    };

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { cache: CacheService }>({
            name: 'cache',
            handler: async ({ ctx, next }) => {
              ctx.services.cache = cache;
              await next();
            },
          })
        );
      },
      initialize: async () => {
        redis = new RedisClient(config.url);
        await redis.connect();
        logger.info('Redis cache connected');
      },
      terminate: async () => {
        await redis.quit();
        logger.info('Redis cache disconnected');
      },
    };
  },
});
```

### Pattern 3: Background job queue

```typescript
interface QueueOptions {
  concurrency?: number;
}

interface QueueService {
  add: (name: string, data: unknown) => Promise<string>;
  getStatus: (jobId: string) => Promise<string>;
}

const queuePlugin = createPlugin<QueueOptions, {}, { queue: QueueService }>({
  name: 'queue',
  version: '1.0.0',
  defaultConfig: {
    concurrency: 5,
  },
  setup: (config, logger) => {
    let queue: JobQueue;

    const queueService: QueueService = {
      add: async (name, data) => queue.add(name, data),
      getStatus: async jobId => queue.getStatus(jobId),
    };

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { queue: QueueService }>({
            name: 'queue',
            handler: async ({ ctx, next }) => {
              ctx.services.queue = queueService;
              await next();
            },
          })
        );
      },
      initialize: async () => {
        queue = new JobQueue({ concurrency: config.concurrency });
        logger.info('Job queue initialized', { concurrency: config.concurrency });
      },
      onServerStart: async () => {
        queue.startProcessing();
        logger.info('Job queue processing started');
      },
      onServerStop: async () => {
        await queue.drain(); // Wait for in-flight jobs
        logger.info('Job queue drained');
      },
      terminate: async () => {
        queue.shutdown();
        logger.info('Job queue shutdown');
      },
    };
  },
});
```

### Pattern 4: External API client

```typescript
interface ApiClientOptions {
  baseUrl: string;
  apiKey: string;
  timeout?: number;
}

interface ApiClient {
  get: (path: string) => Promise<unknown>;
  post: (path: string, body: unknown) => Promise<unknown>;
}

const apiClientPlugin = createPlugin<ApiClientOptions, {}, { api: ApiClient }>({
  name: 'api-client',
  version: '1.0.0',
  defaultConfig: {
    baseUrl: 'https://api.example.com',
    apiKey: '',
    timeout: 30000,
  },
  setup: (config, logger) => {
    const client: ApiClient = {
      get: async path => {
        const res = await fetch(`${config.baseUrl}${path}`, {
          headers: { Authorization: `Bearer ${config.apiKey}` },
          signal: AbortSignal.timeout(config.timeout!),
        });
        return res.json();
      },
      post: async (path, body) => {
        const res = await fetch(`${config.baseUrl}${path}`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${config.apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
          signal: AbortSignal.timeout(config.timeout!),
        });
        return res.json();
      },
    };

    return {
      register: async server => {
        server.use(
          createMiddleware<{}, { api: ApiClient }>({
            name: 'api-client',
            handler: async ({ ctx, next }) => {
              ctx.services.api = client;
              await next();
            },
          })
        );
        logger.info('API client registered', { baseUrl: config.baseUrl });
      },
      // No async initialization needed for fetch-based clients
    };
  },
});
```

---

## Anti-patterns to avoid

### ‚ùå Creating resources per request

```typescript
// ‚ùå WRONG: New connection every request
const badPlugin = createPlugin<{}, {}, { db: Database }>({
  name: 'bad',
  version: '1.0.0',
  setup: () => ({
    register: async server => {
      server.use(
        createMiddleware({
          handler: async ({ ctx, next }) => {
            ctx.services.db = await Database.connect(); // Expensive!
            await next();
            await ctx.services.db.close();
          },
        })
      );
    },
  }),
});

// ‚úÖ CORRECT: Create once, reference many
const goodPlugin = createPlugin<{}, {}, { db: Database }>({
  name: 'good',
  version: '1.0.0',
  setup: (config, logger) => {
    let db: Database;

    return {
      register: async server => {
        server.use(
          createMiddleware({
            handler: async ({ ctx, next }) => {
              ctx.services.db = db; // Just a reference
              await next();
            },
          })
        );
      },
      initialize: async () => {
        db = await Database.connect();
        logger.info('Database connected');
      },
      terminate: async () => {
        await db.close();
        logger.info('Database disconnected');
      },
    };
  },
});
```

### ‚ùå Forgetting cleanup

```typescript
// ‚ùå WRONG: No cleanup
const leakyPlugin = createPlugin<{}, {}, {}>({
  name: 'leaky',
  version: '1.0.0',
  setup: () => {
    let interval: NodeJS.Timeout;

    return {
      initialize: async () => {
        interval = setInterval(doSomething, 1000); // Runs forever!
      },
      // Missing terminate!
    };
  },
});

// ‚úÖ CORRECT: Clean up resources
const cleanPlugin = createPlugin<{}, {}, {}>({
  name: 'clean',
  version: '1.0.0',
  setup: (config, logger) => {
    let interval: NodeJS.Timeout;

    return {
      initialize: async () => {
        interval = setInterval(doSomething, 1000);
        logger.info('Timer started');
      },
      terminate: async () => {
        clearInterval(interval); // Clean up!
        logger.info('Timer stopped');
      },
    };
  },
});
```

### ‚ùå Ignoring return value

```typescript
// ‚ùå WRONG: Types lost
const base = Blaize.createServer();
base.register(databasePlugin()); // Return value ignored!

type AppContext = InferContext<typeof base>;
// services = {}  ‚Üê db is missing!

// ‚úÖ CORRECT: Capture return
const server = Blaize.createServer().register(databasePlugin());

type AppContext = InferContext<typeof server>;
// services = { db: Database }  ‚úÖ
```

---

## Official plugins

BlaizeJS provides official plugins:

| Plugin  | Package                    | Purpose                                     |
| ------- | -------------------------- | ------------------------------------------- |
| Queue   | `@blaizejs/plugin-queue`   | Background job processing with SSE progress |
| Cache   | `@blaizejs/plugin-cache`   | Memory and Redis caching                    |
| Metrics | `@blaizejs/plugin-metrics` | Prometheus metrics collection               |

```typescript
import { createQueuePlugin } from '@blaizejs/plugin-queue';
import { createCachePlugin } from '@blaizejs/plugin-cache';
import { createMetricsPlugin } from '@blaizejs/plugin-metrics';

const server = Blaize.createServer()
  .register(
    createQueuePlugin({
      /* options */
    })
  )
  .register(
    createCachePlugin({
      /* options */
    })
  )
  .register(
    createMetricsPlugin({
      /* options */
    })
  );
```

---

## Key takeaways

1. **Use plugins for resources** ‚Äî Database connections, cache clients, external APIs
2. **Use middleware for requests** ‚Äî Authentication, logging, validation
3. **Closure pattern** ‚Äî Declare singleton in closure, reference in middleware
4. **Lifecycle hooks** ‚Äî `initialize` to connect, `terminate` to clean up
5. **Type accumulation** ‚Äî Capture `.register()` return value for types
6. **Reverse shutdown** ‚Äî Plugins terminate in reverse registration order
7. **Logger integration** ‚Äî Use plugin-scoped logger for debugging

---

## Related pages

- **[Middleware](/docs/architecture/middleware)** ‚Äî For per-request logic
- **[Type System](/docs/architecture/type-system)** ‚Äî How plugin types flow
- **[Context](/docs/architecture/context)** ‚Äî Where services are accessed
- **[Router](/docs/architecture/router)** ‚Äî How plugins add routes
