# ğŸ”— Middleware

> Middleware wraps your route handlers, executing logic before and after each request â€” authentication, logging, validation, and more.

---

## The big picture

Middleware in BlaizeJS follows the "onion model" â€” each middleware wraps the next, executing code before and after the inner layers:

```
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                  Request Arrives                  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚              Middleware A (before)                â”‚
              â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
              â”‚   â”‚          Middleware B (before)            â”‚   â”‚
              â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
              â”‚   â”‚   â”‚      Middleware C (before)        â”‚   â”‚   â”‚
              â”‚   â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚   â”‚
              â”‚   â”‚   â”‚   â”‚      Route Handler        â”‚   â”‚   â”‚   â”‚
              â”‚   â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚   â”‚
              â”‚   â”‚   â”‚      Middleware C (after)         â”‚   â”‚   â”‚
              â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
              â”‚   â”‚          Middleware B (after)             â”‚   â”‚
              â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
              â”‚              Middleware A (after)                 â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                  Response Sent                    â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The `await next()` call is the pivot point â€” code before it runs on the way in, code after runs on the way out.

---

## Creating middleware

Use `createMiddleware` to create typed middleware:

```typescript
import { createMiddleware } from 'blaizejs';

const loggingMiddleware = createMiddleware<
  { startTime: number }, // Adds to ctx.state
  {} // Adds to ctx.services (none here)
>({
  name: 'logging',

  handler: async ({ ctx, next, logger }) => {
    // BEFORE: Runs when request arrives
    ctx.state.startTime = Date.now();
    logger.info(`â†’ ${ctx.request.method} ${ctx.request.path}`);

    await next(); // Call the next middleware or handler

    // AFTER: Runs when response is ready
    const duration = Date.now() - ctx.state.startTime;
    logger.info(`â† ${ctx.response.statusCode} (${duration}ms)`);
  },
});
```

### Middleware options

| Option    | Type       | Required | Description                           |
| --------- | ---------- | -------- | ------------------------------------- |
| `name`    | `string`   | No       | Identifier for debugging and logging  |
| `handler` | `function` | Yes      | The middleware function               |
| `skip`    | `function` | No       | Return `true` to skip this middleware |
| `debug`   | `boolean`  | No       | Enable verbose logging                |

### Type parameters

```typescript
createMiddleware<TState, TServices>(options);
```

| Parameter   | Description                                       |
| ----------- | ------------------------------------------------- |
| `TState`    | Properties this middleware adds to `ctx.state`    |
| `TServices` | Properties this middleware adds to `ctx.services` |

---

## The handler function

The middleware handler receives a single object with named properties:

```typescript
handler: async ({ ctx, next, logger, eventBus }) => {
  // ctx      - The request context (request, response, state, services)
  // next     - Function to call the next middleware
  // logger   - BlaizeLogger instance scoped to this middleware
  // eventBus - TypedEventBus for publishing/subscribing to events
};
```

**Destructure only what you need:**

```typescript
// Minimal - just ctx and next
handler: async ({ ctx, next }) => { ... }

// With logging
handler: async ({ ctx, next, logger }) => { ... }

// With events
handler: async ({ ctx, next, eventBus }) => { ... }

// Everything
handler: async ({ ctx, next, logger, eventBus }) => { ... }
```

### Calling next()

The `next()` function invokes the next middleware in the chain (or the route handler if there's no more middleware):

```typescript
handler: async ({ ctx, next }) => {
  // Before next(): Request is coming in

  await next(); // Execute the rest of the chain

  // After next(): Response is going out
};
```

**Rules for `next()`:**

1. **Call it once** â€” Calling `next()` multiple times throws an error
2. **Await it** â€” Always `await next()` to properly handle async middleware
3. **Optional** â€” Not calling `next()` short-circuits the chain (useful for auth failures)

```typescript
// âŒ ERROR: Calling next() twice
handler: async ({ ctx, next }) => {
  await next();
  await next(); // Throws: "next() called multiple times"
};

// âœ… Short-circuit: Don't call next() to stop the chain
handler: async ({ ctx, next }) => {
  if (!ctx.request.header('authorization')) {
    ctx.response.status(401).json({ error: 'Unauthorized' });
    return; // Don't call next() â€” request ends here
  }
  await next();
};
```

---

## Type composition

When middleware is added to a server, its types compose automatically:

```typescript
// Auth middleware adds user to state
const authMiddleware = createMiddleware<
  { user: User; isAuthenticated: boolean },
  { auth: AuthService }
>({ ... });

// Timing middleware adds startTime to state
const timingMiddleware = createMiddleware<
  { startTime: number },
  {}
>({ ... });

// Server composes all types
const server = Blaize.createServer()
  .use(authMiddleware)
  .use(timingMiddleware);

type AppContext = InferContext<typeof server>;
// AppContext['state'] = {
//   user: User;
//   isAuthenticated: boolean;
//   startTime: number;
// }
// AppContext['services'] = {
//   auth: AuthService;
// }
```

Route handlers then receive the composed types:

```typescript
export const getProfile = route.get({
  handler: async ({ ctx }) => {
    ctx.state.user; // âœ… User
    ctx.state.isAuthenticated; // âœ… boolean
    ctx.state.startTime; // âœ… number
    ctx.services.auth; // âœ… AuthService
  },
});
```

---

## Skip conditions

Use the `skip` function to conditionally bypass middleware:

```typescript
const authMiddleware = createMiddleware<{ user: User }, {}>({
  name: 'auth',

  handler: async ({ ctx, next }) => {
    const token = ctx.request.header('authorization');
    if (!token) {
      throw new UnauthorizedError('Missing token');
    }
    ctx.state.user = await validateToken(token);
    await next();
  },

  // Skip auth for public routes
  skip: ({ ctx }) => {
    const publicPaths = ['/health', '/public', '/auth/login'];
    return publicPaths.some(path => ctx.request.path.startsWith(path));
  },
});
```

**Skip function signature:**

```typescript
skip: ({ ctx, logger, eventBus }) => boolean;
```

When `skip` returns `true`:

- The middleware's `handler` is **not** called
- Execution continues to the next middleware
- Types are still composed (TypeScript doesn't know about runtime skipping)

---

## Execution order

### Global middleware

Middleware added to the server runs for **all routes** in registration order:

```typescript
const server = Blaize.createServer()
  .use(correlationMiddleware) // Runs 1st
  .use(loggingMiddleware) // Runs 2nd
  .use(authMiddleware); // Runs 3rd

// Execution: correlation â†’ logging â†’ auth â†’ handler â†’ auth â†’ logging â†’ correlation
```

### Route middleware

Middleware can also be added to specific routes:

```typescript
export const getSecrets = route.get({
  middleware: [rateLimitMiddleware, cacheMiddleware],
  handler: async ({ ctx }) => { ... },
});
```

### Combined order

When both exist, the order is:

1. Global middleware (server-level, in order)
2. Route middleware (route-level, in array order)
3. Route handler
4. Route middleware (reverse, after next())
5. Global middleware (reverse, after next())

```typescript
// Server: .use(A).use(B)
// Route: middleware: [X, Y]

// Execution order:
// A before â†’ B before â†’ X before â†’ Y before â†’ handler
// Y after â†’ X after â†’ B after â†’ A after
```

---

## Error handling

Errors thrown in middleware propagate up through the chain:

```typescript
const errorBoundary = createMiddleware({
  name: 'error-boundary',
  handler: async ({ ctx, next, logger }) => {
    try {
      await next();
    } catch (error) {
      // Log the error
      logger.error('Request failed', { error });

      // Handle error, format response
      if (error instanceof BlaizeError) {
        ctx.response.status(error.statusCode).json({
          error: error.message,
          type: error.type,
        });
      } else {
        ctx.response.status(500).json({
          error: 'Internal server error',
        });
      }
    }
  },
});
```

**Error propagation:**

```
A throws â†’ B catches (if try/catch) â†’ Response sent
A â†’ B throws â†’ A catches (if try/catch) â†’ Response sent
A â†’ B â†’ handler throws â†’ B catches â†’ A catches â†’ Response sent
```

---

## Common patterns

### Pattern 1: Authentication

```typescript
interface User {
  id: string;
  email: string;
  role: 'admin' | 'user';
}

interface AuthService {
  verify: (token: string) => Promise<User>;
  hasPermission: (user: User, permission: string) => boolean;
}

const authMiddleware = createMiddleware<{ user: User }, { auth: AuthService }>({
  name: 'auth',

  handler: async ({ ctx, next, logger }) => {
    const token = ctx.request.header('authorization')?.replace('Bearer ', '');

    if (!token) {
      throw new UnauthorizedError('Missing authentication token');
    }

    try {
      ctx.state.user = await authService.verify(token);
      ctx.services.auth = authService;
      logger.info('User authenticated', { userId: ctx.state.user.id });
    } catch {
      throw new UnauthorizedError('Invalid token');
    }

    await next();
  },

  skip: ({ ctx }) => ctx.request.path === '/health',
});
```

### Pattern 2: Request timing

```typescript
const timingMiddleware = createMiddleware<{ startTime: number }, {}>({
  name: 'timing',

  handler: async ({ ctx, next }) => {
    ctx.state.startTime = performance.now();

    await next();

    const duration = performance.now() - ctx.state.startTime;
    ctx.response.header('X-Response-Time', `${duration.toFixed(2)}ms`);
  },
});
```

### Pattern 3: Correlation ID

```typescript
const correlationMiddleware = createMiddleware<{ correlationId: string }, {}>({
  name: 'correlation',

  handler: async ({ ctx, next }) => {
    // Use incoming ID or generate new one
    ctx.state.correlationId =
      ctx.request.header('x-correlation-id') || `req_${crypto.randomUUID()}`;

    // Add to response headers for tracing
    ctx.response.header('x-correlation-id', ctx.state.correlationId);

    await next();
  },
});
```

### Pattern 4: Rate limiting

```typescript
const rateLimits = new Map<string, { count: number; resetAt: number }>();

const rateLimitMiddleware = createMiddleware({
  name: 'rate-limit',

  handler: async ({ ctx, next, logger }) => {
    const ip = ctx.request.header('x-forwarded-for') || 'unknown';
    const now = Date.now();
    const windowMs = 60000; // 1 minute
    const maxRequests = 100;

    let record = rateLimits.get(ip);

    if (!record || now > record.resetAt) {
      record = { count: 0, resetAt: now + windowMs };
      rateLimits.set(ip, record);
    }

    record.count++;

    if (record.count > maxRequests) {
      logger.warn('Rate limit exceeded', { ip, count: record.count });
      throw new RateLimitError('Too many requests', {
        retryAfter: Math.ceil((record.resetAt - now) / 1000),
      });
    }

    ctx.response.header('X-RateLimit-Limit', String(maxRequests));
    ctx.response.header('X-RateLimit-Remaining', String(maxRequests - record.count));
    ctx.response.header('X-RateLimit-Reset', String(record.resetAt));

    await next();
  },
});
```

### Pattern 5: Request validation middleware

```typescript
import { z } from 'zod';

function createValidationMiddleware<T extends z.ZodType>(
  location: 'body' | 'query' | 'params',
  schema: T
) {
  return createMiddleware({
    name: `validate-${location}`,

    handler: async ({ ctx, next, logger }) => {
      const data =
        location === 'body'
          ? ctx.request.body
          : location === 'query'
            ? ctx.request.query
            : ctx.request.params;

      const result = schema.safeParse(data);

      if (!result.success) {
        logger.warn('Validation failed', {
          location,
          errors: result.error.errors,
        });
        throw new ValidationError('Validation failed', {
          errors: result.error.errors,
        });
      }

      await next();
    },
  });
}

// Usage
const userBodySchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
});

export const createUser = route.post({
  middleware: [createValidationMiddleware('body', userBodySchema)],
  handler: async ({ ctx }) => {
    // Body is validated
    const user = await db.users.create(ctx.request.body);
    return user;
  },
});
```

### Pattern 6: EventBus integration

```typescript
const auditMiddleware = createMiddleware<{ auditId: string }, {}>({
  name: 'audit',

  handler: async ({ ctx, next, logger, eventBus }) => {
    const auditId = crypto.randomUUID();
    ctx.state.auditId = auditId;

    // Publish request started event
    await eventBus.publish('audit:request-started', {
      auditId,
      method: ctx.request.method,
      path: ctx.request.path,
      timestamp: Date.now(),
    });

    try {
      await next();

      // Publish success event
      await eventBus.publish('audit:request-completed', {
        auditId,
        statusCode: ctx.response.statusCode,
        timestamp: Date.now(),
      });
    } catch (error) {
      // Publish failure event
      await eventBus.publish('audit:request-failed', {
        auditId,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: Date.now(),
      });
      throw error; // Re-throw to maintain error flow
    }
  },
});
```

---

## Testing middleware

Use `createTestContext` from `@blaizejs/testing-utils`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { createTestContext } from '@blaizejs/testing-utils';
import { authMiddleware } from './auth';

describe('authMiddleware', () => {
  it('sets user in state when valid token provided', async () => {
    const ctx = createTestContext({
      headers: {
        authorization: 'Bearer valid-token',
      },
    });
    const next = vi.fn();
    const logger = createMockLogger();
    const eventBus = createMockEventBus();

    await authMiddleware.handler({ ctx, next, logger, eventBus });

    expect(ctx.state.user).toBeDefined();
    expect(ctx.state.user.id).toBe('user-123');
    expect(next).toHaveBeenCalled();
  });

  it('throws UnauthorizedError when no token', async () => {
    const ctx = createTestContext({
      headers: {},
    });
    const next = vi.fn();
    const logger = createMockLogger();
    const eventBus = createMockEventBus();

    await expect(authMiddleware.handler({ ctx, next, logger, eventBus })).rejects.toThrow(
      'Missing authentication token'
    );

    expect(next).not.toHaveBeenCalled();
  });

  it('skips for health endpoint', () => {
    const ctx = createTestContext({
      path: '/health',
    });
    const logger = createMockLogger();
    const eventBus = createMockEventBus();

    expect(authMiddleware.skip?.({ ctx, logger, eventBus })).toBe(true);
  });
});
```

---

## Key takeaways

1. **Onion model** â€” Code before `next()` runs on request, after runs on response
2. **Type composition** â€” Middleware types combine on the server automatically
3. **Destructured handler** â€” `({ ctx, next, logger, eventBus })`
4. **Call `next()` once** â€” Multiple calls throw an error
5. **Skip for efficiency** â€” Use `skip` to bypass middleware for certain routes
6. **Order matters** â€” Global middleware runs first, then route middleware
7. **Capture return values** â€” `.use()` returns a new server with updated types

---

## Related pages

- **[Context](/docs/architecture/context)** â€” The object middleware modifies
- **[Type System](/docs/architecture/type-system)** â€” How middleware types compose
- **[Plugins](/docs/architecture/plugins)** â€” For lifecycle management and service singletons
- **[Error Handling](/docs/guides/error-handling)** â€” Semantic error classes
- **[Router](/docs/architecture/router)** â€” How middleware integrates with routes
