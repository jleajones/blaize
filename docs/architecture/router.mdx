# ðŸ›¤ï¸ Router

> File paths become URL paths. Export names become client methods. Types flow automatically.

---

## Why File-Based Routing?

Most frameworks require you to manually register routes:

```typescript
// Traditional approach
app.get('/users', listUsers);
app.get('/users/:id', getUser);
app.post('/users', createUser);
// ... repeat for every route
```

BlaizeJS takes a different approach: **your file structure IS your route structure**. Create a file, get a route. No registration, no configuration, no room for URL/handler mismatches.

```
src/routes/                         URL
â”œâ”€â”€ index.ts                   â†’    /
â”œâ”€â”€ health.ts                  â†’    /health
â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ index.ts               â†’    /users
â”‚   â””â”€â”€ [userId]/
â”‚       â”œâ”€â”€ index.ts           â†’    /users/:userId
â”‚       â””â”€â”€ posts.ts           â†’    /users/:userId/posts
â””â”€â”€ api/
    â””â”€â”€ v1/
        â””â”€â”€ status.ts          â†’    /api/v1/status
```

**Benefits:**
- **Discoverable:** New developers can understand your API by browsing files
- **Predictable:** File location guarantees URL structure
- **Maintainable:** Refactoring files automatically refactors URLs
- **Type-safe:** File exports carry types to the client

---

## How Routes Connect to Types

Before diving into route definitions, it's important to understand where the `route` object comes from. This is the bridge between your server's types and your route handlers.

In your main app file, you create a **route factory** that inherits types from your server:

```typescript
// src/app.ts
import { Blaize, type InferContext } from 'blaizejs';

// 1. Create server with middleware and plugins
const app = Blaize.createServer({
  port: 3000,
  routesDir: './src/routes',
  middleware: [authMiddleware],
  plugins: [databasePlugin()],
});

// 2. Extract the composed context types
type AppContext = InferContext<typeof app>;

// 3. Create a route factory that carries these types
export const route = Blaize.Router.createRouteFactory<
  AppContext['state'],     // { user: User } from authMiddleware
  AppContext['services']   // { db: Database } from databasePlugin
>();

await app.listen();
```

Now every route file imports this `route` factory:

```typescript
// src/routes/users.ts
import { route } from '../app';  // â† Types flow from here

export const listUsers = route.get({
  handler: async (ctx) => {
    ctx.state.user;      // âœ… Typed as User
    ctx.services.db;     // âœ… Typed as Database
  },
});
```

For a deeper explanation of how types flow through the system, see **[Type System](/docs/architecture/type-system)**.

---

## Path Mapping Rules

### Basic Mapping

| File Path | URL Path |
|-----------|----------|
| `routes/index.ts` | `/` |
| `routes/users.ts` | `/users` |
| `routes/users/index.ts` | `/users` |
| `routes/health.ts` | `/health` |
| `routes/api/v1/status.ts` | `/api/v1/status` |

### Dynamic Segments

Use `[param]` brackets for dynamic URL segments:

| File Path | URL Path | Parameters |
|-----------|----------|------------|
| `routes/users/[userId].ts` | `/users/:userId` | `userId` |
| `routes/users/[userId]/index.ts` | `/users/:userId` | `userId` |
| `routes/users/[userId]/posts.ts` | `/users/:userId/posts` | `userId` |
| `routes/posts/[postId]/comments/[commentId].ts` | `/posts/:postId/comments/:commentId` | `postId`, `commentId` |

The parameter name inside brackets becomes the key in `params`:

```typescript
// routes/users/[userId].ts
export const getUser = route.get({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
  },
  handler: async (ctx, params) => {
    // params.userId is the value from the URL
    // GET /users/abc-123 â†’ params.userId = "abc-123"
    return await db.users.findById(params.userId);
  },
});
```

### Index Files

`index.ts` files represent the directory path:

```
routes/users/index.ts    â†’  /users      (not /users/index)
routes/users/[userId]/index.ts  â†’  /users/:userId
```

---

## Route Factory Methods

The route factory (explained above) provides methods for all HTTP verbs:

| Method | HTTP Verb | Request Body | Files Support | Common Use |
|--------|-----------|--------------|---------------|------------|
| `route.get()` | GET | No | No | Fetch resources |
| `route.post()` | POST | **Yes** | **Yes** | Create resources, **file uploads** |
| `route.put()` | PUT | **Yes** | **Yes** | Replace resources, **update files** |
| `route.patch()` | PATCH | **Yes** | **Yes** | Partial updates, **file uploads** |
| `route.delete()` | DELETE | No | No | Remove resources |
| `route.head()` | HEAD | No | No | Headers only |
| `route.options()` | OPTIONS | No | No | CORS preflight |
| `route.sse()` | GET | No | No | Server-Sent Events |

**File upload methods:**
- POST, PUT, PATCH support both `body` and `files` schemas
- GET, DELETE, HEAD, OPTIONS do not accept request bodies
- Client automatically detects files and switches to multipart encoding

---

## Route Definition

Each route is defined with a schema and handler:

```typescript
// src/routes/users/[userId].ts
import { route } from '../../app';
import { z } from 'zod';

export const getUser = route.get({
  // Schema validates params, query, body, files, and response
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    query: z.object({ 
      include: z.array(z.string()).optional() 
    }),
    response: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  },
  
  // Optional route-level middleware
  middleware: [rateLimitMiddleware],
  
  // Handler receives typed context and params
  handler: async (ctx, params, logger) => {
    logger.info('Fetching user', { userId: params.userId });
    
    const user = await ctx.services.db.users.findById(params.userId);
    
    if (!user) {
      throw new NotFoundError('User not found');
    }
    
    return user;  // Validated against response schema
  },
});
```

### Handler Signature

```typescript
handler: async (ctx, params, logger) => {
  // ctx     - Context with request, response, state, services
  // params  - Validated URL parameters (typed from schema.params)
  // logger  - BlaizeLogger scoped to this route
  
  return response;  // Validated against schema.response
}
```

### Schema Properties

| Property | Methods | Purpose | Access |
|----------|---------|---------|--------|
| `params` | All | URL path parameters (`:userId`) | `params` argument |
| `query` | All | Query string (`?limit=10`) | `ctx.request.query` |
| `body` | POST, PUT, PATCH | JSON/form body | `ctx.request.body` |
| `files` | POST, PUT, PATCH | **Uploaded files** | **`ctx.request.files`** |
| `response` | All | Response validation | Return value |

**Schema validation order:**
1. `params` - Extracted from URL path
2. `query` - Parsed from query string
3. **Multipart detection** - If `Content-Type: multipart/form-data`
4. `files` - Validated file uploads (if multipart)
5. `body` - Validated request body (or form fields if multipart)
6. `response` - Validated return value (development only)

---

## File Upload Routes

Routes can accept file uploads alongside regular body data using the `files` schema property:

```typescript
// routes/users/[userId]/avatar.ts
import { file } from 'blaizejs';
import { z } from 'zod';

export const updateAvatar = route.patch({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    files: z.object({
      avatar: file({
        maxSize: '5MB',
        accept: ['image/jpeg', 'image/png', 'image/webp'],
      }),
    }),
    response: z.object({
      avatarUrl: z.string().url(),
    }),
  },
  handler: async ({ ctx, params }) => {
    const { avatar } = ctx.request.files;
    
    // avatar is typed as UploadedFile
    console.log(avatar.originalname);  // Typed!
    console.log(avatar.size);          // Typed!
    console.log(avatar.mimetype);      // Typed!
    
    // Upload to storage...
    const url = await ctx.services.storage.upload(avatar);
    
    return { avatarUrl: url };
  },
});
```

### Mixed Body + Files

Combine form data with file uploads in a single request:

```typescript
export const createPost = route.post({
  schema: {
    body: z.object({
      title: z.string().min(1),
      content: z.string(),
      tags: z.array(z.string()).optional(),
    }),
    files: z.object({
      coverImage: file({ maxSize: '2MB', accept: ['image/*'] }),
      attachments: file({ maxSize: '10MB' }).array().optional(),
    }),
  },
  handler: async ({ ctx }) => {
    const { title, content, tags } = ctx.request.body;
    const { coverImage, attachments } = ctx.request.files;
    
    // Process both body data and files...
  },
});
```

### File Validation

The `file()` helper provides built-in validation:

- **Size limits**: `maxSize: '5MB'` (supports KB, MB, GB, TB)
- **MIME types**: `accept: ['image/*', 'application/pdf']`
- **Wildcards**: `image/*`, `video/*`, `audio/*`
- **Arrays**: `.array()`, `.optional()`, `.nullable()`

```typescript
// Multiple files
files: z.object({
  photos: file({ maxSize: '5MB', accept: ['image/*'] }).array(),
}),

// Optional file
files: z.object({
  resume: file({ accept: ['application/pdf'] }).optional(),
}),
```

### UploadedFile Interface

Files received in handlers have this structure:

```typescript
interface UploadedFile {
  fieldname: string;      // Form field name
  originalname: string;   // Original filename
  encoding: string;       // File encoding
  mimetype: string;       // MIME type
  size: number;           // File size in bytes
  buffer: Buffer;         // File contents
}
```

See **[File Uploads Guide](/docs/guides/file-uploads)** for complete examples including S3/R2 integration, client patterns, and error handling.

---

## Request Body Handling

BlaizeJS automatically detects and handles different request types:

| Content-Type | Detection | Parsing | Access |
|--------------|-----------|---------|--------|
| `application/json` | `Content-Type` header | JSON parser | `ctx.request.body` |
| `application/x-www-form-urlencoded` | `Content-Type` header | Form parser | `ctx.request.body` |
| `multipart/form-data` | `Content-Type` header + boundary | Multipart parser | `ctx.request.files` + `ctx.request.body` |

**Multipart handling:**
- Files are extracted to `ctx.request.files`
- Form fields are available in `ctx.request.body`
- Both are validated against their respective schemas
- Memory strategy buffers files for convenience

---

## Named Exports â†’ Client Methods

**This is crucial:** The export name becomes the client method name.

```typescript
// src/routes/users/index.ts
export const listUsers = route.get({ ... });   // client.$get.listUsers()
export const createUser = route.post({ ... }); // client.$post.createUser()

// src/routes/users/[userId].ts
export const getUser = route.get({ ... });     // client.$get.getUser()
export const updateUser = route.put({ ... });  // client.$put.updateUser()
export const deleteUser = route.delete({ ... }); // client.$delete.deleteUser()

// src/routes/users/[userId]/avatar.ts
export const updateAvatar = route.patch({ ... }); // client.$patch.updateAvatar()
```

### Routes Registry

Export your routes in a registry file for the client:

```typescript
// src/app-type.ts
import { listUsers, createUser } from './routes/users';
import { getUser, updateUser, deleteUser } from './routes/users/[userId]';
import { updateAvatar } from './routes/users/[userId]/avatar';
import { streamNotifications } from './routes/notifications/stream';

export const routes = {
  listUsers,
  createUser,
  getUser,
  updateUser,
  deleteUser,
  updateAvatar,
  streamNotifications,
} as const;  // `as const` is important!
```

### Client Usage

```typescript
// client.ts
import bc from '@blaizejs/client';
import { routes } from './server/app-type';

const client = bc.create('https://api.example.com', routes);

// Methods use export names, not file paths!
const users = await client.$get.listUsers({ query: { limit: 10 } });
const user = await client.$get.getUser({ params: { userId: '123' } });
const newUser = await client.$post.createUser({ body: { name: 'Alice' } });

// File uploads - client auto-detects and uses multipart
const file = document.querySelector('input[type="file"]').files[0];
await client.$patch.updateAvatar({
  params: { userId: '123' },
  files: { avatar: file }
});
```

---

## Route Matching Priority

When multiple routes could match a URL, BlaizeJS uses this priority:

1. **Static segments beat dynamic:** `/users/profile` wins over `/users/[id]`
2. **Deeper paths beat shallow:** `/users/[id]/posts` wins over `/users/[id]`
3. **Earlier registration wins ties:** Alphabetical file order

```
GET /users/profile

âœ… routes/users/profile.ts     (static match)
âŒ routes/users/[userId].ts    (dynamic, lower priority)
```

```
GET /users/123

âŒ routes/users/profile.ts     (doesn't match "123")
âœ… routes/users/[userId].ts    (dynamic match, userId = "123")
```

---

## Route Discovery

On server start, BlaizeJS:

1. **Scans** the `routesDir` recursively for `.ts` files
2. **Parses** file paths into URL patterns
3. **Imports** each file and extracts route exports
4. **Registers** routes for fast matching

```typescript
const app = Blaize.createServer({
  routesDir: './src/routes',  // Where to look for routes
});
```

### What Gets Discovered

The router looks for exports that look like routes (objects with HTTP method properties):

```typescript
// âœ… Discovered: Named export with route.get()
export const getUser = route.get({ handler: async () => {} });

// âœ… Discovered: Named export with route.post()  
export const createUser = route.post({ handler: async () => {} });

// âŒ Not a route: No HTTP method
export const userSchema = z.object({ ... });

// âŒ Not a route: Just a function
export function validateUser() { ... }
```

---

## Multiple Routes Per File

A single file can export multiple routes:

```typescript
// src/routes/users/index.ts
import { route } from '../../app';

// GET /users
export const listUsers = route.get({
  schema: {
    query: z.object({ limit: z.coerce.number().default(20) }),
    response: z.array(userSchema),
  },
  handler: async (ctx) => {
    return await ctx.services.db.users.findMany({
      take: ctx.request.query.limit,
    });
  },
});

// POST /users
export const createUser = route.post({
  schema: {
    body: createUserSchema,
    response: userSchema,
  },
  handler: async (ctx) => {
    return await ctx.services.db.users.create(ctx.request.body);
  },
});
```

Both routes share the same URL path (`/users`) but handle different HTTP methods.

---

## Route-Level Middleware

Add middleware to specific routes:

```typescript
export const getSecrets = route.get({
  middleware: [adminOnlyMiddleware, auditLogMiddleware],
  handler: async (ctx) => {
    // Only runs if middleware passes
    return await ctx.services.vault.getSecrets();
  },
});
```

Middleware executes in array order, before the handler.

---

## CRUD Pattern

A typical RESTful resource:

```
src/routes/
â””â”€â”€ posts/
    â”œâ”€â”€ index.ts           # GET /posts, POST /posts
    â””â”€â”€ [postId]/
        â””â”€â”€ index.ts       # GET /posts/:postId, PUT, PATCH, DELETE
```

```typescript
// src/routes/posts/index.ts
export const listPosts = route.get({
  schema: {
    query: paginationSchema,
    response: z.array(postSchema),
  },
  handler: async (ctx) => {
    return await ctx.services.db.posts.findMany();
  },
});

export const createPost = route.post({
  schema: {
    body: createPostSchema,
    response: postSchema,
  },
  handler: async (ctx) => {
    return await ctx.services.db.posts.create({
      ...ctx.request.body,
      authorId: ctx.state.user.id,
    });
  },
});
```

```typescript
// src/routes/posts/[postId]/index.ts
export const getPost = route.get({
  schema: {
    params: z.object({ postId: z.string().uuid() }),
    response: postSchema,
  },
  handler: async (ctx, params) => {
    const post = await ctx.services.db.posts.findById(params.postId);
    if (!post) throw new NotFoundError('Post not found');
    return post;
  },
});

export const updatePost = route.put({
  schema: {
    params: z.object({ postId: z.string().uuid() }),
    body: updatePostSchema,
    response: postSchema,
  },
  handler: async (ctx, params) => {
    return await ctx.services.db.posts.update(params.postId, ctx.request.body);
  },
});

export const deletePost = route.delete({
  schema: {
    params: z.object({ postId: z.string().uuid() }),
  },
  handler: async (ctx, params) => {
    await ctx.services.db.posts.delete(params.postId);
    ctx.response.status(204);
  },
});
```

---

## Common Patterns

### Pattern: File Upload with Metadata

Handle file uploads with structured metadata:

```typescript
export const uploadDocument = route.post({
  schema: {
    body: z.object({
      title: z.string().min(1),
      category: z.enum(['legal', 'financial', 'personal']),
      metadata: z.object({
        author: z.string(),
        department: z.string(),
        confidential: z.boolean().default(false),
      }),
    }),
    files: z.object({
      document: file({
        maxSize: '10MB',
        accept: ['application/pdf', 'application/msword'],
      }),
      attachments: file({ maxSize: '5MB' }).array().optional(),
    }),
  },
  handler: async ({ ctx }) => {
    const { title, category, metadata } = ctx.request.body;
    const { document, attachments } = ctx.request.files;
    
    // Upload main document
    const documentUrl = await ctx.services.storage.upload(document);
    
    // Upload attachments if present
    const attachmentUrls = attachments
      ? await Promise.all(attachments.map(a => ctx.services.storage.upload(a)))
      : [];
    
    return {
      documentId: generateId(),
      documentUrl,
      attachmentCount: attachmentUrls.length,
    };
  },
});
```

### Pattern: Multi-File Upload

Accept multiple files in a single upload:

```typescript
export const uploadGallery = route.post({
  schema: {
    body: z.object({
      albumTitle: z.string(),
      albumDescription: z.string().optional(),
    }),
    files: z.object({
      photos: file({
        maxSize: '10MB',
        accept: ['image/jpeg', 'image/png'],
      }).array().min(1).max(20),
    }),
  },
  handler: async ({ ctx }) => {
    const { albumTitle, albumDescription } = ctx.request.body;
    const { photos } = ctx.request.files;
    
    // Upload all photos concurrently
    const uploadedPhotos = await Promise.all(
      photos.map(async (photo) => {
        const url = await ctx.services.storage.upload(photo);
        return {
          url,
          filename: photo.originalname,
          size: photo.size,
        };
      })
    );
    
    return {
      albumTitle,
      photoCount: photos.length,
      photos: uploadedPhotos,
    };
  },
});
```

### Pattern: Conditional File Upload

Make files optional based on request context:

```typescript
export const updateProfile = route.patch({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    body: z.object({
      name: z.string().optional(),
      bio: z.string().optional(),
      location: z.string().optional(),
    }),
    files: z.object({
      avatar: file({ maxSize: '5MB', accept: ['image/*'] }).optional(),
      coverPhoto: file({ maxSize: '10MB', accept: ['image/*'] }).optional(),
    }),
  },
  handler: async ({ ctx, params }) => {
    const updates: any = { ...ctx.request.body };
    
    // Only process files if provided
    if (ctx.request.files.avatar) {
      updates.avatarUrl = await uploadFile(ctx.request.files.avatar);
    }
    
    if (ctx.request.files.coverPhoto) {
      updates.coverPhotoUrl = await uploadFile(ctx.request.files.coverPhoto);
    }
    
    await db.users.update(params.userId, updates);
    return { success: true };
  },
});
```

---

## Low-Level Route Creators

For advanced use cases, you can use individual route creators instead of the factory:

```typescript
import { createGetRoute, createPostRoute } from 'blaizejs';

// Without factory â€” no inherited types
export const getHealth = createGetRoute()({
  handler: async () => ({ status: 'ok' }),
});

// With explicit types
export const getUser = createGetRoute<MyState, MyServices>()({
  handler: async (ctx, params) => {
    ctx.state.user;      // Typed as MyState['user']
    ctx.services.db;     // Typed as MyServices['db']
  },
});
```

**Prefer the route factory** â€” it's simpler and automatically inherits types.

---

## Configuration

```typescript
const app = Blaize.createServer({
  // Where to find route files
  routesDir: './src/routes',
});
```

The router scans `.ts` files recursively from `routesDir`. Currently, only TypeScript files are supported.

---

## Key Takeaways

1. **File paths = URL paths** â€” No configuration needed
2. **`[param]` = dynamic segments** â€” Extracted and typed automatically
3. **Export names = client method names** â€” Choose meaningful names
4. **Route factory inherits types** â€” Context is fully typed in handlers
5. **Static beats dynamic** â€” Exact matches take priority
6. **One file, multiple routes** â€” Export different HTTP methods
7. **Files schema for uploads** â€” Type-safe file handling with validation
8. **Automatic multipart detection** â€” Client handles encoding automatically

---

## Related Pages

- **[Type System](/docs/architecture/type-system)** â€” How route types flow to client
- **[Context](/docs/architecture/context)** â€” What's available in handlers
- **[Middleware](/docs/architecture/middleware)** â€” Route-level middleware
- **[SSE](/docs/architecture/sse)** â€” Real-time streaming routes
- **[File Uploads](/docs/guides/file-uploads)** â€” Complete file upload guide with examples