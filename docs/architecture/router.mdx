# ðŸ›¤ï¸ Router

> File paths become URL paths. Export names become client methods. Types flow automatically.

---

## Why file-based routing?

Most frameworks require you to manually register routes:

```typescript
// Traditional approach
app.get('/users', listUsers);
app.get('/users/:id', getUser);
app.post('/users', createUser);
// ... repeat for every route
```

BlaizeJS takes a different approach: **your file structure IS your route structure**. Create a file, get a route. No registration, no configuration, no room for URL/handler mismatches.

```
src/routes/                         URL
â”œâ”€â”€ index.ts                   â†’    /
â”œâ”€â”€ health.ts                  â†’    /health
â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ index.ts               â†’    /users
â”‚   â””â”€â”€ [userId]/
â”‚       â”œâ”€â”€ index.ts           â†’    /users/:userId
â”‚       â””â”€â”€ posts.ts           â†’    /users/:userId/posts
â””â”€â”€ api/
    â””â”€â”€ v1/
        â””â”€â”€ status.ts          â†’    /api/v1/status
```

**Benefits:**

- **Discoverable:** New developers can understand your API by browsing files
- **Predictable:** File location guarantees URL structure
- **Maintainable:** Refactoring files automatically refactors URLs
- **Type-safe:** File exports carry types to the client

---

## How routes connect to types

Before diving into route definitions, it's important to understand where the `route` object comes from. This is the bridge between your server's types and your route handlers.

In your main app file, you create a **route factory** that inherits types from your server:

```typescript
// src/app-router.ts
import { Blaize, type InferContext } from 'blaizejs';

// 1. Create type-only server (for type inference)
const typeServer = Blaize.createServer({
  host: 'localhost',
  port: 7485,
  routesDir: './src/routes',
  // Include middleware and plugins for type inference
});

// 2. Extract the composed context types
type AppContext = InferContext<typeof typeServer>;

// 3. Create a route factory that carries these types
export const route = Blaize.Router.createRouteFactory<
  AppContext['state'], // { user: User } from authMiddleware
  AppContext['services'] // { db: Database } from databasePlugin
>();
```

Now every route file imports this `route` factory:

```typescript
// src/routes/users.ts
import { route } from '../app-router'; // â† Types flow from here

export const listUsers = route.get({
  handler: async ({ ctx }) => {
    ctx.state.user; // âœ… Typed as User
    ctx.services.db; // âœ… Typed as Database
  },
});
```

For a deeper explanation of how types flow through the system, see **[Type System](/docs/architecture/type-system)**.

---

## Path mapping rules

### Basic mapping

| File Path                 | URL Path         |
| ------------------------- | ---------------- |
| `routes/index.ts`         | `/`              |
| `routes/users.ts`         | `/users`         |
| `routes/users/index.ts`   | `/users`         |
| `routes/health.ts`        | `/health`        |
| `routes/api/v1/status.ts` | `/api/v1/status` |

### Dynamic segments

Use `[param]` brackets for dynamic URL segments in **both files and folders**:

| File Path                                       | URL Path                             | Parameters            |
| ----------------------------------------------- | ------------------------------------ | --------------------- |
| `routes/users/[userId].ts`                      | `/users/:userId`                     | `userId`              |
| `routes/users/[userId]/index.ts`                | `/users/:userId`                     | `userId`              |
| `routes/users/[userId]/posts.ts`                | `/users/:userId/posts`               | `userId`              |
| `routes/posts/[postId]/comments/[commentId].ts` | `/posts/:postId/comments/:commentId` | `postId`, `commentId` |

**Both patterns work:**

- **File pattern:** `tasks/[taskId].ts` â€” Use when you have a single endpoint at that parameter
- **Folder pattern:** `users/[userId]/tasks.ts` â€” Use when multiple routes share the same parameter

The parameter name inside brackets becomes the key in `params`:

```typescript
// routes/users/[userId].ts (file pattern)
export const getUser = route.get({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
  },
  handler: async ({ params }) => {
    // params.userId is the value from the URL
    // GET /users/abc-123 â†’ params.userId = "abc-123"
    return await db.users.findById(params.userId);
  },
});
```

```typescript
// routes/users/[userId]/tasks.ts (folder pattern)
export const getUserTasks = route.get({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
  },
  handler: async ({ params }) => {
    // GET /users/abc-123/tasks â†’ params.userId = "abc-123"
    return await db.tasks.findAll({ userId: params.userId });
  },
});
```

### Index files

`index.ts` files represent the directory path:

```
routes/users/index.ts    â†’  /users      (not /users/index)
routes/users/[userId]/index.ts  â†’  /users/:userId
```

---

## Route factory methods

The route factory (explained above) provides methods for all HTTP verbs:

| Method            | HTTP Verb | Request Body | Files Support | Handler Params                                  | Common Use                          |
| ----------------- | --------- | ------------ | ------------- | ----------------------------------------------- | ----------------------------------- |
| `route.get()`     | GET       | No           | No            | `{ ctx, params, logger, eventBus }`             | Fetch resources                     |
| `route.post()`    | POST      | **Yes**      | **Yes**       | `{ ctx, params, logger, eventBus }`             | Create resources, **file uploads**  |
| `route.put()`     | PUT       | **Yes**      | **Yes**       | `{ ctx, params, logger, eventBus }`             | Replace resources, **update files** |
| `route.patch()`   | PATCH     | **Yes**      | **Yes**       | `{ ctx, params, logger, eventBus }`             | Partial updates, **file uploads**   |
| `route.delete()`  | DELETE    | No           | No            | `{ ctx, params, logger, eventBus }`             | Remove resources                    |
| `route.head()`    | HEAD      | No           | No            | `{ ctx, params, logger, eventBus }`             | Headers only                        |
| `route.options()` | OPTIONS   | No           | No            | `{ ctx, params, logger, eventBus }`             | CORS preflight                      |
| `route.sse()`     | GET       | No           | No            | **`{ stream, ctx, params, logger, eventBus }`** | **Server-Sent Events**              |

**Key differences:**

- **SSE routes** include `stream` as first parameter for sending events
- **File upload methods** (POST, PUT, PATCH) support both `body` and `files` schemas
- **All routes** receive the same context object with different capabilities

---

## Route definition

Each route is defined with a schema and handler:

```typescript
// src/routes/users/[userId].ts
import { route } from '../../app-router';
import { z } from 'zod';

export const getUser = route.get({
  // Schema validates params, query, body, files, and response
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    query: z.object({
      include: z.array(z.string()).optional(),
    }),
    response: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  },

  // Optional route-level middleware
  middleware: [rateLimitMiddleware],

  // Handler receives single object with named properties
  handler: async ({ ctx, params, logger }) => {
    logger.info('Fetching user', { userId: params.userId });

    const user = await ctx.services.db.users.findById(params.userId);

    if (!user) {
      throw new NotFoundError('User not found');
    }

    return user; // Validated against response schema
  },
});
```

### Handler signature

**Regular routes (GET, POST, PUT, PATCH, DELETE):**

```typescript
handler: async ({ ctx, params, logger, eventBus }) => {
  // ctx       - Context with request, response, state, services
  // params    - Validated URL parameters (typed from schema.params)
  // logger    - BlaizeLogger scoped to this route
  // eventBus  - TypedEventBus for publishing events

  return response; // Validated against schema.response
};
```

**SSE routes:**

```typescript
handler: async ({ stream, ctx, params, logger, eventBus }) => {
  // stream    - TypedSSEStream for sending events to client
  // ctx       - Context with request, response, state, services
  // params    - Validated URL parameters (typed from schema.params)
  // logger    - BlaizeLogger scoped to this route
  // eventBus  - TypedEventBus for subscribing to events

  // SSE handlers don't return - they send events via stream
  stream.send('message', { text: 'Hello!' });
};
```

**Key points:**

- Handler receives a **single object** with named properties
- **Destructure only what you need:** `({ ctx })` or `({ ctx, params, logger })`
- **SSE handlers include `stream`** as the first destructured property
- All parameters are available, use what's relevant to your route
- Parameters are fully typed based on your schemas

### Schema properties

| Property   | Methods          | Purpose                         | Access                  |
| ---------- | ---------------- | ------------------------------- | ----------------------- |
| `params`   | All              | URL path parameters (`:userId`) | `params` argument       |
| `query`    | All              | Query string (`?limit=10`)      | `ctx.request.query`     |
| `body`     | POST, PUT, PATCH | JSON/form body                  | `ctx.request.body`      |
| `files`    | POST, PUT, PATCH | **Uploaded files**              | **`ctx.request.files`** |
| `response` | All              | Response validation             | Return value            |

**Schema validation order:**

1. `params` - Extracted from URL path
2. `query` - Parsed from query string
3. **Multipart detection** - If `Content-Type: multipart/form-data`
4. `files` - Validated file uploads (if multipart)
5. `body` - Validated request body (or form fields if multipart)
6. `response` - Validated return value (development only)

---

## File upload routes

Routes can accept file uploads alongside regular body data using the `files` schema property:

```typescript
// routes/users/[userId]/avatar.ts
import { file } from 'blaizejs';
import { z } from 'zod';

export const updateAvatar = route.patch({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    files: z.object({
      avatar: file({
        maxSize: '5MB',
        accept: ['image/jpeg', 'image/png', 'image/webp'],
      }),
    }),
    response: z.object({
      avatarUrl: z.string().url(),
    }),
  },
  handler: async ({ ctx, params }) => {
    const { avatar } = ctx.request.files;

    // avatar is typed as UploadedFile
    console.log(avatar.originalname); // Typed!
    console.log(avatar.size); // Typed!
    console.log(avatar.mimetype); // Typed!

    // Upload to storage...
    const url = await ctx.services.storage.upload(avatar);

    return { avatarUrl: url };
  },
});
```

### Mixed body + files

Combine form data with file uploads in a single request:

```typescript
export const createPost = route.post({
  schema: {
    body: z.object({
      title: z.string().min(1),
      content: z.string(),
      tags: z.array(z.string()).optional(),
    }),
    files: z.object({
      coverImage: file({ maxSize: '2MB', accept: ['image/*'] }),
      attachments: file({ maxSize: '10MB' }).array().optional(),
    }),
  },
  handler: async ({ ctx }) => {
    const { title, content, tags } = ctx.request.body;
    const { coverImage, attachments } = ctx.request.files;

    // Process both body data and files...
  },
});
```

### File validation

The `file()` helper provides built-in validation:

- **Size limits**: `maxSize: '5MB'` (supports KB, MB, GB, TB)
- **MIME types**: `accept: ['image/*', 'application/pdf']`
- **Wildcards**: `image/*`, `video/*`, `audio/*`
- **Arrays**: `.array()`, `.optional()`, `.nullable()`

```typescript
// Multiple files
files: z.object({
  photos: file({ maxSize: '5MB', accept: ['image/*'] }).array(),
}),

// Optional file
files: z.object({
  resume: file({ accept: ['application/pdf'] }).optional(),
}),
```

### UploadedFile interface

Files received in handlers have this structure:

```typescript
interface UploadedFile {
  fieldname: string; // Form field name
  originalname: string; // Original filename
  encoding: string; // File encoding
  mimetype: string; // MIME type
  size: number; // File size in bytes
  buffer: Buffer; // File contents
}
```

See **[File Uploads Guide](/docs/guides/file-uploads)** for complete examples including S3/R2 integration, client patterns, and error handling.

---

## SSE (Server-Sent Events) routes

SSE routes enable real-time streaming from server to client:

```typescript
// routes/notifications/stream.ts
import { route } from '../../app-router';
import { z } from 'zod';

export const streamNotifications = route.sse({
  schema: {
    query: z.object({
      userId: z.string().uuid(),
    }),
    events: {
      notification: z.object({
        id: z.string(),
        message: z.string(),
        timestamp: z.number(),
      }),
      heartbeat: z.object({
        timestamp: z.number(),
      }),
    },
  },
  handler: async ({ stream, ctx, params, logger, eventBus }) => {
    const { userId } = ctx.request.query;

    logger.info('SSE connection established', { userId });

    // Send heartbeat every 30 seconds
    const heartbeat = setInterval(() => {
      stream.send('heartbeat', { timestamp: Date.now() });
    }, 30000);

    // Subscribe to user's notifications via EventBus
    const unsubscribe = eventBus.subscribe(`notification:${userId}`, event => {
      stream.send('notification', event.data);
    });

    // Cleanup on disconnect
    stream.onClose(() => {
      clearInterval(heartbeat);
      unsubscribe();
      logger.info('SSE connection closed', { userId });
    });
  },
});
```

**SSE-specific features:**

- **`stream` parameter** - First in handler destructuring
- **`schema.events`** - Defines typed events (replaces `response`)
- **`stream.send(event, data)`** - Send typed events to client
- **`stream.onClose(callback)`** - Handle client disconnect
- **No return value** - Handler sends events via stream

**Client usage:**

```typescript
const eventSource = new EventSource('/notifications/stream?userId=123');

eventSource.addEventListener('notification', event => {
  const data = JSON.parse(event.data);
  console.log('Notification:', data.message);
});

eventSource.addEventListener('heartbeat', event => {
  const data = JSON.parse(event.data);
  console.log('Heartbeat:', data.timestamp);
});
```

See **[SSE Guide](/docs/guides/sse)** for complete patterns including error handling, reconnection, and integration with job queues.

---

## Request body handling

BlaizeJS automatically detects and handles different request types:

| Content-Type                        | Detection                        | Parsing          | Access                                   |
| ----------------------------------- | -------------------------------- | ---------------- | ---------------------------------------- |
| `application/json`                  | `Content-Type` header            | JSON parser      | `ctx.request.body`                       |
| `application/x-www-form-urlencoded` | `Content-Type` header            | Form parser      | `ctx.request.body`                       |
| `multipart/form-data`               | `Content-Type` header + boundary | Multipart parser | `ctx.request.files` + `ctx.request.body` |

**Multipart handling:**

- Files are extracted to `ctx.request.files`
- Form fields are available in `ctx.request.body`
- Both are validated against their respective schemas
- Memory strategy buffers files for convenience

---

## Named exports â†’ Client methods

**This is crucial:** The export name becomes the client method name.

```typescript
// src/routes/users/index.ts
export const listUsers = route.get({ ... });   // client.$get.listUsers()
export const createUser = route.post({ ... }); // client.$post.createUser()

// src/routes/users/[userId].ts
export const getUser = route.get({ ... });     // client.$get.getUser()
export const updateUser = route.put({ ... });  // client.$put.updateUser()
export const deleteUser = route.delete({ ... }); // client.$delete.deleteUser()

// src/routes/users/[userId]/avatar.ts
export const updateAvatar = route.patch({ ... }); // client.$patch.updateAvatar()
```

### Routes registry

Export your routes in a registry file for the client:

```typescript
// src/app-type.ts
import { listUsers, createUser } from './routes/users';
import { getUser, updateUser, deleteUser } from './routes/users/[userId]';
import { updateAvatar } from './routes/users/[userId]/avatar';
import { streamNotifications } from './routes/notifications/stream';

export const routes = {
  listUsers,
  createUser,
  getUser,
  updateUser,
  deleteUser,
  updateAvatar,
  streamNotifications,
} as const; // `as const` is important!
```

### Client usage

```typescript
// client.ts
import bc from '@blaizejs/client';
import { routes } from './server/app-type';

const client = bc.create('https://localhost:7485', routes);

// Methods use export names, not file paths!
const users = await client.$get.listUsers({ query: { limit: 10 } });
const user = await client.$get.getUser({ params: { userId: '123' } });
const newUser = await client.$post.createUser({ body: { name: 'Alice' } });

// File uploads - client auto-detects and uses multipart
const file = document.querySelector('input[type="file"]').files[0];
await client.$patch.updateAvatar({
  params: { userId: '123' },
  files: { avatar: file },
});
```

---

## Route matching priority

When multiple routes could match a URL, BlaizeJS uses this priority:

1. **Static segments beat dynamic:** `/users/profile` wins over `/users/[id]`
2. **Deeper paths beat shallow:** `/users/[id]/posts` wins over `/users/[id]`
3. **Earlier registration wins ties:** Alphabetical file order

```
GET /users/profile

âœ… routes/users/profile.ts     (static match)
âŒ routes/users/[userId].ts    (dynamic, lower priority)
```

```
GET /users/123

âŒ routes/users/profile.ts     (doesn't match "123")
âœ… routes/users/[userId].ts    (dynamic match, userId = "123")
```

---

## Route discovery

On server start, BlaizeJS:

1. **Scans** the `routesDir` recursively for `.ts` files
2. **Parses** file paths into URL patterns
3. **Imports** each file and extracts route exports
4. **Registers** routes for fast matching

```typescript
const server = Blaize.createServer({
  routesDir: './src/routes', // Where to look for routes
});
```

### What gets discovered

The router looks for exports that look like routes (objects with HTTP method properties):

```typescript
// âœ… Discovered: Named export with route.get()
export const getUser = route.get({ handler: async () => {} });

// âœ… Discovered: Named export with route.post()
export const createUser = route.post({ handler: async () => {} });

// âŒ Not a route: No HTTP method
export const userSchema = z.object({ ... });

// âŒ Not a route: Just a function
export function validateUser() { ... }
```

---

## Multiple routes per file

A single file can export multiple routes:

```typescript
// src/routes/users/index.ts
import { route } from '../../app-router';

// GET /users
export const listUsers = route.get({
  schema: {
    query: z.object({ limit: z.coerce.number().default(20) }),
    response: z.array(userSchema),
  },
  handler: async ({ ctx }) => {
    return await ctx.services.db.users.findMany({
      take: ctx.request.query.limit,
    });
  },
});

// POST /users
export const createUser = route.post({
  schema: {
    body: createUserSchema,
    response: userSchema,
  },
  handler: async ({ ctx }) => {
    return await ctx.services.db.users.create(ctx.request.body);
  },
});
```

Both routes share the same URL path (`/users`) but handle different HTTP methods.

---

## Route-level middleware

Add middleware to specific routes:

```typescript
export const getSecrets = route.get({
  middleware: [adminOnlyMiddleware, auditLogMiddleware],
  handler: async ({ ctx }) => {
    // Only runs if middleware passes
    return await ctx.services.vault.getSecrets();
  },
});
```

Middleware executes in array order, before the handler.

---

## CRUD pattern

A typical RESTful resource:

```
src/routes/
â””â”€â”€ posts/
    â”œâ”€â”€ index.ts           # GET /posts, POST /posts
    â””â”€â”€ [postId]/
        â””â”€â”€ index.ts       # GET /posts/:postId, PUT, PATCH, DELETE
```

```typescript
// src/routes/posts/index.ts
export const listPosts = route.get({
  schema: {
    query: paginationSchema,
    response: z.array(postSchema),
  },
  handler: async ({ ctx }) => {
    return await ctx.services.db.posts.findMany();
  },
});

export const createPost = route.post({
  schema: {
    body: createPostSchema,
    response: postSchema,
  },
  handler: async ({ ctx }) => {
    return await ctx.services.db.posts.create({
      ...ctx.request.body,
      authorId: ctx.state.user.id,
    });
  },
});
```

```typescript
// src/routes/posts/[postId]/index.ts
export const getPost = route.get({
  schema: {
    params: z.object({ postId: z.string().uuid() }),
    response: postSchema,
  },
  handler: async ({ params }) => {
    const post = await db.posts.findById(params.postId);
    if (!post) throw new NotFoundError('Post not found');
    return post;
  },
});

export const updatePost = route.put({
  schema: {
    params: z.object({ postId: z.string().uuid() }),
    body: updatePostSchema,
    response: postSchema,
  },
  handler: async ({ ctx, params }) => {
    return await ctx.services.db.posts.update(params.postId, ctx.request.body);
  },
});

export const deletePost = route.delete({
  schema: {
    params: z.object({ postId: z.string().uuid() }),
  },
  handler: async ({ ctx, params }) => {
    await ctx.services.db.posts.delete(params.postId);
    ctx.response.status(204);
  },
});
```

---

## Common patterns

### Pattern: File upload with metadata

Handle file uploads with structured metadata:

```typescript
export const uploadDocument = route.post({
  schema: {
    body: z.object({
      title: z.string().min(1),
      category: z.enum(['legal', 'financial', 'personal']),
      metadata: z.object({
        author: z.string(),
        department: z.string(),
        confidential: z.boolean().default(false),
      }),
    }),
    files: z.object({
      document: file({
        maxSize: '10MB',
        accept: ['application/pdf', 'application/msword'],
      }),
      attachments: file({ maxSize: '5MB' }).array().optional(),
    }),
  },
  handler: async ({ ctx }) => {
    const { title, category, metadata } = ctx.request.body;
    const { document, attachments } = ctx.request.files;

    // Upload main document
    const documentUrl = await ctx.services.storage.upload(document);

    // Upload attachments if present
    const attachmentUrls = attachments
      ? await Promise.all(attachments.map(a => ctx.services.storage.upload(a)))
      : [];

    return {
      documentId: generateId(),
      documentUrl,
      attachmentCount: attachmentUrls.length,
    };
  },
});
```

### Pattern: Multi-file upload

Accept multiple files in a single upload:

```typescript
export const uploadGallery = route.post({
  schema: {
    body: z.object({
      albumTitle: z.string(),
      albumDescription: z.string().optional(),
    }),
    files: z.object({
      photos: file({
        maxSize: '10MB',
        accept: ['image/jpeg', 'image/png'],
      })
        .array()
        .min(1)
        .max(20),
    }),
  },
  handler: async ({ ctx }) => {
    const { albumTitle, albumDescription } = ctx.request.body;
    const { photos } = ctx.request.files;

    // Upload all photos concurrently
    const uploadedPhotos = await Promise.all(
      photos.map(async photo => {
        const url = await ctx.services.storage.upload(photo);
        return {
          url,
          filename: photo.originalname,
          size: photo.size,
        };
      })
    );

    return {
      albumTitle,
      photoCount: photos.length,
      photos: uploadedPhotos,
    };
  },
});
```

### Pattern: Conditional file upload

Make files optional based on request context:

```typescript
export const updateProfile = route.patch({
  schema: {
    params: z.object({ userId: z.string().uuid() }),
    body: z.object({
      name: z.string().optional(),
      bio: z.string().optional(),
      location: z.string().optional(),
    }),
    files: z.object({
      avatar: file({ maxSize: '5MB', accept: ['image/*'] }).optional(),
      coverPhoto: file({ maxSize: '10MB', accept: ['image/*'] }).optional(),
    }),
  },
  handler: async ({ ctx, params }) => {
    const updates: any = { ...ctx.request.body };

    // Only process files if provided
    if (ctx.request.files.avatar) {
      updates.avatarUrl = await uploadFile(ctx.request.files.avatar);
    }

    if (ctx.request.files.coverPhoto) {
      updates.coverPhotoUrl = await uploadFile(ctx.request.files.coverPhoto);
    }

    await db.users.update(params.userId, updates);
    return { success: true };
  },
});
```

---

## Low-level route creators

For advanced use cases, you can use individual route creators instead of the factory:

```typescript
import { createGetRoute, createPostRoute } from 'blaizejs';

// Without factory â€” no inherited types
export const getHealth = createGetRoute()({
  handler: async () => ({ status: 'ok' }),
});

// With explicit types
export const getUser = createGetRoute<MyState, MyServices>()({
  handler: async ({ ctx, params }) => {
    ctx.state.user; // Typed as MyState['user']
    ctx.services.db; // Typed as MyServices['db']
  },
});
```

**Prefer the route factory** â€” it's simpler and automatically inherits types.

---

## Configuration

```typescript
const server = Blaize.createServer({
  // Where to find route files
  routesDir: './src/routes',
});
```

The router scans `.ts` files recursively from `routesDir`. Currently, only TypeScript files are supported.

---

## Key takeaways

1. **File paths = URL paths** â€” No configuration needed
2. **`[param]` = dynamic segments** â€” Works in both files and folders
3. **Export names = client method names** â€” Choose meaningful names
4. **Route factory inherits types** â€” Context is fully typed in handlers
5. **Handler uses destructuring** â€” `({ ctx, params, logger, eventBus })`
6. **SSE handlers include `stream`** â€” `({ stream, ctx, params, logger, eventBus })`
7. **Static beats dynamic** â€” Exact matches take priority
8. **One file, multiple routes** â€” Export different HTTP methods
9. **Files schema for uploads** â€” Type-safe file handling with validation
10. **Automatic multipart detection** â€” Client handles encoding automatically

---

## Related pages

- **[Type System](/docs/architecture/type-system)** â€” How route types flow to client
- **[Context](/docs/architecture/context)** â€” What's available in handlers
- **[Middleware](/docs/architecture/middleware)** â€” Route-level middleware
- **[SSE](/docs/architecture/sse)** â€” Real-time streaming routes
- **[File Uploads](/docs/guides/file-uploads)** â€” Complete file upload guide with examples
