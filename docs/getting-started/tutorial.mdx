# ğŸ“š Tutorial: Build a task API

> **Time:** 30 minutes | **Goal:** Build a task management API with authentication, validation, and testing

In this tutorial, you'll extend the BlaizeJS starter project to build a complete task management API:

- Authentication middleware with typed state
- CRUD routes with full validation
- Dynamic routes with URL parameters
- Testing your implementation
- Type-safe client integration

---

## What you'll build

You'll add task management to your existing API:

| Method   | Path                   | Description                          |
| -------- | ---------------------- | ------------------------------------ |
| `POST`   | `/auth/login`          | Get an auth token                    |
| `GET`    | `/tasks`               | List all tasks (global view)         |
| `POST`   | `/tasks`               | Create a task for authenticated user |
| `GET`    | `/tasks/:taskId`       | Get a single task by ID              |
| `PUT`    | `/tasks/:taskId`       | Update a task                        |
| `DELETE` | `/tasks/:taskId`       | Delete a task                        |
| `GET`    | `/users/:userId/tasks` | Get all tasks for a specific user    |

**Data model:** Tasks belong to users. Each task has a `userId` field.

---

## Prerequisites

Create a new BlaizeJS project:

```bash
npx create-blaize-app task-api
cd task-api
npm run dev
```

You should see the server start at `https://localhost:7485` with several example routes already working.

---

## Part 1: Project setup

### 1.1 Explore the existing structure

The `create-blaize-app` template gives you:

```
src/
â”œâ”€â”€ app.ts              # Server setup
â”œâ”€â”€ app-router.ts       # Type-safe route factory
â”œâ”€â”€ app-type.ts         # Route registry for client
â”œâ”€â”€ events.ts           # Event schemas
â””â”€â”€ routes/
    â”œâ”€â”€ index.ts        # GET / (working)
    â”œâ”€â”€ health.ts       # GET /health (working)
    â”œâ”€â”€ upload.ts       # POST /upload (working)
    â”œâ”€â”€ users/          # User routes (demo)
    â””â”€â”€ events/         # SSE streaming (demo)
```

Test the existing routes:

```bash
# Welcome message
curl -k https://localhost:7485/

# Health check
curl -k https://localhost:7485/health

# List demo users
curl -k https://localhost:7485/users
```

### 1.2 Add new directories

We'll add tasks and auth alongside the existing examples:

```bash
mkdir -p src/routes/auth src/routes/tasks src/middleware src/lib
```

Final structure:

```
src/
â”œâ”€â”€ app.ts
â”œâ”€â”€ app-router.ts
â”œâ”€â”€ app-type.ts
â”œâ”€â”€ events.ts
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ auth.ts             # â† NEW
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â””â”€â”€ login.ts        # â† NEW
â”‚   â”œâ”€â”€ tasks/
â”‚   â”‚   â”œâ”€â”€ index.ts        # â† NEW (GET, POST /tasks)
â”‚   â”‚   â””â”€â”€ [taskId].ts     # â† NEW (file-based dynamic route)
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ index.ts        # âœ… Existing (demo)
â”‚   â”‚   â”œâ”€â”€ [userId]/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts    # âœ… Existing (demo)
â”‚   â”‚   â”‚   â””â”€â”€ tasks.ts    # â† NEW (GET /users/:userId/tasks)
â”‚   â”œâ”€â”€ index.ts            # âœ… Existing
â”‚   â”œâ”€â”€ health.ts           # âœ… Existing
â”‚   â”œâ”€â”€ upload.ts           # âœ… Existing (demo)
â”‚   â””â”€â”€ events/             # âœ… Existing (demo)
â””â”€â”€ lib/
    â”œâ”€â”€ db.ts               # â† NEW (mock database)
    â””â”€â”€ schemas.ts          # â† NEW (shared schemas)
```

**Note on dynamic routes:**

- `routes/tasks/[taskId].ts` - âœ… File-based (we'll use this)
- `routes/users/[userId]/tasks.ts` - âœ… Folder-based (we'll use this too)

Both patterns work! Use files for simple routes, folders when you have multiple routes under the same param.

---

## Part 2: Create shared schemas

### 2.1 Define task and user types

Create `src/lib/schemas.ts`:

```typescript
import { z } from 'zod';

// User schema
export const userSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
});

export type User = z.infer<typeof userSchema>;

// Task schemas
export const taskStatusSchema = z.enum(['todo', 'in-progress', 'done']);

export const taskSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string().nullable(),
  status: taskStatusSchema,
  userId: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export type Task = z.infer<typeof taskSchema>;

export const createTaskSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200),
  description: z.string().max(2000).nullable().optional(),
  status: taskStatusSchema.optional().default('todo'),
});

export const updateTaskSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  description: z.string().max(2000).nullable().optional(),
  status: taskStatusSchema.optional(),
});

export const taskFiltersSchema = z.object({
  status: taskStatusSchema.optional(),
  search: z.string().optional(),
  limit: z.coerce.number().int().min(1).max(100).optional().default(20),
  offset: z.coerce.number().int().min(0).optional().default(0),
});
```

**Key concepts:**

- `z.infer<typeof schema>` creates TypeScript types from Zod schemas
- `z.coerce.number()` converts string `"10"` to number `10`
- `.optional().default(value)` provides defaults for optional fields

---

## Part 3: Create a mock database

### 3.1 Build the database layer

Create `src/lib/db.ts`:

```typescript
import type { User, Task } from './schemas';

// Mock users (in real app, use PostgreSQL/MongoDB)
const users: Map<string, User & { password: string }> = new Map([
  [
    'user-1',
    {
      id: 'user-1',
      email: 'alice@example.com',
      name: 'Alice',
      password: 'password123', // âš ï¸ In real app, hash passwords!
    },
  ],
  [
    'user-2',
    {
      id: 'user-2',
      email: 'bob@example.com',
      name: 'Bob',
      password: 'password456',
    },
  ],
]);

// Mock tasks
const tasks: Map<string, Task> = new Map([
  [
    'task-1',
    {
      id: 'task-1',
      title: 'Learn BlaizeJS',
      description: 'Complete the tutorial',
      status: 'in-progress',
      userId: 'user-1',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
  ],
]);

// Mock token storage (in real app, use JWT)
const tokens: Map<string, string> = new Map(); // token -> userId

export const db = {
  users: {
    findByEmail: (email: string) => {
      for (const user of users.values()) {
        if (user.email === email) return user;
      }
      return null;
    },

    findById: (id: string) => {
      const user = users.get(id);
      if (!user) return null;
      // Remove password before returning
      const { password: _, ...userWithoutPassword } = user;
      return userWithoutPassword;
    },

    validatePassword: (email: string, password: string) => {
      const user = db.users.findByEmail(email);
      return user?.password === password ? user : null;
    },
  },

  tokens: {
    create: (userId: string) => {
      const token = `tok_${crypto.randomUUID()}`;
      tokens.set(token, userId);
      return token;
    },

    validate: (token: string) => {
      const userId = tokens.get(token);
      if (!userId) return null;
      return db.users.findById(userId);
    },
  },

  tasks: {
    findAll: (filters?: {
      userId?: string; // Optional - filter by user
      status?: string;
      search?: string;
      limit?: number;
      offset?: number;
    }) => {
      let result = Array.from(tasks.values());

      // Apply user filter if provided
      if (filters?.userId) {
        result = result.filter(t => t.userId === filters.userId);
      }

      // Apply status filter
      if (filters?.status) {
        result = result.filter(t => t.status === filters.status);
      }

      // Apply search filter
      if (filters?.search) {
        const search = filters.search.toLowerCase();
        result = result.filter(
          t =>
            t.title.toLowerCase().includes(search) || t.description?.toLowerCase().includes(search)
        );
      }

      const total = result.length;
      const offset = filters?.offset ?? 0;
      const limit = filters?.limit ?? 20;

      return {
        tasks: result.slice(offset, offset + limit),
        total,
        limit,
        offset,
      };
    },

    findById: (id: string, userId: string) => {
      const task = tasks.get(id);
      if (!task || task.userId !== userId) return null;
      return task;
    },

    create: (
      data: {
        title: string;
        description?: string | null;
        status?: string;
      },
      userId: string
    ): Task => {
      const task: Task = {
        id: `task-${crypto.randomUUID()}`,
        title: data.title,
        description: data.description ?? null,
        status: (data.status as Task['status']) ?? 'todo',
        userId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };
      tasks.set(task.id, task);
      return task;
    },

    update: (id: string, data: Partial<Task>, userId: string): Task | null => {
      const task = tasks.get(id);
      if (!task || task.userId !== userId) return null;

      const updated: Task = {
        ...task,
        ...data,
        id: task.id, // Prevent override
        userId: task.userId, // Prevent override
        updatedAt: new Date().toISOString(),
      };
      tasks.set(id, updated);
      return updated;
    },

    delete: (id: string, userId: string): boolean => {
      const task = tasks.get(id);
      if (!task || task.userId !== userId) return false;
      tasks.delete(id);
      return true;
    },
  },
};
```

---

## Part 4: Authentication

### 4.1 Create the login route

Create `src/routes/auth/login.ts`:

```typescript
import { route } from '../../app-router';
import { UnauthorizedError } from 'blaizejs';
import { z } from 'zod';
import { db } from '../../lib/db';

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

export const postLogin = route.post({
  schema: {
    body: loginSchema,
    response: z.object({
      token: z.string(),
      user: z.object({
        id: z.string(),
        email: z.string(),
        name: z.string(),
      }),
    }),
  },
  handler: async ({ ctx }) => {
    const { email, password } = ctx.request.body;

    // Validate credentials
    const user = db.users.validatePassword(email, password);

    if (!user) {
      throw new UnauthorizedError('Invalid email or password');
    }

    // Create token
    const token = db.tokens.create(user.id);

    // Return token and user (without password)
    const { password: _, ...userWithoutPassword } = user;

    return {
      token,
      user: userWithoutPassword,
    };
  },
});
```

**Key concepts:**

- Handler uses destructuring: `({ ctx, params, logger, eventBus })`
- `ctx.request.body` is typed from `schema.body`
- `UnauthorizedError` automatically formats to HTTP 401

### 4.2 Test the login route

```bash
curl -k -X POST https://localhost:7485/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "alice@example.com", "password": "password123"}'
```

Response:

```json
{
  "token": "tok_550e8400-e29b-41d4-a716-446655440000",
  "user": {
    "id": "user-1",
    "email": "alice@example.com",
    "name": "Alice"
  }
}
```

**Save this token!** You'll need it for the next steps.

### 4.3 Create the auth middleware

Create `src/middleware/auth.ts`:

```typescript
import { createMiddleware, UnauthorizedError } from 'blaizejs';
import { db } from '../lib/db';
import type { User } from '../lib/schemas';

export const authMiddleware = createMiddleware<
  { user: User }, // Adds user to ctx.state
  {} // No services added
>({
  name: 'auth',

  handler: async ({ ctx, next }) => {
    // Extract token from Authorization header
    const authHeader = ctx.request.header('authorization');

    if (!authHeader?.startsWith('Bearer ')) {
      throw new UnauthorizedError('Missing or invalid Authorization header', {
        suggestion: 'Include header: Authorization: Bearer <token>',
      });
    }

    const token = authHeader.slice(7); // Remove 'Bearer '

    // Validate token and get user
    const user = db.tokens.validate(token);

    if (!user) {
      throw new UnauthorizedError('Invalid or expired token', {
        suggestion: 'Login again to get a new token',
      });
    }

    // Add user to state â€” now available in all routes!
    ctx.state.user = user;

    await next();
  },

  // Skip auth for public routes
  skip: ({ ctx }) => {
    const publicPaths = ['/health', '/auth/login', '/'];
    return publicPaths.some(path => ctx.request.path.startsWith(path));
  },
});
```

**Key concepts:**

- Middleware handler receives `{ ctx, next, logger, eventBus }`
- Type parameters: `<TState, TServices>` define what middleware adds
- `skip` function determines when to bypass middleware
- `ctx.state.user` becomes available in all protected routes

### 4.4 Register the middleware

Update `src/app.ts` to use the auth middleware:

```typescript
import { Blaize } from 'blaizejs';
import { fileURLToPath } from 'node:url';
import path from 'node:path';
import { minimalEvents } from './events';
import { authMiddleware } from './middleware/auth'; // â† ADD THIS

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const routesDir = path.resolve(__dirname, './routes');

const server = Blaize.createServer({
  host: 'localhost',
  port: process.env.PORT ? parseInt(process.env.PORT) : 7485,
  routesDir,
  http2: { enabled: true },
  eventSchemas: minimalEvents,
}).use(authMiddleware); // â† ADD THIS LINE

// Rest of app.ts stays the same...
```

Now all routes (except public ones) require authentication!

---

## Part 5: Task CRUD routes

### 5.1 List and create tasks

Create `src/routes/tasks/index.ts`:

```typescript
import { route } from '../../app-router';
import { z } from 'zod';
import { db } from '../../lib/db';
import { taskSchema, createTaskSchema, taskFiltersSchema } from '../../lib/schemas';

// GET /tasks â€” List all tasks (global view, can filter by userId)
export const getTasks = route.get({
  schema: {
    query: taskFiltersSchema.extend({
      userId: z.string().optional(), // Filter by user
    }),
    response: z.object({
      tasks: z.array(taskSchema),
      total: z.number(),
      limit: z.number(),
      offset: z.number(),
    }),
  },
  handler: async ({ ctx, logger }) => {
    const filters = ctx.request.query;

    logger.info('Fetching tasks', { filters });

    // Global view - returns all tasks (or filtered by userId)
    return db.tasks.findAll(filters);
  },
});

// POST /tasks â€” Create a new task
export const createTask = route.post({
  schema: {
    body: createTaskSchema,
    response: taskSchema,
  },
  handler: async ({ ctx, logger, eventBus }) => {
    const userId = ctx.state.user.id;
    const data = ctx.request.body;

    const task = db.tasks.create(data, userId);

    logger.info('Task created', { taskId: task.id, userId });

    // Publish event for real-time updates
    await eventBus.publish('demo:event', {
      message: `Task created: ${task.title}`,
      data: { taskId: task.id },
    });

    // Set 201 Created status
    ctx.response.status(201);

    return task;
  },
});
```

**Key concepts:**

- `ctx.state.user` is available because of auth middleware
- TypeScript knows `user` exists and what type it is
- `logger` and `eventBus` come from handler context
- `ctx.response.status()` sets HTTP status codes

### 5.2 Single task operations (dynamic routes)

Create `src/routes/tasks/[taskId].ts`:

```typescript
import { route } from '../../app-router';
import { NotFoundError } from 'blaizejs';
import { z } from 'zod';
import { db } from '../../lib/db';
import { taskSchema, updateTaskSchema } from '../../lib/schemas';

const paramsSchema = z.object({
  taskId: z.string(),
});

// GET /tasks/:taskId
export const getTask = route.get({
  schema: {
    params: paramsSchema,
    response: taskSchema,
  },
  handler: async ({ ctx, params, logger }) => {
    logger.info('Fetching task', { taskId: params.taskId });

    const task = db.tasks.findById(params.taskId, ctx.state.user.id);

    if (!task) {
      throw new NotFoundError('Task not found', {
        resourceType: 'task',
        resourceId: params.taskId,
      });
    }

    return task;
  },
});

// PUT /tasks/:taskId
export const updateTask = route.put({
  schema: {
    params: paramsSchema,
    body: updateTaskSchema,
    response: taskSchema,
  },
  handler: async ({ ctx, params, logger }) => {
    const userId = ctx.state.user.id;
    const data = ctx.request.body;

    const updated = db.tasks.update(params.taskId, data, userId);

    if (!updated) {
      throw new NotFoundError('Task not found', {
        resourceType: 'task',
        resourceId: params.taskId,
      });
    }

    logger.info('Task updated', { taskId: params.taskId });

    return updated;
  },
});

// DELETE /tasks/:taskId
export const deleteTask = route.delete({
  schema: {
    params: paramsSchema,
    response: z.object({
      success: z.boolean(),
      message: z.string(),
    }),
  },
  handler: async ({ ctx, params, logger }) => {
    const userId = ctx.state.user.id;

    const deleted = db.tasks.delete(params.taskId, userId);

    if (!deleted) {
      throw new NotFoundError('Task not found', {
        resourceType: 'task',
        resourceId: params.taskId,
      });
    }

    logger.info('Task deleted', { taskId: params.taskId });

    return {
      success: true,
      message: `Task ${params.taskId} deleted`,
    };
  },
});
```

**Key concepts:**

- `[taskId]` in filename becomes route parameter
- `params` is validated by `schema.params`
- Same `ctx.state.user` available in all protected routes
- Named exports (`getTasks`, not `GET`) for better client integration

### 5.3 Test the task API

Set your token from the login response:

```bash
export TOKEN="tok_your-token-here"
```

**Create a task:**

```bash
curl -k -X POST https://localhost:7485/tasks \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"title": "Buy groceries", "description": "Milk, eggs, bread"}'
```

**List tasks:**

```bash
curl -k https://localhost:7485/tasks \
  -H "Authorization: Bearer $TOKEN"
```

**Filter by status:**

```bash
curl -k "https://localhost:7485/tasks?status=todo" \
  -H "Authorization: Bearer $TOKEN"
```

**Get a task:**

```bash
curl -k https://localhost:7485/tasks/task-1 \
  -H "Authorization: Bearer $TOKEN"
```

**Update a task:**

```bash
curl -k -X PUT https://localhost:7485/tasks/task-1 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"status": "done"}'
```

**Delete a task:**

```bash
curl -k -X DELETE https://localhost:7485/tasks/task-1 \
  -H "Authorization: Bearer $TOKEN"
```

---

## Part 6: Nested user tasks route

### 6.1 Get tasks for a specific user

This demonstrates the folder-based dynamic route pattern. Create `src/routes/users/[userId]/tasks.ts`:

```typescript
import { route } from '../../../app-router';
import { z } from 'zod';
import { db } from '../../../lib/db';
import { taskSchema, taskFiltersSchema } from '../../../lib/schemas';

// GET /users/:userId/tasks
export const getUserTasks = route.get({
  schema: {
    params: z.object({
      userId: z.string(),
    }),
    query: taskFiltersSchema,
    response: z.object({
      userId: z.string(),
      tasks: z.array(taskSchema),
      total: z.number(),
      limit: z.number(),
      offset: z.number(),
    }),
  },
  handler: async ({ ctx, params, logger }) => {
    const { userId } = params;

    logger.info('Fetching tasks for user', { userId });

    // Fetch all tasks for this specific user
    const result = db.tasks.findAll({
      userId,
      ...ctx.request.query,
    });

    return {
      userId,
      ...result,
    };
  },
});
```

**Key concepts:**

- File location: `users/[userId]/tasks.ts`
- URL path: `/users/:userId/tasks`
- Shows folder-based dynamic route pattern
- `params.userId` comes from the URL segment

### 6.2 Test the nested route

```bash
# Get all tasks for user-1
curl -k https://localhost:7485/users/user-1/tasks \
  -H "Authorization: Bearer $TOKEN"

# Filter by status for a specific user
curl -k "https://localhost:7485/users/user-1/tasks?status=todo" \
  -H "Authorization: Bearer $TOKEN"
```

**Comparison of the two approaches:**

| Route                  | File Pattern              | Use When                           |
| ---------------------- | ------------------------- | ---------------------------------- |
| `/tasks/:taskId`       | `tasks/[taskId].ts`       | Single endpoint at that param      |
| `/users/:userId/tasks` | `users/[userId]/tasks.ts` | Multiple endpoints share the param |

Both work! The template uses `users/[userId]/index.ts` (folder pattern) because it might add more user routes later.

---

## Part 7: Testing

### 6.1 Test the task routes

Create `src/__tests__/routes/tasks.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { createTestContext, createRouteTestContext } from '@blaizejs/testing-utils';
import { getTasks, createTask } from '../../routes/tasks/index';

describe('GET /tasks', () => {
  it('returns tasks for authenticated user', async () => {
    const { logger, eventBus, cleanup } = createRouteTestContext();

    const ctx = createTestContext({
      method: 'GET',
      query: {},
      state: {
        user: { id: 'user-1', email: 'alice@example.com', name: 'Alice' },
      },
    });

    const result = await getTasks.handler({ ctx, params: {}, logger, eventBus });

    expect(result).toHaveProperty('tasks');
    expect(result).toHaveProperty('total');
    expect(Array.isArray(result.tasks)).toBe(true);

    cleanup();
  });

  it('filters tasks by status', async () => {
    const { logger, eventBus, cleanup } = createRouteTestContext();

    const ctx = createTestContext({
      method: 'GET',
      query: { status: 'todo' },
      state: {
        user: { id: 'user-1', email: 'alice@example.com', name: 'Alice' },
      },
    });

    const result = await getTasks.handler({ ctx, params: {}, logger, eventBus });

    // All returned tasks should have 'todo' status
    result.tasks.forEach(task => {
      expect(task.status).toBe('todo');
    });

    cleanup();
  });
});

describe('POST /tasks', () => {
  it('creates a new task', async () => {
    const { logger, eventBus, cleanup } = createRouteTestContext();

    const ctx = createTestContext({
      method: 'POST',
      body: {
        title: 'Test task',
        description: 'Test description',
      },
      state: {
        user: { id: 'user-1', email: 'alice@example.com', name: 'Alice' },
      },
    });

    const result = await createTask.handler({ ctx, params: {}, logger, eventBus });

    expect(result.title).toBe('Test task');
    expect(result.description).toBe('Test description');
    expect(result.status).toBe('todo'); // Default status
    expect(result.userId).toBe('user-1');
    expect(result.id).toBeDefined();

    cleanup();
  });
});
```

### 7.2 Test the auth middleware

Create `src/__tests__/middleware/auth.test.ts`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { createTestContext } from '@blaizejs/testing-utils';
import { authMiddleware } from '../../middleware/auth';

describe('authMiddleware', () => {
  it('throws UnauthorizedError when no token provided', async () => {
    const ctx = createTestContext({
      headers: {},
    });
    const next = vi.fn();

    await expect(
      authMiddleware.handler({ ctx, next, logger: ctx.logger, eventBus: ctx.eventBus })
    ).rejects.toThrow('Missing or invalid Authorization header');

    expect(next).not.toHaveBeenCalled();
  });

  it('throws UnauthorizedError for invalid token format', async () => {
    const ctx = createTestContext({
      headers: {
        authorization: 'InvalidFormat token123',
      },
    });
    const next = vi.fn();

    await expect(
      authMiddleware.handler({ ctx, next, logger: ctx.logger, eventBus: ctx.eventBus })
    ).rejects.toThrow('Missing or invalid Authorization header');

    expect(next).not.toHaveBeenCalled();
  });

  it('skips auth for public paths', () => {
    const ctx = createTestContext({
      path: '/auth/login',
    });

    const shouldSkip = authMiddleware.skip?.({ ctx });

    expect(shouldSkip).toBe(true);
  });

  it('does not skip auth for protected paths', () => {
    const ctx = createTestContext({
      path: '/tasks',
    });

    const shouldSkip = authMiddleware.skip?.({ ctx });

    expect(shouldSkip).toBe(false);
  });
});
```

### 7.3 Run the tests

```bash
npm test
```

You should see all tests passing!

---

## Part 8: Type-safe client

### 8.1 Export routes for the client

Update `src/app-type.ts` to include the new routes:

```typescript
// Existing routes
import { getRoot } from './routes/index';
import { getHealth } from './routes/health';
import { getUsers } from './routes/users/index';
import { getUserById } from './routes/users/[userId]/index';
import { postUpload } from './routes/upload';
import { getEventsStream } from './routes/events/stream';

// New routes
import { postLogin } from './routes/auth/login';
import { getTasks, createTask } from './routes/tasks/index';
import { getTask, updateTask, deleteTask } from './routes/tasks/[taskId]';
import { getUserTasks } from './routes/users/[userId]/tasks';

export const routes = {
  // Existing
  getRoot,
  getHealth,
  getUsers,
  getUserById,
  postUpload,
  getEventsStream,

  // New
  postLogin,
  getTasks,
  createTask,
  getTask,
  updateTask,
  deleteTask,
  getUserTasks, // Nested route
} as const;
```

### 8.2 Use the type-safe client

In a client application:

```typescript
import bc from '@blaizejs/client';
import { routes } from './server/app-type';

const client = bc.create('https://localhost:7485', routes);

// Login
const { token, user } = await client.$post.postLogin({
  body: { email: 'alice@example.com', password: 'password123' },
});

// Create authenticated client
const authClient = bc.create('https://localhost:7485', routes, {
  defaultHeaders: {
    Authorization: `Bearer ${token}`,
  },
});

// All calls include auth header automatically
const { tasks } = await authClient.$get.getTasks({
  query: { status: 'todo' },
});

// Get tasks for a specific user (nested route)
const userTasks = await authClient.$get.getUserTasks({
  params: { userId: 'user-1' },
  query: { status: 'in-progress' },
});

const newTask = await authClient.$post.createTask({
  body: { title: 'New task from client' },
});

// Full autocomplete on all responses!
console.log(newTask.id); // string
console.log(newTask.status); // 'todo' | 'in-progress' | 'done'
console.log(newTask.userId); // string - task belongs to a user
```

---

## âœ… What you've learned

In this tutorial, you:

| Concept               | What You Did                                                 |
| --------------------- | ------------------------------------------------------------ |
| **Project Structure** | Built on create-blaize-app foundation                        |
| **Data Modeling**     | Created tasks that belong to users                           |
| **Auth Middleware**   | Created middleware that adds typed state                     |
| **CRUD Routes**       | Implemented GET, POST, PUT, DELETE with validation           |
| **Dynamic Routes**    | Used `[param]` in both file and folder patterns              |
| **Nested Routes**     | Created `/users/:userId/tasks` for user-scoped data          |
| **Handler Signature** | Used destructuring: `({ ctx, params, logger, eventBus })`    |
| **Error Handling**    | Threw semantic errors (`NotFoundError`, `UnauthorizedError`) |
| **Testing**           | Tested routes with `createTestContext`                       |
| **Type-Safe Client**  | Exported routes for end-to-end type safety                   |
| **EventBus**          | Published events for real-time coordination                  |

---

## ğŸ¯ Next steps

Now that you've built a complete API, explore more advanced features:

- **[Middleware guide](../guides/middleware)** â€” Advanced middleware patterns
- **[SSE guide](../guides/sse)** â€” Add real-time updates to tasks
- **[Plugin guide](../guides/plugins)** â€” Add database, caching, queue
- **[Database integration](../guides/database-integration)** â€” Replace mock DB with real database
- **[Error handling](../guides/error-handling)** â€” All 12 error classes explained

---

## ğŸ“‚ Complete code reference

Final project structure:

```
src/
â”œâ”€â”€ app.ts                  # Server with auth middleware
â”œâ”€â”€ app-router.ts           # Route factory
â”œâ”€â”€ app-type.ts             # Route registry (updated)
â”œâ”€â”€ events.ts               # Event schemas
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ auth.ts             # âœ… Authentication middleware
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â””â”€â”€ login.ts        # âœ… POST /auth/login
â”‚   â”œâ”€â”€ tasks/
â”‚   â”‚   â”œâ”€â”€ index.ts        # âœ… GET, POST /tasks
â”‚   â”‚   â””â”€â”€ [taskId].ts     # âœ… GET, PUT, DELETE (file-based dynamic)
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ index.ts        # âœ“ Existing (demo)
â”‚   â”‚   â””â”€â”€ [userId]/
â”‚   â”‚       â”œâ”€â”€ index.ts    # âœ“ Existing (demo)
â”‚   â”‚       â””â”€â”€ tasks.ts    # âœ… GET /users/:userId/tasks (folder-based dynamic)
â”‚   â”œâ”€â”€ index.ts            # âœ“ Existing
â”‚   â”œâ”€â”€ health.ts           # âœ“ Existing
â”‚   â”œâ”€â”€ upload.ts           # âœ“ Existing (demo)
â”‚   â””â”€â”€ events/             # âœ“ Existing (demo)
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ db.ts               # âœ… Mock database
â”‚   â””â”€â”€ schemas.ts          # âœ… Shared Zod schemas
â””â”€â”€ __tests__/
    â”œâ”€â”€ routes/
    â”‚   â””â”€â”€ tasks.test.ts   # âœ… Task route tests
    â””â”€â”€ middleware/
        â””â”€â”€ auth.test.ts    # âœ… Auth middleware tests
```

**Key learnings:**

- **File-based dynamic routes:** `tasks/[taskId].ts` â†’ `/tasks/:taskId`
- **Folder-based dynamic routes:** `users/[userId]/tasks.ts` â†’ `/users/:userId/tasks`
- Both patterns work! Use what makes sense for your structure.

**Congratulations!** You've built a production-style API with BlaizeJS. ğŸ‰
