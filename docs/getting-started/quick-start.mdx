# ðŸš€ Quick start

> **Time:** 10 minutes | **Goal:** Running BlaizeJS server with routes, validation, and type safety

---

## Prerequisites

- **Node.js 23+** â€” [Download](https://nodejs.org/)
- **Package manager** â€” npm, pnpm, yarn, or bun

Verify your Node version:

```bash
node --version
# v23.0.0 or higher
```

---

## 1. Create your project

```bash
npx create-blaize-app my-api
cd my-api
```

You'll see output like:

```
ðŸ”¥ BlaizeJS CLI

âœ“ Created project directory
âœ“ Generated 8 files
âœ“ Initialized git repository
âœ“ Installed dependencies

ðŸŽ‰ Success! Created my-api

Next steps:
  cd my-api
  npm run dev
```

<details>
<summary>Using a different package manager?</summary>

```bash
# pnpm
pnpm create blaize-app my-api

# yarn
yarn create blaize-app my-api

# bun
bun create blaize-app my-api
```

</details>

---

## 2. Start the dev server

```bash
npm run dev
```

You'll see:

```
ðŸš€ Server started successfully

ðŸ“ Available Endpoints:
   GET  https://localhost:7485/
   GET  https://localhost:7485/health
   GET  https://localhost:7485/users
   GET  https://localhost:7485/users/:userId
   POST https://localhost:7485/upload
   GET  https://localhost:7485/events/stream
```

> **Note:** BlaizeJS uses HTTPS by default (HTTP/2). Your browser may warn about the self-signed certificate in development â€” that's expected.

---

## 3. Test your API

Open a new terminal and make a request:

```bash
curl -k https://localhost:7485/health
```

Response:

```json
{
  "status": "ok",
  "timestamp": 1706356800000,
  "uptime": 123.456
}
```

> The `-k` flag tells curl to accept the self-signed certificate.

---

## 4. Explore the project structure

```
my-api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app.ts              # Server setup
â”‚   â”œâ”€â”€ app-router.ts       # Type-safe route factory
â”‚   â”œâ”€â”€ app-type.ts         # Route registry for client
â”‚   â”œâ”€â”€ events.ts           # Event schemas
â”‚   â””â”€â”€ routes/
â”‚       â”œâ”€â”€ index.ts        # GET /
â”‚       â”œâ”€â”€ health.ts       # GET /health
â”‚       â”œâ”€â”€ upload.ts       # POST /upload
â”‚       â”œâ”€â”€ users/
â”‚       â”‚   â”œâ”€â”€ index.ts    # GET /users
â”‚       â”‚   â””â”€â”€ [userId]/
â”‚       â”‚       â””â”€â”€ index.ts # GET /users/:userId
â”‚       â””â”€â”€ events/
â”‚           â””â”€â”€ stream.ts   # GET /events/stream (SSE)
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

Open `src/app.ts` to see the server setup:

```typescript
import { Blaize } from 'blaizejs';
import { fileURLToPath } from 'node:url';
import path from 'node:path';
import { minimalEvents } from './events';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const routesDir = path.resolve(__dirname, './routes');

const server = Blaize.createServer({
  host: 'localhost',
  port: 7485,
  routesDir,
  http2: { enabled: true },
  eventSchemas: minimalEvents,
});

await server.listen();
```

Open `src/app-router.ts` to see the route factory:

```typescript
import { Blaize, type InferContext } from 'blaizejs';
import type { minimalEvents } from './events';

// Type-only server for type inference
const typeServer = Blaize.createServer({
  host: 'localhost',
  port: 7485,
  routesDir: './src/routes',
  eventSchemas: {} as typeof minimalEvents,
});

type AppContext = InferContext<typeof typeServer>;

export const route = Blaize.Router.createRouteFactory<
  AppContext['state'],
  AppContext['services']
>();
```

**Why separate `app-router.ts`?**
- Cleaner imports in route files
- Type inference happens once, reused everywhere
- No server lifecycle dependency in routes
- Easier testing

Open `src/routes/health.ts` to see a route:

```typescript
import { route } from '../app-router';
import { z } from 'zod';

export const getHealth = route.get({
  schema: {
    response: z.object({
      status: z.literal('ok'),
      timestamp: z.number(),
      uptime: z.number(),
    }),
  },
  handler: async () => ({
    status: 'ok' as const,
    timestamp: Date.now(),
    uptime: process.uptime(),
  }),
});
```

**Key concepts:**
- `route.get()` creates a GET route handler
- `export const getHealth` names the handler (used by type-safe client)
- `schema.response` defines and validates your response shape
- The handler returns data that TypeScript checks against the schema

---

## 5. Add a route with query parameters

Create a new file `src/routes/hello.ts`:

```typescript
import { route } from '../app-router';
import { z } from 'zod';

export const getHello = route.get({
  schema: {
    query: z.object({
      name: z.string().optional(),
      excited: z.coerce.boolean().optional(), // "true" string â†’ true boolean
    }),
    response: z.object({
      message: z.string(),
    }),
  },
  handler: async ({ ctx }) => {
    const { name = 'World', excited = false } = ctx.request.query;
    const punctuation = excited ? '!' : '.';
    return { message: `Hello, ${name}${punctuation}` };
  },
});
```

**Important:** Note the handler signature uses **destructuring**:
```typescript
handler: async ({ ctx, params, logger, eventBus }) => { ... }
```

Test it:

```bash
curl -k "https://localhost:7485/hello"
# {"message":"Hello, World."}

curl -k "https://localhost:7485/hello?name=BlaizeJS"
# {"message":"Hello, BlaizeJS."}

curl -k "https://localhost:7485/hello?name=BlaizeJS&excited=true"
# {"message":"Hello, BlaizeJS!"}
```

**Key concepts:**
- `schema.query` defines and validates query string parameters
- `z.coerce.boolean()` converts string `"true"` to boolean `true`
- `ctx.request.query` is fully typed based on your schema
- Handler receives `{ ctx, params, logger, eventBus }` object (not positional params)

---

## 6. Add a route with request body

Create `src/routes/messages.ts`:

```typescript
import { route } from '../app-router';
import { z } from 'zod';

// Define reusable schemas
const messageSchema = z.object({
  id: z.string(),
  from: z.string().email(),
  to: z.string().email(),
  subject: z.string(),
  body: z.string(),
  sentAt: z.string(),
});

const createMessageSchema = z.object({
  from: z.string().email(),
  to: z.string().email(),
  subject: z.string().min(1).max(200),
  body: z.string().min(1).max(10000),
});

export const createMessage = route.post({
  schema: {
    body: createMessageSchema,
    response: messageSchema,
  },
  handler: async ({ ctx }) => {
    // ctx.request.body is typed as { from, to, subject, body }
    const { from, to, subject, body } = ctx.request.body;
    
    // Create the message (in real app, save to database)
    const message = {
      id: crypto.randomUUID(),
      from,
      to,
      subject,
      body,
      sentAt: new Date().toISOString(),
    };
    
    return message;
  },
});
```

Test it:

```bash
curl -k -X POST https://localhost:7485/messages \
  -H "Content-Type: application/json" \
  -d '{
    "from": "alice@example.com",
    "to": "bob@example.com", 
    "subject": "Hello!",
    "body": "Welcome to BlaizeJS"
  }'
```

Response:

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "from": "alice@example.com",
  "to": "bob@example.com",
  "subject": "Hello!",
  "body": "Welcome to BlaizeJS",
  "sentAt": "2024-01-15T10:30:00.000Z"
}
```

**Validation errors are automatic:**

```bash
curl -k -X POST https://localhost:7485/messages \
  -H "Content-Type: application/json" \
  -d '{"from": "not-an-email", "to": "bob@example.com", "subject": "", "body": "Hi"}'
```

Response (400 Bad Request):

```json
{
  "type": "VALIDATION_ERROR",
  "title": "Validation failed",
  "status": 400,
  "correlationId": "req_abc123",
  "timestamp": "2024-01-15T10:30:00.000Z",
  "details": {
    "errors": [
      { "path": ["from"], "message": "Invalid email" },
      { "path": ["subject"], "message": "String must contain at least 1 character(s)" }
    ]
  }
}
```

**Key concepts:**
- `schema.body` validates the JSON request body
- `ctx.request.body` is fully typed from your schema
- Invalid requests automatically return 400 with detailed errors
- Zod constraints (`.min()`, `.max()`, `.email()`) are enforced

---

## 7. Explore dynamic routes

Look at `src/routes/users/[userId]/index.ts` â€” this is a dynamic route:

```typescript
import { route } from '../../../app-router';
import { NotFoundError } from 'blaizejs';
import { z } from 'zod';

export const getUserById = route.get({
  schema: {
    params: z.object({
      userId: z.string().uuid(),
    }),
    response: z.object({
      id: z.string().uuid(),
      name: z.string(),
      email: z.string().email(),
    }),
  },
  handler: async ({ params, logger, eventBus }) => {
    logger.info('Fetching user', { userId: params.userId });
    
    // params.userId is typed as string
    if (params.userId === '00000000-0000-0000-0000-000000000000') {
      throw new NotFoundError(`User ${params.userId} not found`);
    }
    
    // Publish event
    await eventBus.publish('user:viewed', {
      userId: params.userId,
      timestamp: Date.now(),
    });
    
    return {
      id: params.userId,
      name: 'John Doe',
      email: 'john@example.com',
    };
  },
});
```

Test it:

```bash
curl -k https://localhost:7485/users/550e8400-e29b-41d4-a716-446655440000
# {"id":"550e8400-e29b-41d4-a716-446655440000","name":"John Doe","email":"john@example.com"}

curl -k https://localhost:7485/users/00000000-0000-0000-0000-000000000000
# {"type":"NOT_FOUND","title":"User 00000000-0000-0000-0000-000000000000 not found","status":404,...}
```

**Key concepts:**
- `[userId]` in the directory name becomes a URL parameter
- `schema.params` validates URL parameters
- `params.userId` is fully typed
- `NotFoundError` automatically formats to a proper HTTP 404 response
- `logger` provides request-scoped logging
- `eventBus` enables publishing events for real-time updates

---

## 8. Connect the type-safe client (optional)

The `src/app-type.ts` file exports all routes for the type-safe client:

```typescript
import { getRoot } from './routes/index';
import { getHealth } from './routes/health';
import { getUsers } from './routes/users/index';
import { getUserById } from './routes/users/[userId]/index';
import { createMessage } from './routes/messages';

export const routes = {
  getRoot,
  getHealth,
  getUsers,
  getUserById,
  createMessage,
} as const;
```

Now a client application can call your API:

```typescript
import bc from '@blaizejs/client';
import { routes } from './server/app-type';

const client = bc.create('https://localhost:7485', routes);

// Full autocomplete and type checking!
const user = await client.$get.getUserById({ 
  params: { userId: '550e8400-e29b-41d4-a716-446655440000' } 
});
console.log(user.name); // TypeScript knows this is a string

// POST requests with typed body
const message = await client.$post.createMessage({
  body: {
    from: 'alice@example.com',
    to: 'bob@example.com',
    subject: 'Hello!',
    body: 'Welcome to BlaizeJS',
  },
});
console.log(message.id); // TypeScript knows this is a string
```

---

## âœ… What you've learned

In 10 minutes, you've:
- âœ… Created a new BlaizeJS project
- âœ… Started the development server
- âœ… Explored file-based routing
- âœ… Added routes with **query parameters** (validated and typed)
- âœ… Added routes with **request body validation** (with automatic error responses)
- âœ… Explored **dynamic routes** with URL parameters
- âœ… Used the **new handler signature** with destructuring
- âœ… Used **logger** and **eventBus** in handlers
- âœ… Previewed the type-safe client

---

## ðŸ”— Next steps

- **[Tutorial](./tutorial)** â€” Build a complete API in 30 minutes
- **[File-based routing](../guides/routing)** â€” Deep dive into routing patterns
- **[Middleware](../guides/middleware)** â€” Add authentication, logging, and more
- **[API reference](../api-reference/blaizejs)** â€” Full API documentation

---

## ðŸ“š Available scripts

Your project includes these npm scripts:

| Script | Description |
|--------|-------------|
| `npm run dev` | Start development server with hot reload |
| `npm run build` | Build for production |
| `npm start` | Run production build |
| `npm run type-check` | Check TypeScript types |
| `npm run clean` | Remove build artifacts |
| `npm test` | Run tests |
| `npm run test:watch` | Run tests in watch mode |
| `npm run test:coverage` | Run tests with coverage report |

---

## ðŸ†˜ Troubleshooting

### "Certificate error" in browser

BlaizeJS uses HTTPS by default. In development, it uses a self-signed certificate. You can:
- Click "Advanced" â†’ "Proceed anyway" in your browser
- Use `curl -k` to skip certificate verification
- Use an HTTP client like Postman or Insomnia

### Port already in use

Change the port in `src/app.ts`:

```typescript
const server = Blaize.createServer({
  port: 3000, // Change this
  // ...
});
```

### Route not found

- Check that your file is in the `src/routes/` directory
- Verify the file exports a named function (e.g., `export const getHealth`)
- For POST routes, make sure you're sending `Content-Type: application/json`
- Make sure the dev server is running

### TypeScript errors in handler

Remember the new handler signature uses destructuring:

```typescript
// âŒ Old signature (deprecated)
handler: async (ctx, params, logger) => { ... }

// âœ… New signature (correct)
handler: async ({ ctx, params, logger, eventBus }) => { ... }
```

---

**Ready to build something real? Continue to the [Tutorial](./tutorial) â†’**