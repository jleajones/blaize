# üóÑÔ∏è Database integration

> **Learn how to integrate any database or ORM into your BlaizeJS application using the plugin system**

This guide teaches you the **pattern** for integrating databases ‚Äî not a specific implementation. You'll get full control, perfect type safety, and lifecycle management while keeping the flexibility to use your preferred tools.

---

## üéØ Philosophy: Teaching patterns, not abstractions

BlaizeJS intentionally does not provide a database plugin because:

1. **Existing ORMs are excellent** ‚Äî Drizzle, Prisma, and TypeORM are battle-tested with great TypeScript support
2. **You know your needs best** ‚Äî Your database setup, migrations, and query patterns are unique to your app
3. **Teaching > Abstracting** ‚Äî Understanding how to inject services gives you the power to integrate _anything_
4. **Type safety** ‚Äî Using your ORM directly preserves all its TypeScript types

**The same pattern you learn here works for:**

- Redis and caching systems
- Message queues (RabbitMQ, Kafka)
- Search engines (Elasticsearch, MeiliSearch)
- Any external service

---

## üìö What you'll learn

- ‚úÖ Create a database plugin with lifecycle management
- ‚úÖ Inject your database into `ctx.services` with full type safety
- ‚úÖ Handle connections, disconnections, and errors gracefully
- ‚úÖ Publish events for real-time updates
- ‚úÖ Coordinate across multiple servers
- ‚úÖ Integrate transactions and complex queries

---

## üìã Prerequisites

- Complete the [Quick Start Guide](../quick-start)
- Familiarity with TypeScript
- Understanding of SQL/databases
- Your preferred ORM installed

---

## üöÄ Quick start

**Jump to your ORM:**

| ORM         | Best For                              | Jump To                                       |
| ----------- | ------------------------------------- | --------------------------------------------- |
| **Drizzle** | Type-safety, lightweight, functional  | [Drizzle Integration ‚Üí](#drizzle-integration) |
| **Prisma**  | Auto-generated client, great DX       | [Prisma Integration ‚Üí](#prisma-integration)   |
| **TypeORM** | Mature, decorator-based, feature-rich | [TypeORM Integration ‚Üí](#typeorm-integration) |

---

## üß† Understanding the plugin system

### Plugins vs middleware

Before diving into code, understand when to use each:

| Concept        | When to Use              | Example                                  |
| -------------- | ------------------------ | ---------------------------------------- |
| **Middleware** | Per-request logic        | Authentication, logging, request parsing |
| **Plugins**    | Once at startup/shutdown | Database connections, background workers |

```typescript
// ‚ùå WRONG: Creating a database connection on every request
const dbMiddleware = createMiddleware({
  handler: async (ctx, next) => {
    ctx.services.db = await Database.connect(); // Expensive!
    await next();
    await ctx.services.db.close(); // Wasteful!
  },
});

// ‚úÖ CORRECT: Plugin connects once, middleware provides access
const databasePlugin = createPlugin<
  { connectionString: string }, // Config
  {}, // State (none needed)
  { db: Database } // Services to inject
>({
  name: 'database',
  version: '1.0.0',

  setup: ({ config, logger }) => {
    let db: Database; // Singleton in closure

    return {
      // Connect ONCE at startup
      initialize: async () => {
        db = await Database.connect(config.connectionString);
      },

      // Register middleware to provide access
      register: async server => {
        server.use(
          createMiddleware<{}, { db: Database }>({
            name: 'database',
            handler: async (ctx, next) => {
              ctx.services.db = db; // Just a reference!
              await next();
            },
          })
        );
      },

      // Clean up ONCE at shutdown
      terminate: async () => {
        await db.close();
      },
    };
  },
});
```

### Plugin lifecycle hooks

Plugins implement up to five lifecycle hooks:

| Hook            | When It Runs                     | Use For                                |
| --------------- | -------------------------------- | -------------------------------------- |
| `register`      | During `server.register(plugin)` | Adding middleware, routes              |
| `initialize`    | Before `server.listen()`         | Connecting to resources                |
| `onServerStart` | After server is listening        | Verifying connections, starting timers |
| `onServerStop`  | When server begins shutdown      | Stopping new work, draining queues     |
| `terminate`     | During server shutdown           | Closing connections, cleanup           |

**Execution order:**

```
Startup:
  1. plugin1.register() ‚Üí plugin2.register() ‚Üí plugin3.register()
  2. plugin1.initialize() ‚Üí plugin2.initialize() ‚Üí plugin3.initialize()
  3. plugin1.onServerStart() ‚Üí plugin2.onServerStart() ‚Üí plugin3.onServerStart()

Shutdown (reverse order):
  1. plugin3.onServerStop() ‚Üí plugin2.onServerStop() ‚Üí plugin1.onServerStop()
  2. plugin3.terminate() ‚Üí plugin2.terminate() ‚Üí plugin1.terminate()
```

> ‚ö†Ô∏è **Critical:** Middleware MUST be registered in the `register` hook. Registering middleware elsewhere will cause the plugin to fail.

### Type parameters explained

```typescript
createPlugin<TConfig, TState, TServices>({ ... })
```

| Generic     | Purpose                            | Example                          |
| ----------- | ---------------------------------- | -------------------------------- |
| `TConfig`   | Configuration options shape        | `{ host: string; port: number }` |
| `TState`    | Adds to `ctx.state` (usually `{}`) | `{ requestId: string }`          |
| `TServices` | Adds to `ctx.services`             | `{ db: Database; cache: Cache }` |

**For middleware within plugins:**

```typescript
createMiddleware<TState, TServices>({ ... })
```

The middleware types must match what the plugin declares it provides.

---

## üìñ Drizzle integration

**Recommended** ‚Äî Drizzle is functional, type-safe, lightweight, and has excellent TypeScript support.

### Step 1: Install dependencies

```bash
pnpm add drizzle-orm better-sqlite3
pnpm add -D drizzle-kit @types/better-sqlite3
```

### Step 2: Define your schema

```typescript
// src/database/schema.ts
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .$defaultFn(() => new Date()),
});

export const posts = sqliteTable('posts', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: integer('user_id')
    .notNull()
    .references(() => users.id),
  title: text('title').notNull(),
  content: text('content').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .$defaultFn(() => new Date()),
});

// Export types for use in route handlers
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type Post = typeof posts.$inferSelect;
export type NewPost = typeof posts.$inferInsert;
```

### Step 3: Create database module

```typescript
// src/database/index.ts
import Database from 'better-sqlite3';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { users, posts } from './schema';

// Create SQLite connection
const sqlite = new Database('./data.db');

// Enable WAL mode for better concurrency
sqlite.pragma('journal_mode = WAL');

// Create Drizzle instance
export const db = drizzle(sqlite, {
  schema: { users, posts },
});

// Export schema for queries
export const schema = { users, posts };

// Export connection for cleanup
export const connection = sqlite;

// Export type for service injection
export type Database = typeof db;
```

### Step 4: Create database plugin

```typescript
// src/database/plugin.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { db, connection } from './index';
import type { Database } from './index';

interface DatabaseServices {
  db: Database;
}

export const createDatabasePlugin = () => {
  return createPlugin<{}, {}, DatabaseServices>({
    name: 'app-database',
    version: '1.0.0',

    setup: ({ logger }) => {
      const pluginLogger = logger.child({ plugin: 'database' });

      return {
        /**
         * Register - Add middleware to inject db into ctx.services
         * CRITICAL: Must happen in register hook, not setup body
         */
        register: async server => {
          pluginLogger.debug('Registering database middleware');

          server.use(
            createMiddleware<{}, DatabaseServices>({
              name: 'database',
              handler: async (ctx, next) => {
                ctx.services.db = db;
                await next();
              },
            })
          );

          pluginLogger.info('Database middleware registered');
        },

        /**
         * Initialize - Verify connection before server starts
         */
        initialize: async () => {
          pluginLogger.info('Initializing database');

          try {
            connection.prepare('SELECT 1').get();
            pluginLogger.info('Database connection verified');
          } catch (error) {
            pluginLogger.error('Database connection failed', {
              error: error instanceof Error ? error.message : String(error),
            });
            throw error;
          }
        },

        /**
         * Server start - Log readiness
         */
        onServerStart: async () => {
          pluginLogger.info('Database ready');
        },

        /**
         * Server stop - Prepare for shutdown
         */
        onServerStop: async () => {
          pluginLogger.info('Database stopping');
        },

        /**
         * Terminate - Close connection
         */
        terminate: async () => {
          pluginLogger.info('Closing database connection');
          connection.close();
          pluginLogger.info('Database connection closed');
        },
      };
    },
  });
};
```

### Step 5: Register the plugin

```typescript
// src/server.ts
import { createServer } from 'blaizejs';
import { createDatabasePlugin } from './database/plugin';

const server = createServer({
  port: 3000,
  routesDir: './src/routes',
}).register(createDatabasePlugin());

await server.listen();
```

### Step 6: Use in routes

```typescript
// src/routes/users/create.ts
import { createPostRoute } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../database/schema';

const createUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    // ctx.services.db is fully typed!
    const [user] = await ctx.services.db
      .insert(users)
      .values({
        name: ctx.request.body.name,
        email: ctx.request.body.email,
      })
      .returning();

    return { success: true, user };
  },
});
```

```typescript
// src/routes/users/[userId]/get.ts
import { createGetRoute, NotFoundError } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../../database/schema';
import { eq } from 'drizzle-orm';

export const getUser = createGetRoute({
  schema: {
    params: z.object({ userId: z.string() }),
  },
  handler: async (ctx, params) => {
    const [user] = await ctx.services.db
      .select()
      .from(users)
      .where(eq(users.id, parseInt(params.userId)))
      .limit(1);

    if (!user) {
      throw new NotFoundError('User not found');
    }

    return { success: true, user };
  },
});
```

### Step 7: Migrations

```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit';

export default {
  schema: './src/database/schema.ts',
  out: './drizzle',
  driver: 'better-sqlite',
  dbCredentials: {
    url: './data.db',
  },
} satisfies Config;
```

```bash
# Generate migration
pnpm drizzle-kit generate:sqlite

# Apply migration
pnpm drizzle-kit push:sqlite
```

---

## üìñ Prisma integration

Prisma provides an auto-generated client with excellent developer experience.

### Key differences from Drizzle

| Aspect     | Drizzle               | Prisma                |
| ---------- | --------------------- | --------------------- |
| Schema     | TypeScript files      | `schema.prisma` file  |
| Client     | Imported directly     | Generated by CLI      |
| Migrations | `drizzle-kit`         | `prisma migrate`      |
| Connection | Lazy (on first query) | Lazy (on first query) |

### Step 1: Install dependencies

```bash
pnpm add @prisma/client
pnpm add -D prisma
```

### Step 2: Initialize Prisma

```bash
pnpm prisma init
```

### Step 3: Define your schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  createdAt DateTime @default(now())
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  userId    Int
  title     String
  content   String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}
```

### Step 4: Generate Prisma Client

```bash
pnpm prisma generate
```

### Step 5: Create database module

```typescript
// src/database/index.ts
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient({
  log: ['query', 'error', 'warn'],
});

export type Database = typeof prisma;
```

### Step 6: Create database plugin

```typescript
// src/database/plugin.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { prisma } from './index';
import type { Database } from './index';

interface DatabaseServices {
  db: Database;
}

export const createDatabasePlugin = () => {
  return createPlugin<{}, {}, DatabaseServices>({
    name: 'app-database',
    version: '1.0.0',

    setup: ({ logger }) => {
      const pluginLogger = logger.child({ plugin: 'database' });

      return {
        register: async server => {
          server.use(
            createMiddleware<{}, DatabaseServices>({
              name: 'database',
              handler: async (ctx, next) => {
                ctx.services.db = prisma;
                await next();
              },
            })
          );

          pluginLogger.info('Database middleware registered');
        },

        initialize: async () => {
          // Prisma connects lazily, verify with simple query
          await prisma.$queryRaw`SELECT 1`;
          pluginLogger.info('Database connection verified');
        },

        onServerStart: async () => {
          pluginLogger.info('Database ready');
        },

        onServerStop: async () => {
          pluginLogger.info('Database stopping');
        },

        terminate: async () => {
          await prisma.$disconnect();
          pluginLogger.info('Database connection closed');
        },
      };
    },
  });
};
```

### Step 7: Use in routes

```typescript
// src/routes/users/create.ts
import { createPostRoute } from 'blaizejs';
import { z } from 'zod';

const createUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    const user = await ctx.services.db.user.create({
      data: {
        name: ctx.request.body.name,
        email: ctx.request.body.email,
      },
    });

    return { success: true, user };
  },
});
```

### Step 8: Migrations

```bash
# Create migration
pnpm prisma migrate dev --name init

# Apply in production
pnpm prisma migrate deploy
```

---

## üìñ TypeORM integration

TypeORM is a mature ORM with decorator-based entities and extensive features.

### Step 1: Install dependencies

```bash
pnpm add typeorm reflect-metadata better-sqlite3
pnpm add -D @types/better-sqlite3
```

### Step 2: Define entities

```typescript
// src/database/entities/User.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, OneToMany } from 'typeorm';
import { Post } from './Post';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column({ unique: true })
  email: string;

  @CreateDateColumn()
  createdAt: Date;

  @OneToMany(() => Post, post => post.user)
  posts: Post[];
}
```

```typescript
// src/database/entities/Post.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne } from 'typeorm';
import { User } from './User';

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  userId: number;

  @Column()
  title: string;

  @Column()
  content: string;

  @CreateDateColumn()
  createdAt: Date;

  @ManyToOne(() => User, user => user.posts)
  user: User;
}
```

### Step 3: Create database module

```typescript
// src/database/index.ts
import 'reflect-metadata';
import { DataSource } from 'typeorm';
import { User } from './entities/User';
import { Post } from './entities/Post';

export const AppDataSource = new DataSource({
  type: 'sqlite',
  database: './data.db',
  entities: [User, Post],
  synchronize: true, // Disable in production!
  logging: true,
});

export type Database = typeof AppDataSource;
```

### Step 4: Create database plugin

```typescript
// src/database/plugin.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { AppDataSource } from './index';
import type { Database } from './index';

interface DatabaseServices {
  db: Database;
}

export const createDatabasePlugin = () => {
  return createPlugin<{}, {}, DatabaseServices>({
    name: 'app-database',
    version: '1.0.0',

    setup: ({ logger }) => {
      const pluginLogger = logger.child({ plugin: 'database' });

      return {
        register: async server => {
          server.use(
            createMiddleware<{}, DatabaseServices>({
              name: 'database',
              handler: async (ctx, next) => {
                ctx.services.db = AppDataSource;
                await next();
              },
            })
          );

          pluginLogger.info('Database middleware registered');
        },

        initialize: async () => {
          await AppDataSource.initialize();
          pluginLogger.info('Database connection initialized');
        },

        onServerStart: async () => {
          pluginLogger.info('Database ready');
        },

        onServerStop: async () => {
          pluginLogger.info('Database stopping');
        },

        terminate: async () => {
          await AppDataSource.destroy();
          pluginLogger.info('Database connection closed');
        },
      };
    },
  });
};
```

### Step 5: Use in routes

```typescript
// src/routes/users/create.ts
import { createPostRoute } from 'blaizejs';
import { z } from 'zod';
import { User } from '../../database/entities/User';

const createUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    const userRepository = ctx.services.db.getRepository(User);

    const user = userRepository.create({
      name: ctx.request.body.name,
      email: ctx.request.body.email,
    });

    await userRepository.save(user);

    return { success: true, user };
  },
});
```

---

## üöÄ Advanced patterns

### Real-time updates with EventBus

Combine database operations with EventBus for real-time coordination across your application.

**Use cases:**

- User notifications (new follower, new message)
- Real-time dashboards (sales updates, activity feeds)
- Cache invalidation across multiple servers
- SSE streaming (live updates to connected clients)

**Example with Drizzle:**

```typescript
// src/routes/users/create.ts
import { createPostRoute } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../database/schema';

const createUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    // Create user with Drizzle
    const [user] = await ctx.services.db
      .insert(users)
      .values({
        name: ctx.request.body.name,
        email: ctx.request.body.email,
      })
      .returning();

    // Publish event for real-time coordination
    await ctx.eventBus.publish('user:created', {
      userId: user.id,
      name: user.name,
      email: user.email,
      timestamp: Date.now(),
    });

    return { success: true, user };
  },
});
```

**SSE endpoint for real-time updates:**

```typescript
// src/routes/users/stream.ts
import { createSSERoute } from 'blaizejs';

export const userStream = createSSERoute({
  handler: async (stream, ctx) => {
    ctx.logger.info('Client connected to user stream');

    stream.send('connected', {
      message: 'Connected to user updates',
      timestamp: new Date().toISOString(),
    });

    // Subscribe to user events
    const unsubscribe = ctx.eventBus.subscribe('user:created', event => {
      stream.send('user-created', {
        user: event.data,
        timestamp: new Date(event.timestamp).toISOString(),
      });
    });

    // Heartbeat every 30 seconds
    const heartbeat = setInterval(() => {
      stream.send('heartbeat', {
        timestamp: new Date().toISOString(),
      });
    }, 30000);

    // Cleanup on disconnect
    stream.onClose(() => {
      ctx.logger.info('Client disconnected from user stream');
      unsubscribe();
      clearInterval(heartbeat);
    });
  },
});
```

### Database helpers with automatic events

Create helper functions that combine Drizzle operations with automatic event emission:

```typescript
// src/database/helpers.ts
import { db } from './index';
import { users } from './schema';
import { eq } from 'drizzle-orm';
import type { NewUser, User } from './schema';
import type { EventBus } from 'blaizejs';

export function createDatabaseHelpers(eventBus: EventBus) {
  return {
    users: {
      async create(data: NewUser): Promise<User> {
        const [user] = await db.insert(users).values(data).returning();

        await eventBus.publish('user:created', {
          userId: user.id,
          data: user,
        });

        return user;
      },

      async update(id: number, data: Partial<NewUser>): Promise<User> {
        const [user] = await db.update(users).set(data).where(eq(users.id, id)).returning();

        await eventBus.publish('user:updated', {
          userId: id,
          data: user,
        });

        return user;
      },

      async delete(id: number): Promise<void> {
        await db.delete(users).where(eq(users.id, id));

        await eventBus.publish('user:deleted', {
          userId: id,
        });
      },
    },

    // Raw database access when needed
    db,
  };
}
```

**Update plugin to inject helpers:**

```typescript
register: async server => {
  const dbWithHelpers = createDatabaseHelpers(server.eventBus);

  server.use(
    createMiddleware<{}, { db: ReturnType<typeof createDatabaseHelpers> }>({
      name: 'database',
      handler: async (ctx, next) => {
        ctx.services.db = dbWithHelpers;
        await next();
      },
    })
  );
};
```

**Use in routes:**

```typescript
export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    // Helper automatically emits event
    const user = await ctx.services.db.users.create({
      name: ctx.request.body.name,
      email: ctx.request.body.email,
    });

    return { success: true, user };
  },
});
```

### Transaction support

Handle multi-step operations atomically:

```typescript
// src/routes/posts/create.ts
import { createPostRoute, NotFoundError } from 'blaizejs';
import { z } from 'zod';
import { posts, users } from '../../database/schema';
import { eq } from 'drizzle-orm';

const createPostSchema = z.object({
  userId: z.number(),
  title: z.string().min(1).max(200),
  content: z.string().min(1),
});

export const createPost = createPostRoute({
  schema: {
    body: createPostSchema,
  },
  handler: async ctx => {
    // Use Drizzle's transaction API
    const result = await ctx.services.db.transaction(async tx => {
      // Verify user exists
      const [user] = await tx
        .select()
        .from(users)
        .where(eq(users.id, ctx.request.body.userId))
        .limit(1);

      if (!user) {
        throw new NotFoundError('User not found');
      }

      // Create post
      const [post] = await tx
        .insert(posts)
        .values({
          userId: ctx.request.body.userId,
          title: ctx.request.body.title,
          content: ctx.request.body.content,
        })
        .returning();

      return { user, post };
    });

    // Transaction committed - emit event AFTER success
    await ctx.eventBus.publish('post:created', {
      postId: result.post.id,
      userId: result.user.id,
      data: result.post,
    });

    return { success: true, post: result.post };
  },
});
```

**Key points:**

- All operations in transaction are atomic
- Emit events AFTER transaction commits
- If transaction fails, no events are emitted

### Multi-server coordination

Use EventBus with Redis adapter for cache invalidation across multiple servers:

```typescript
// Server setup with Redis EventBus
import { createServer } from 'blaizejs';
import { createRedisClient, RedisEventBusAdapter } from '@blaizejs/adapter-redis';

const redisClient = createRedisClient({
  host: 'localhost',
  port: 6379,
});

const redisAdapter = new RedisEventBusAdapter(redisClient);

const server = createServer({
  serverId: process.env.SERVER_ID || 'server-1',
  routesDir: './src/routes',
})
  .register(createDatabasePlugin())
  .register(createCachePlugin());

// Attach Redis adapter to EventBus
await server.eventBus.setAdapter(redisAdapter);

await server.listen(3000);
```

**Update user route:**

```typescript
// src/routes/users/[userId]/update.ts
import { createPutRoute } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../../database/schema';
import { eq } from 'drizzle-orm';

const updateUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const updateUser = createPutRoute({
  schema: {
    params: z.object({ userId: z.string() }),
    body: updateUserSchema,
  },
  handler: async (ctx, params) => {
    const userId = parseInt(params.userId);

    // Update user in database
    const [user] = await ctx.services.db
      .update(users)
      .set({
        name: ctx.request.body.name,
        email: ctx.request.body.email,
      })
      .where(eq(users.id, userId))
      .returning();

    // Publish event - propagates to ALL servers via Redis
    await ctx.eventBus.publish('user:updated', {
      userId,
      data: user,
    });

    return { success: true, user };
  },
});
```

**All servers subscribe to invalidate cache:**

```typescript
server.eventBus.subscribe('user:updated', async event => {
  // This runs on ALL servers
  await ctx.services.cache.delete(`user:${event.data.userId}`);
  console.log(`[${server.serverId}] Cache invalidated for user ${event.data.userId}`);
});
```

**How it works:**

- Without Redis adapter: Events only on current server
- With Redis adapter: Events propagate to all servers
- Each server independently invalidates its cache
- Ensures cache consistency across your cluster

---

## üêõ Troubleshooting

### "Property 'db' does not exist on type 'Services'"

**Cause:** TypeScript doesn't know about your database service.

**Solution:** Ensure your plugin defines the services interface:

```typescript
interface DatabaseServices {
  db: Database;
}

createPlugin<{}, {}, DatabaseServices>({ ... })
```

And ensure your middleware uses the same type:

```typescript
createMiddleware<{}, DatabaseServices>({ ... })
```

---

### "Database connection closed" errors

**Cause:** Database disconnected before request completed.

**Solution:** Ensure `terminate` hook is only called on shutdown:

```typescript
terminate: async () => {
  // Only runs when server.close() is called
  await connection.close();
};
```

---

### Middleware not injecting database

**Cause:** Middleware registered in wrong lifecycle hook.

**Solution:** Register middleware in `register` hook:

```typescript
// ‚úÖ Correct
return {
  register: async (server) => {
    server.use(middleware);
  },
}

// ‚ùå Wrong - server not available in setup body
setup: ({ logger }) => {
  server.use(middleware); // Error!
  return { ... };
}
```

---

### TypeScript types not working

**Cause:** Database type not exported or imported correctly.

**Solution:**

```typescript
// Export type from database module
export type Database = typeof db;

// Import in plugin
import type { Database } from './index';

// Use in services interface
interface DatabaseServices {
  db: Database;
}
```

---

## ‚ö° Performance tips

### Connection pooling

**For PostgreSQL with Drizzle:**

```typescript
import { Pool } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';
import * as schema from './schema';

const pool = new Pool({
  host: 'localhost',
  port: 5432,
  database: 'mydb',
  user: 'postgres',
  password: 'password',
  max: 20, // Maximum connections
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

export const db = drizzle(pool, { schema });
```

### Query optimization

**Select specific columns:**

```typescript
import { users } from './schema';

// ‚ùå Don't select everything
const allUsers = await ctx.services.db.select().from(users);

// ‚úÖ Select only needed columns
const userNames = await ctx.services.db
  .select({
    id: users.id,
    name: users.name,
  })
  .from(users);
```

**Use prepared statements:**

```typescript
import { users } from './schema';
import { eq, sql } from 'drizzle-orm';

// Drizzle automatically uses prepared statements
const getUserById = ctx.services.db
  .select()
  .from(users)
  .where(eq(users.id, sql.placeholder('id')))
  .prepare();

// Reuse prepared statement efficiently
const user1 = await getUserById.execute({ id: 1 });
const user2 = await getUserById.execute({ id: 2 });
```

### Caching strategies

**Cache frequently accessed data:**

```typescript
import { createGetRoute, NotFoundError } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../database/schema';
import { eq } from 'drizzle-orm';

export const getUser = createGetRoute({
  schema: {
    params: z.object({ userId: z.string() }),
  },
  handler: async (ctx, params) => {
    const cacheKey = `user:${params.userId}`;

    // Check cache first
    let user = await ctx.services.cache.get(cacheKey);

    if (!user) {
      // Cache miss - query database
      const [dbUser] = await ctx.services.db
        .select()
        .from(users)
        .where(eq(users.id, parseInt(params.userId)))
        .limit(1);

      if (dbUser) {
        // Store in cache for 5 minutes
        await ctx.services.cache.set(cacheKey, JSON.stringify(dbUser), 300);
        user = dbUser;
      }
    } else {
      user = JSON.parse(user);
    }

    if (!user) {
      throw new NotFoundError('User not found');
    }

    return { success: true, user };
  },
});
```

**Invalidate cache on update:**

```typescript
import { createPutRoute } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../database/schema';
import { eq } from 'drizzle-orm';

const updateUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const updateUser = createPutRoute({
  schema: {
    params: z.object({ userId: z.string() }),
    body: updateUserSchema,
  },
  handler: async (ctx, params) => {
    const userId = parseInt(params.userId);

    // Update database
    const [user] = await ctx.services.db
      .update(users)
      .set(ctx.request.body)
      .where(eq(users.id, userId))
      .returning();

    // Invalidate cache
    await ctx.services.cache.delete(`user:${userId}`);

    // Emit event for multi-server coordination
    await ctx.eventBus.publish('user:updated', { userId });

    return { success: true, user };
  },
});
```

---

## üîó Related documentation

- [Plugin system](./plugins) ‚Äî Deep dive into plugin architecture
- [EventBus](./eventbus) ‚Äî Real-time event coordination
- [Server-Sent Events](./sse) ‚Äî Real-time updates to clients
- [Middleware](./middleware) ‚Äî Request/response processing

---

## ‚úÖ Summary

You've learned:

- ‚úÖ How to create a database plugin with lifecycle management
- ‚úÖ How to inject services with full type safety
- ‚úÖ How to handle connections and cleanup properly
- ‚úÖ How to publish events for real-time updates
- ‚úÖ How to coordinate across multiple servers
- ‚úÖ How to optimize queries and implement caching

**This same pattern works for any external service** ‚Äî Redis, message queues, search engines, or custom integrations. You now have the power to integrate anything into BlaizeJS!

---

**Next steps:**

1. Choose your ORM ([Drizzle](#drizzle-integration) recommended)
2. Follow the integration guide
3. Add real-time updates with EventBus
4. Implement caching for performance
5. Deploy with confidence!
