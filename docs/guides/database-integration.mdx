# üóÑÔ∏è Database integration

> **Learn how to integrate any database or ORM into your BlaizeJS application using the plugin system with factory functions for safe service access**

This guide teaches you the **pattern** for integrating databases ‚Äî not a specific implementation. You'll get full control, perfect type safety, and lifecycle management while keeping the flexibility to use your preferred tools. Plus, you'll learn how to safely access your database from route handlers, job handlers, and utility functions.

---

## üéØ Philosophy: Teaching patterns, not abstractions

BlaizeJS intentionally does not provide a database plugin because:

1. **Existing ORMs are excellent** ‚Äî Drizzle, Prisma, and TypeORM are battle-tested with great TypeScript support
2. **You know your needs best** ‚Äî Your database setup, migrations, and query patterns are unique to your app
3. **Teaching > Abstracting** ‚Äî Understanding how to inject services gives you the power to integrate _anything_
4. **Type safety** ‚Äî Using your ORM directly preserves all its TypeScript types

**The same pattern you learn here works for:**

- Redis and caching systems
- Message queues (RabbitMQ, Kafka)
- Search engines (Elasticsearch, MeiliSearch)
- Any external service

---

## üìö What you'll learn

- ‚úÖ Create a database plugin with lifecycle management
- ‚úÖ Export factory functions for safe service access
- ‚úÖ Inject your database into `ctx.services` with full type safety
- ‚úÖ Use database in routes, job handlers, and utilities
- ‚úÖ Handle connections, disconnections, and errors gracefully
- ‚úÖ Publish events for real-time updates
- ‚úÖ Coordinate across multiple servers
- ‚úÖ Integrate transactions and complex queries

---

## üìã Prerequisites

- Complete the [Quick Start Guide](../quick-start)
- Familiarity with TypeScript
- Understanding of SQL/databases
- Your preferred ORM installed

---

## üöÄ Quick start

**Jump to your ORM:**

| ORM         | Best For                              | Jump To                                       |
| ----------- | ------------------------------------- | --------------------------------------------- |
| **Drizzle** | Type-safety, lightweight, functional  | [Drizzle Integration ‚Üí](#drizzle-integration) |
| **Prisma**  | Auto-generated client, great DX       | [Prisma Integration ‚Üí](#prisma-integration)   |
| **TypeORM** | Mature, decorator-based, feature-rich | [TypeORM Integration ‚Üí](#typeorm-integration) |

---

## üß† Understanding the plugin system

### Plugins vs middleware

Before diving into code, understand when to use each:

| Concept        | When to Use              | Example                                  |
| -------------- | ------------------------ | ---------------------------------------- |
| **Middleware** | Per-request logic        | Authentication, logging, request parsing |
| **Plugins**    | Once at startup/shutdown | Database connections, background workers |

```typescript
// ‚ùå WRONG: Creating a database connection on every request
const dbMiddleware = createMiddleware({
  handler: async (ctx, next) => {
    ctx.services.db = await Database.connect(); // Expensive!
    await next();
    await ctx.services.db.close(); // Wasteful!
  },
});

// ‚úÖ CORRECT: Plugin connects once, factory provides safe access
// Internal singleton (private)
let _db: Database | null = null;

// Factory function for external access (public)
export function getDatabase(): Database {
  if (!_db) {
    throw new Error(
      'Database not initialized. ' +
      'Make sure you have registered the database plugin.'
    );
  }
  return _db;
}

const databasePlugin = createPlugin<
  { connectionString: string }, // Config
  {}, // State (none needed)
  { db: Database } // Services to inject
>({
  name: 'database',
  version: '1.0.0',

  setup: ({ config, logger }) => {
    return {
      // Connect ONCE at startup (only place to assign _db)
      initialize: async () => {
        _db = await Database.connect(config.connectionString);
      },

      // Register middleware to provide access in routes
      register: async server => {
        server.use(
          createMiddleware<{}, { db: Database }>({
            name: 'database',
            handler: async (ctx, next) => {
              ctx.services.db = getDatabase(); // Use factory
              await next();
            },
          })
        );
      },

      // Clean up ONCE at shutdown (only place to clear _db)
      terminate: async () => {
        const db = getDatabase();
        await db.close();
        _db = null;
      },
    };
  },
});
```

### Two ways to access your database

BlaizeJS plugins provide **two access patterns**, each optimized for different contexts:

| Context | Access Method | Example |
|---------|---------------|---------|
| **Route handlers** | `ctx.services.db` | `await ctx.services.db.insert(...)` |
| **Job handlers** | `getDatabase()` | `const db = getDatabase()` |
| **Utility functions** | `getDatabase()` | `const db = getDatabase()` |
| **Worker processes** | `getDatabase()` | `const db = getDatabase()` |

**Why two patterns?**

- **Route handlers** receive context via middleware ‚Üí use `ctx.services.db`
- **Everything else** doesn't have context ‚Üí use `getDatabase()` factory function

This pattern gives you:
- ‚úÖ **Clear error messages** ‚Äî "Database not initialized..." instead of "Cannot read property of null"
- ‚úÖ **Explicit intent** ‚Äî `getDatabase()` shows you're retrieving a service
- ‚úÖ **Easy testing** ‚Äî Mock the factory function, not the instance
- ‚úÖ **Safety checks** ‚Äî Factory verifies initialization state

### Plugin lifecycle hooks

Plugins implement up to five lifecycle hooks:

| Hook            | When It Runs                     | Use For                                |
| --------------- | -------------------------------- | -------------------------------------- |
| `register`      | During `server.register(plugin)` | Adding middleware, routes              |
| `initialize`    | Before `server.listen()`         | Connecting to resources                |
| `onServerStart` | After server is listening        | Verifying connections, starting timers |
| `onServerStop`  | When server begins shutdown      | Stopping new work, draining queues     |
| `terminate`     | During server shutdown           | Closing connections, cleanup           |

**Execution order:**

```
Startup:
  1. plugin1.register() ‚Üí plugin2.register() ‚Üí plugin3.register()
  2. plugin1.initialize() ‚Üí plugin2.initialize() ‚Üí plugin3.initialize()
  3. plugin1.onServerStart() ‚Üí plugin2.onServerStart() ‚Üí plugin3.onServerStart()

Shutdown (reverse order):
  1. plugin3.onServerStop() ‚Üí plugin2.onServerStop() ‚Üí plugin1.onServerStop()
  2. plugin3.terminate() ‚Üí plugin2.terminate() ‚Üí plugin1.terminate()
```

> ‚ö†Ô∏è **Critical:** Middleware MUST be registered in the `register` hook. Registering middleware elsewhere will cause the plugin to fail.

### Type parameters explained

```typescript
createPlugin<TConfig, TState, TServices>({ ... })
```

| Generic     | Purpose                            | Example                          |
| ----------- | ---------------------------------- | -------------------------------- |
| `TConfig`   | Configuration options shape        | `{ host: string; port: number }` |
| `TState`    | Adds to `ctx.state` (usually `{}`) | `{ requestId: string }`          |
| `TServices` | Adds to `ctx.services`             | `{ db: Database; cache: Cache }` |

**For middleware within plugins:**

```typescript
createMiddleware<TState, TServices>({ ... })
```

The middleware types must match what the plugin declares it provides.

### Naming conventions

Follow these patterns for consistency:

| Service Type | Factory Function | Check Function | Private Variable |
|--------------|------------------|----------------|------------------|
| `Database` | `getDatabase()` | `isDatabaseInitialized()` | `_db` |
| `PrismaClient` | `getPrisma()` | `isPrismaInitialized()` | `_prisma` |
| `DataSource` | `getDataSource()` | `isDataSourceInitialized()` | `_dataSource` |

**Pattern:** `get[ServiceName]()` where ServiceName is PascalCase

---

## üìñ Drizzle integration

**Recommended** ‚Äî Drizzle is functional, type-safe, lightweight, and has excellent TypeScript support.

### Step 1: Install dependencies

```bash
pnpm add drizzle-orm better-sqlite3
pnpm add -D drizzle-kit @types/better-sqlite3
```

### Step 2: Define your schema

```typescript
// src/database/schema.ts
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';

export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .$defaultFn(() => new Date()),
});

export const posts = sqliteTable('posts', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: integer('user_id')
    .notNull()
    .references(() => users.id),
  title: text('title').notNull(),
  content: text('content').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .$defaultFn(() => new Date()),
});

// Export types for use in route handlers
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type Post = typeof posts.$inferSelect;
export type NewPost = typeof posts.$inferInsert;
```

### Step 3: Create database module with factory functions

```typescript
// src/database/index.ts
import Database from 'better-sqlite3';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { users, posts } from './schema';
import type { BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';

// Internal singletons (private)
let _sqlite: Database.Database | null = null;
let _db: BetterSQLite3Database<typeof schema> | null = null;

const schema = { users, posts };

/**
 * Get the Drizzle database instance
 * 
 * Safe for use in:
 * - Job handlers
 * - Utility functions
 * - Worker processes
 * - Anywhere outside route handlers
 * 
 * @throws {Error} If called before database plugin is initialized
 * 
 * @example In job handlers
 * ```typescript
 * import { getDatabase } from '../../database';
 * 
 * export const cleanupHandler = createHandler(queues, 'maintenance', 'cleanup',
 *   async (data, ctx) => {
 *     const db = getDatabase();
 *     await db.delete(sessions).where(lt(sessions.expiresAt, new Date()));
 *   }
 * );
 * ```
 * 
 * @example In utility functions
 * ```typescript
 * import { getDatabase } from '../database';
 * 
 * export async function getUserStats(userId: number) {
 *   const db = getDatabase();
 *   return await db.select().from(users).where(eq(users.id, userId));
 * }
 * ```
 */
export function getDatabase(): BetterSQLite3Database<typeof schema> {
  if (!_db) {
    throw new Error(
      'Database not initialized. ' +
      'Make sure you have registered the database plugin.'
    );
  }
  return _db;
}

/**
 * Check if database is initialized
 * 
 * Useful for conditional logic or startup checks.
 * 
 * @returns true if the database has been initialized
 */
export function isDatabaseInitialized(): boolean {
  return _db !== null;
}

/**
 * Initialize database (called by plugin)
 * @internal - Do not call directly
 */
export function initializeDatabase(): void {
  _sqlite = new Database('./data.db');
  _sqlite.pragma('journal_mode = WAL');
  _db = drizzle(_sqlite, { schema });
}

/**
 * Close database connection (called by plugin)
 * @internal - Do not call directly
 */
export function closeDatabase(): void {
  if (_sqlite) {
    _sqlite.close();
    _sqlite = null;
  }
  _db = null;
}

// Export schema for queries
export { schema };

// Export type for service injection
export type Database = BetterSQLite3Database<typeof schema>;
```

### Step 4: Create database plugin

```typescript
// src/database/plugin.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { 
  getDatabase, 
  initializeDatabase, 
  closeDatabase,
  isDatabaseInitialized 
} from './index';
import type { Database } from './index';

interface DatabaseServices {
  db: Database;
}

export const createDatabasePlugin = () => {
  return createPlugin<{}, {}, DatabaseServices>({
    name: 'app-database',
    version: '1.0.0',

    setup: ({ logger }) => {
      const pluginLogger = logger.child({ plugin: 'database' });

      return {
        /**
         * Register - Add middleware to inject db into ctx.services
         * CRITICAL: Must happen in register hook, not setup body
         */
        register: async server => {
          pluginLogger.debug('Registering database middleware');

          server.use(
            createMiddleware<{}, DatabaseServices>({
              name: 'database',
              handler: async (ctx, next) => {
                ctx.services.db = getDatabase(); // Use factory
                await next();
              },
            })
          );

          pluginLogger.info('Database middleware registered');
        },

        /**
         * Initialize - Connect to database before server starts
         */
        initialize: async () => {
          pluginLogger.info('Initializing database');

          try {
            initializeDatabase(); // Only place to create connection
            
            // Verify connection
            const db = getDatabase();
            db.run('SELECT 1');
            
            pluginLogger.info('Database connection verified');
          } catch (error) {
            pluginLogger.error('Database connection failed', {
              error: error instanceof Error ? error.message : String(error),
            });
            throw error;
          }
        },

        /**
         * Server start - Log readiness
         */
        onServerStart: async () => {
          pluginLogger.info('Database ready', {
            initialized: isDatabaseInitialized(),
          });
        },

        /**
         * Server stop - Prepare for shutdown
         */
        onServerStop: async () => {
          pluginLogger.info('Database stopping');
        },

        /**
         * Terminate - Close connection
         */
        terminate: async () => {
          pluginLogger.info('Closing database connection');
          closeDatabase(); // Only place to close connection
          pluginLogger.info('Database connection closed', {
            initialized: isDatabaseInitialized(),
          });
        },
      };
    },
  });
};
```

### Step 5: Register the plugin

```typescript
// src/server.ts
import { createServer } from 'blaizejs';
import { createDatabasePlugin } from './database/plugin';

const server = createServer({
  port: 3000,
  routesDir: './src/routes',
}).register(createDatabasePlugin());

await server.listen();
```

### Step 6: Use in routes

```typescript
// src/routes/users/create.ts
import { createPostRoute } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../database/schema';

const createUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    // ctx.services.db is fully typed!
    const [user] = await ctx.services.db
      .insert(users)
      .values({
        name: ctx.request.body.name,
        email: ctx.request.body.email,
      })
      .returning();

    return { success: true, user };
  },
});
```

```typescript
// src/routes/users/[userId]/get.ts
import { createGetRoute, NotFoundError } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../../database/schema';
import { eq } from 'drizzle-orm';

export const getUser = createGetRoute({
  schema: {
    params: z.object({ userId: z.string() }),
  },
  handler: async (ctx, params) => {
    // Use ctx.services in routes
    const [user] = await ctx.services.db
      .select()
      .from(users)
      .where(eq(users.id, parseInt(params.userId)))
      .limit(1);

    if (!user) {
      throw new NotFoundError('User not found');
    }

    return { success: true, user };
  },
});
```

### Step 7: Use in job handlers

```typescript
// src/queues/cleanup/old-sessions.ts
import { getDatabase } from '../../database';
import { sessions } from '../../database/schema';
import { lt } from 'drizzle-orm';

export const cleanupOldSessions = createHandler(
  queues,
  'maintenance',
  'cleanup-sessions',
  async (data, ctx) => {
    // Use factory function in job handlers
    const db = getDatabase();
    
    const result = await db
      .delete(sessions)
      .where(lt(sessions.expiresAt, new Date()))
      .returning({ id: sessions.id });

    ctx.logger.info('Cleaned up old sessions', { 
      count: result.length 
    });

    return { deletedCount: result.length };
  }
);
```

### Step 8: Use in utility functions

```typescript
// src/lib/user-stats.ts
import { getDatabase } from '../database';
import { users, posts } from '../database/schema';
import { eq, count } from 'drizzle-orm';

/**
 * Get statistics for a user
 * Safe to call from anywhere - uses factory function
 */
export async function getUserStats(userId: number) {
  // Use factory function in utilities
  const db = getDatabase();

  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.id, userId))
    .limit(1);

  if (!user) {
    return null;
  }

  const [postCount] = await db
    .select({ count: count() })
    .from(posts)
    .where(eq(posts.userId, userId));

  return {
    user,
    stats: {
      totalPosts: postCount.count,
      accountAge: Date.now() - user.createdAt.getTime(),
    },
  };
}
```

### Step 9: Migrations

```typescript
// drizzle.config.ts
import type { Config } from 'drizzle-kit';

export default {
  schema: './src/database/schema.ts',
  out: './drizzle',
  driver: 'better-sqlite',
  dbCredentials: {
    url: './data.db',
  },
} satisfies Config;
```

```bash
# Generate migration
pnpm drizzle-kit generate:sqlite

# Apply migration
pnpm drizzle-kit push:sqlite
```

---

## üìñ Prisma integration

Prisma provides an auto-generated client with excellent developer experience.

### Key differences from Drizzle

| Aspect     | Drizzle               | Prisma                |
| ---------- | --------------------- | --------------------- |
| Schema     | TypeScript files      | `schema.prisma` file  |
| Client     | Imported directly     | Generated by CLI      |
| Migrations | `drizzle-kit`         | `prisma migrate`      |
| Connection | Lazy (on first query) | Lazy (on first query) |

### Step 1: Install dependencies

```bash
pnpm add @prisma/client
pnpm add -D prisma
```

### Step 2: Initialize Prisma

```bash
pnpm prisma init
```

### Step 3: Define your schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  createdAt DateTime @default(now())
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  userId    Int
  title     String
  content   String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}
```

### Step 4: Generate Prisma Client

```bash
pnpm prisma generate
```

### Step 5: Create database module with factory functions

```typescript
// src/database/index.ts
import { PrismaClient } from '@prisma/client';

// Internal singleton (private)
let _prisma: PrismaClient | null = null;

/**
 * Get the Prisma client instance
 * 
 * Safe for use in:
 * - Job handlers
 * - Utility functions
 * - Worker processes
 * - Anywhere outside route handlers
 * 
 * @throws {Error} If called before Prisma is initialized
 * 
 * @example In job handlers
 * ```typescript
 * import { getPrisma } from '../../database';
 * 
 * export const cleanupHandler = createHandler(queues, 'maintenance', 'cleanup',
 *   async (data, ctx) => {
 *     const prisma = getPrisma();
 *     await prisma.session.deleteMany({
 *       where: { expiresAt: { lt: new Date() } }
 *     });
 *   }
 * );
 * ```
 */
export function getPrisma(): PrismaClient {
  if (!_prisma) {
    throw new Error(
      'Prisma not initialized. ' +
      'Make sure you have registered the database plugin.'
    );
  }
  return _prisma;
}

/**
 * Check if Prisma is initialized
 */
export function isPrismaInitialized(): boolean {
  return _prisma !== null;
}

/**
 * Initialize Prisma (called by plugin)
 * @internal
 */
export function initializePrisma(): void {
  _prisma = new PrismaClient({
    log: ['query', 'error', 'warn'],
  });
}

/**
 * Close Prisma connection (called by plugin)
 * @internal
 */
export async function closePrisma(): Promise<void> {
  if (_prisma) {
    await _prisma.$disconnect();
    _prisma = null;
  }
}

// Export type
export type Database = PrismaClient;
```

### Step 6: Create database plugin

```typescript
// src/database/plugin.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { 
  getPrisma, 
  initializePrisma, 
  closePrisma,
  isPrismaInitialized 
} from './index';
import type { Database } from './index';

interface DatabaseServices {
  db: Database;
}

export const createDatabasePlugin = () => {
  return createPlugin<{}, {}, DatabaseServices>({
    name: 'app-database',
    version: '1.0.0',

    setup: ({ logger }) => {
      const pluginLogger = logger.child({ plugin: 'database' });

      return {
        register: async server => {
          server.use(
            createMiddleware<{}, DatabaseServices>({
              name: 'database',
              handler: async (ctx, next) => {
                ctx.services.db = getPrisma(); // Use factory
                await next();
              },
            })
          );

          pluginLogger.info('Database middleware registered');
        },

        initialize: async () => {
          pluginLogger.info('Initializing Prisma');
          
          initializePrisma(); // Only place to create client
          
          // Verify connection
          const prisma = getPrisma();
          await prisma.$queryRaw`SELECT 1`;
          
          pluginLogger.info('Prisma connection verified');
        },

        onServerStart: async () => {
          pluginLogger.info('Database ready', {
            initialized: isPrismaInitialized(),
          });
        },

        onServerStop: async () => {
          pluginLogger.info('Database stopping');
        },

        terminate: async () => {
          pluginLogger.info('Closing Prisma connection');
          await closePrisma(); // Only place to disconnect
          pluginLogger.info('Prisma connection closed');
        },
      };
    },
  });
};
```

### Step 7: Use in routes

```typescript
// src/routes/users/create.ts
import { createPostRoute } from 'blaizejs';
import { z } from 'zod';

const createUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    // Use ctx.services in routes
    const user = await ctx.services.db.user.create({
      data: {
        name: ctx.request.body.name,
        email: ctx.request.body.email,
      },
    });

    return { success: true, user };
  },
});
```

### Step 8: Use in job handlers

```typescript
// src/queues/cleanup/old-sessions.ts
import { getPrisma } from '../../database';

export const cleanupOldSessions = createHandler(
  queues,
  'maintenance',
  'cleanup-sessions',
  async (data, ctx) => {
    // Use factory function in job handlers
    const prisma = getPrisma();
    
    const result = await prisma.session.deleteMany({
      where: {
        expiresAt: { lt: new Date() },
      },
    });

    ctx.logger.info('Cleaned up old sessions', { 
      count: result.count 
    });

    return { deletedCount: result.count };
  }
);
```

### Step 9: Use in utility functions

```typescript
// src/lib/user-stats.ts
import { getPrisma } from '../database';

export async function getUserStats(userId: number) {
  // Use factory function in utilities
  const prisma = getPrisma();

  const user = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      _count: {
        select: { posts: true },
      },
    },
  });

  if (!user) {
    return null;
  }

  return {
    user,
    stats: {
      totalPosts: user._count.posts,
      accountAge: Date.now() - user.createdAt.getTime(),
    },
  };
}
```

### Step 10: Migrations

```bash
# Create migration
pnpm prisma migrate dev --name init

# Apply in production
pnpm prisma migrate deploy
```

---

## üìñ TypeORM integration

TypeORM is a mature ORM with decorator-based entities and extensive features.

### Step 1: Install dependencies

```bash
pnpm add typeorm reflect-metadata better-sqlite3
pnpm add -D @types/better-sqlite3
```

### Step 2: Define entities

```typescript
// src/database/entities/User.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, OneToMany } from 'typeorm';
import { Post } from './Post';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column({ unique: true })
  email: string;

  @CreateDateColumn()
  createdAt: Date;

  @OneToMany(() => Post, post => post.user)
  posts: Post[];
}
```

```typescript
// src/database/entities/Post.ts
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne } from 'typeorm';
import { User } from './User';

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  userId: number;

  @Column()
  title: string;

  @Column()
  content: string;

  @CreateDateColumn()
  createdAt: Date;

  @ManyToOne(() => User, user => user.posts)
  user: User;
}
```

### Step 3: Create database module with factory functions

```typescript
// src/database/index.ts
import 'reflect-metadata';
import { DataSource } from 'typeorm';
import { User } from './entities/User';
import { Post } from './entities/Post';

// Internal singleton (private)
let _dataSource: DataSource | null = null;

/**
 * Get the TypeORM DataSource instance
 * 
 * Safe for use in:
 * - Job handlers
 * - Utility functions
 * - Worker processes
 * - Anywhere outside route handlers
 * 
 * @throws {Error} If called before DataSource is initialized
 */
export function getDataSource(): DataSource {
  if (!_dataSource) {
    throw new Error(
      'DataSource not initialized. ' +
      'Make sure you have registered the database plugin.'
    );
  }
  return _dataSource;
}

/**
 * Check if DataSource is initialized
 */
export function isDataSourceInitialized(): boolean {
  return _dataSource !== null && _dataSource.isInitialized;
}

/**
 * Initialize DataSource (called by plugin)
 * @internal
 */
export async function initializeDataSource(): Promise<void> {
  _dataSource = new DataSource({
    type: 'sqlite',
    database: './data.db',
    entities: [User, Post],
    synchronize: true, // Disable in production!
    logging: true,
  });
  
  await _dataSource.initialize();
}

/**
 * Close DataSource connection (called by plugin)
 * @internal
 */
export async function closeDataSource(): Promise<void> {
  if (_dataSource && _dataSource.isInitialized) {
    await _dataSource.destroy();
    _dataSource = null;
  }
}

// Export type
export type Database = DataSource;
```

### Step 4: Create database plugin

```typescript
// src/database/plugin.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { 
  getDataSource, 
  initializeDataSource, 
  closeDataSource,
  isDataSourceInitialized 
} from './index';
import type { Database } from './index';

interface DatabaseServices {
  db: Database;
}

export const createDatabasePlugin = () => {
  return createPlugin<{}, {}, DatabaseServices>({
    name: 'app-database',
    version: '1.0.0',

    setup: ({ logger }) => {
      const pluginLogger = logger.child({ plugin: 'database' });

      return {
        register: async server => {
          server.use(
            createMiddleware<{}, DatabaseServices>({
              name: 'database',
              handler: async (ctx, next) => {
                ctx.services.db = getDataSource(); // Use factory
                await next();
              },
            })
          );

          pluginLogger.info('Database middleware registered');
        },

        initialize: async () => {
          pluginLogger.info('Initializing TypeORM DataSource');
          await initializeDataSource(); // Only place to initialize
          pluginLogger.info('DataSource initialized');
        },

        onServerStart: async () => {
          pluginLogger.info('Database ready', {
            initialized: isDataSourceInitialized(),
          });
        },

        onServerStop: async () => {
          pluginLogger.info('Database stopping');
        },

        terminate: async () => {
          pluginLogger.info('Closing DataSource');
          await closeDataSource(); // Only place to destroy
          pluginLogger.info('DataSource closed');
        },
      };
    },
  });
};
```

### Step 5: Use in routes

```typescript
// src/routes/users/create.ts
import { createPostRoute } from 'blaizejs';
import { z } from 'zod';
import { User } from '../../database/entities/User';

const createUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    // Use ctx.services in routes
    const userRepository = ctx.services.db.getRepository(User);

    const user = userRepository.create({
      name: ctx.request.body.name,
      email: ctx.request.body.email,
    });

    await userRepository.save(user);

    return { success: true, user };
  },
});
```

### Step 6: Use in job handlers

```typescript
// src/queues/cleanup/old-sessions.ts
import { getDataSource } from '../../database';
import { Session } from '../../database/entities/Session';
import { LessThan } from 'typeorm';

export const cleanupOldSessions = createHandler(
  queues,
  'maintenance',
  'cleanup-sessions',
  async (data, ctx) => {
    // Use factory function in job handlers
    const dataSource = getDataSource();
    const sessionRepo = dataSource.getRepository(Session);
    
    const result = await sessionRepo.delete({
      expiresAt: LessThan(new Date()),
    });

    ctx.logger.info('Cleaned up old sessions', { 
      count: result.affected 
    });

    return { deletedCount: result.affected || 0 };
  }
);
```

### Step 7: Use in utility functions

```typescript
// src/lib/user-stats.ts
import { getDataSource } from '../database';
import { User } from '../database/entities/User';

export async function getUserStats(userId: number) {
  // Use factory function in utilities
  const dataSource = getDataSource();
  const userRepo = dataSource.getRepository(User);

  const user = await userRepo.findOne({
    where: { id: userId },
    relations: ['posts'],
  });

  if (!user) {
    return null;
  }

  return {
    user,
    stats: {
      totalPosts: user.posts.length,
      accountAge: Date.now() - user.createdAt.getTime(),
    },
  };
}
```

---

## üß™ Testing database integration

### Testing factory functions

```typescript
// test/database.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { 
  getDatabase, 
  isDatabaseInitialized,
  initializeDatabase,
  closeDatabase 
} from '../src/database';

describe('Database Factory Functions', () => {
  afterEach(async () => {
    if (isDatabaseInitialized()) {
      closeDatabase();
    }
  });

  it('should throw before initialization', () => {
    expect(() => getDatabase()).toThrow('Database not initialized');
    expect(isDatabaseInitialized()).toBe(false);
  });

  it('should return database after initialization', () => {
    initializeDatabase();
    
    expect(() => getDatabase()).not.toThrow();
    expect(isDatabaseInitialized()).toBe(true);
    
    const db = getDatabase();
    expect(db).toBeDefined();
  });

  it('should throw after cleanup', () => {
    initializeDatabase();
    const db = getDatabase();
    expect(db).toBeDefined();
    
    closeDatabase();
    
    expect(() => getDatabase()).toThrow('Database not initialized');
    expect(isDatabaseInitialized()).toBe(false);
  });
});
```

### Mocking database in route tests

```typescript
// test/routes/users.test.ts
import { vi } from 'vitest';
import { request } from 'supertest';

// Mock the factory function
vi.mock('../../database', () => ({
  getDatabase: vi.fn(() => mockDb),
  isDatabaseInitialized: vi.fn(() => true),
}));

const mockDb = {
  insert: vi.fn().mockReturnThis(),
  values: vi.fn().mockReturnThis(),
  returning: vi.fn().mockResolvedValue([{ 
    id: 1, 
    name: 'Test User', 
    email: 'test@example.com' 
  }]),
};

describe('POST /users', () => {
  it('should create a user', async () => {
    const response = await request(app)
      .post('/users')
      .send({
        name: 'Test User',
        email: 'test@example.com',
      });

    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(mockDb.insert).toHaveBeenCalled();
  });
});
```

---

## üöÄ Advanced patterns

### Real-time updates with EventBus

Combine database operations with EventBus for real-time coordination across your application.

**Use cases:**

- User notifications (new follower, new message)
- Real-time dashboards (sales updates, activity feeds)
- Cache invalidation across multiple servers
- SSE streaming (live updates to connected clients)

**Example with Drizzle:**

```typescript
// src/routes/users/create.ts
import { createPostRoute } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../database/schema';

const createUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    // Create user with Drizzle
    const [user] = await ctx.services.db
      .insert(users)
      .values({
        name: ctx.request.body.name,
        email: ctx.request.body.email,
      })
      .returning();

    // Publish event for real-time coordination
    await ctx.eventBus.publish('user:created', {
      userId: user.id,
      name: user.name,
      email: user.email,
      timestamp: Date.now(),
    });

    return { success: true, user };
  },
});
```

**SSE endpoint for real-time updates:**

```typescript
// src/routes/users/stream.ts
import { createSSERoute } from 'blaizejs';

export const userStream = createSSERoute({
  handler: async (stream, ctx) => {
    ctx.logger.info('Client connected to user stream');

    stream.send('connected', {
      message: 'Connected to user updates',
      timestamp: new Date().toISOString(),
    });

    // Subscribe to user events
    const unsubscribe = ctx.eventBus.subscribe('user:created', event => {
      stream.send('user-created', {
        user: event.data,
        timestamp: new Date(event.timestamp).toISOString(),
      });
    });

    // Heartbeat every 30 seconds
    const heartbeat = setInterval(() => {
      stream.send('heartbeat', {
        timestamp: new Date().toISOString(),
      });
    }, 30000);

    // Cleanup on disconnect
    stream.onClose(() => {
      ctx.logger.info('Client disconnected from user stream');
      unsubscribe();
      clearInterval(heartbeat);
    });
  },
});
```

### Database helpers with automatic events

Create helper functions that combine database operations with automatic event emission:

```typescript
// src/database/helpers.ts
import { getDatabase } from './index';
import { users } from './schema';
import { eq } from 'drizzle-orm';
import type { NewUser, User } from './schema';
import type { EventBus } from 'blaizejs';

export function createDatabaseHelpers(eventBus: EventBus) {
  return {
    users: {
      async create(data: NewUser): Promise<User> {
        const db = getDatabase(); // Use factory function
        const [user] = await db.insert(users).values(data).returning();

        await eventBus.publish('user:created', {
          userId: user.id,
          data: user,
        });

        return user;
      },

      async update(id: number, data: Partial<NewUser>): Promise<User> {
        const db = getDatabase();
        const [user] = await db
          .update(users)
          .set(data)
          .where(eq(users.id, id))
          .returning();

        await eventBus.publish('user:updated', {
          userId: id,
          data: user,
        });

        return user;
      },

      async delete(id: number): Promise<void> {
        const db = getDatabase();
        await db.delete(users).where(eq(users.id, id));

        await eventBus.publish('user:deleted', {
          userId: id,
        });
      },
    },

    // Raw database access when needed
    get db() {
      return getDatabase();
    },
  };
}
```

**Update plugin to inject helpers:**

```typescript
register: async server => {
  const dbWithHelpers = createDatabaseHelpers(server.eventBus);

  server.use(
    createMiddleware<{}, { db: ReturnType<typeof createDatabaseHelpers> }>({
      name: 'database',
      handler: async (ctx, next) => {
        ctx.services.db = dbWithHelpers;
        await next();
      },
    })
  );
};
```

**Use in routes:**

```typescript
export const createUser = createPostRoute({
  schema: {
    body: createUserSchema,
  },
  handler: async ctx => {
    // Helper automatically emits event
    const user = await ctx.services.db.users.create({
      name: ctx.request.body.name,
      email: ctx.request.body.email,
    });

    return { success: true, user };
  },
});
```

### Transaction support

Handle multi-step operations atomically:

```typescript
// src/routes/posts/create.ts
import { createPostRoute, NotFoundError } from 'blaizejs';
import { z } from 'zod';
import { posts, users } from '../../database/schema';
import { eq } from 'drizzle-orm';

const createPostSchema = z.object({
  userId: z.number(),
  title: z.string().min(1).max(200),
  content: z.string().min(1),
});

export const createPost = createPostRoute({
  schema: {
    body: createPostSchema,
  },
  handler: async ctx => {
    // Use Drizzle's transaction API
    const result = await ctx.services.db.transaction(async tx => {
      // Verify user exists
      const [user] = await tx
        .select()
        .from(users)
        .where(eq(users.id, ctx.request.body.userId))
        .limit(1);

      if (!user) {
        throw new NotFoundError('User not found');
      }

      // Create post
      const [post] = await tx
        .insert(posts)
        .values({
          userId: ctx.request.body.userId,
          title: ctx.request.body.title,
          content: ctx.request.body.content,
        })
        .returning();

      return { user, post };
    });

    // Transaction committed - emit event AFTER success
    await ctx.eventBus.publish('post:created', {
      postId: result.post.id,
      userId: result.user.id,
      data: result.post,
    });

    return { success: true, post: result.post };
  },
});
```

**Key points:**

- All operations in transaction are atomic
- Emit events AFTER transaction commits
- If transaction fails, no events are emitted

### Multi-server coordination

Use EventBus with Redis adapter for cache invalidation across multiple servers:

```typescript
// Server setup with Redis EventBus
import { createServer } from 'blaizejs';
import { createRedisClient, RedisEventBusAdapter } from '@blaizejs/adapter-redis';

const redisClient = createRedisClient({
  host: 'localhost',
  port: 6379,
});

const redisAdapter = new RedisEventBusAdapter(redisClient);

const server = createServer({
  serverId: process.env.SERVER_ID || 'server-1',
  routesDir: './src/routes',
})
  .register(createDatabasePlugin())
  .register(createCachePlugin());

// Attach Redis adapter to EventBus
await server.eventBus.setAdapter(redisAdapter);

await server.listen(3000);
```

**Update user route:**

```typescript
// src/routes/users/[userId]/update.ts
import { createPutRoute } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../../database/schema';
import { eq } from 'drizzle-orm';

const updateUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const updateUser = createPutRoute({
  schema: {
    params: z.object({ userId: z.string() }),
    body: updateUserSchema,
  },
  handler: async (ctx, params) => {
    const userId = parseInt(params.userId);

    // Update user in database
    const [user] = await ctx.services.db
      .update(users)
      .set({
        name: ctx.request.body.name,
        email: ctx.request.body.email,
      })
      .where(eq(users.id, userId))
      .returning();

    // Publish event - propagates to ALL servers via Redis
    await ctx.eventBus.publish('user:updated', {
      userId,
      data: user,
    });

    return { success: true, user };
  },
});
```

**All servers subscribe to invalidate cache:**

```typescript
server.eventBus.subscribe('user:updated', async event => {
  // This runs on ALL servers
  await ctx.services.cache.delete(`user:${event.data.userId}`);
  console.log(`[${server.serverId}] Cache invalidated for user ${event.data.userId}`);
});
```

**How it works:**

- Without Redis adapter: Events only on current server
- With Redis adapter: Events propagate to all servers
- Each server independently invalidates its cache
- Ensures cache consistency across your cluster

---

## üêõ Troubleshooting

### "Property 'db' does not exist on type 'Services'"

**Cause:** TypeScript doesn't know about your database service.

**Solution:** Ensure your plugin defines the services interface:

```typescript
interface DatabaseServices {
  db: Database;
}

createPlugin<{}, {}, DatabaseServices>({ ... })
```

And ensure your middleware uses the same type:

```typescript
createMiddleware<{}, DatabaseServices>({ ... })
```

---

### "Database not initialized" error

**Cause:** Factory function called before plugin's `initialize()` hook ran.

**Solutions:**

1. Ensure plugin is registered: `server.register(createDatabasePlugin())`
2. Ensure code runs after `server.listen()` for development scripts
3. In tests, ensure factory is mocked

**Example test setup:**
```typescript
vi.mock('../database', () => ({
  getDatabase: vi.fn(() => mockDb),
  isDatabaseInitialized: vi.fn(() => true),
}));
```

---

### "Database connection closed" errors

**Cause:** Database disconnected before request completed.

**Solution:** Ensure `terminate` hook is only called on shutdown:

```typescript
terminate: async () => {
  // Only runs when server.close() is called
  closeDatabase();
};
```

---

### Middleware not injecting database

**Cause:** Middleware registered in wrong lifecycle hook.

**Solution:** Register middleware in `register` hook:

```typescript
// ‚úÖ Correct
return {
  register: async (server) => {
    server.use(middleware);
  },
}

// ‚ùå Wrong - server not available in setup body
setup: ({ logger }) => {
  server.use(middleware); // Error!
  return { ... };
}
```

---

### TypeScript types not working

**Cause:** Database type not exported or imported correctly.

**Solution:**

```typescript
// Export type from database module
export type Database = typeof db;

// Import in plugin
import type { Database } from './index';

// Use in services interface
interface DatabaseServices {
  db: Database;
}
```

---

### "TypeError: getDatabase is not a function"

**Cause:** Import path is incorrect.

**Solution:**
```typescript
// ‚úÖ Correct
import { getDatabase } from '../../database';

// ‚ùå Wrong (old pattern)
import { db } from '../../database';
```

---

## ‚ö° Performance tips

### Connection pooling

**For PostgreSQL with Drizzle:**

```typescript
import { Pool } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';
import * as schema from './schema';

let _pool: Pool | null = null;
let _db: Database | null = null;

export function getDatabase(): Database {
  if (!_db) throw new Error('Database not initialized');
  return _db;
}

export function initializeDatabase(): void {
  _pool = new Pool({
    host: 'localhost',
    port: 5432,
    database: 'mydb',
    user: 'postgres',
    password: 'password',
    max: 20, // Maximum connections
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
  });

  _db = drizzle(_pool, { schema });
}

export function closeDatabase(): void {
  if (_pool) {
    _pool.end();
    _pool = null;
  }
  _db = null;
}
```

### Query optimization

**Select specific columns:**

```typescript
import { users } from './schema';

// ‚ùå Don't select everything
const allUsers = await ctx.services.db.select().from(users);

// ‚úÖ Select only needed columns
const userNames = await ctx.services.db
  .select({
    id: users.id,
    name: users.name,
  })
  .from(users);
```

**Use prepared statements:**

```typescript
import { users } from './schema';
import { eq, sql } from 'drizzle-orm';

// Drizzle automatically uses prepared statements
const getUserById = ctx.services.db
  .select()
  .from(users)
  .where(eq(users.id, sql.placeholder('id')))
  .prepare();

// Reuse prepared statement efficiently
const user1 = await getUserById.execute({ id: 1 });
const user2 = await getUserById.execute({ id: 2 });
```

### Caching strategies

**Cache frequently accessed data:**

```typescript
import { createGetRoute, NotFoundError } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../database/schema';
import { eq } from 'drizzle-orm';

export const getUser = createGetRoute({
  schema: {
    params: z.object({ userId: z.string() }),
  },
  handler: async (ctx, params) => {
    const cacheKey = `user:${params.userId}`;

    // Check cache first
    let user = await ctx.services.cache.get(cacheKey);

    if (!user) {
      // Cache miss - query database
      const [dbUser] = await ctx.services.db
        .select()
        .from(users)
        .where(eq(users.id, parseInt(params.userId)))
        .limit(1);

      if (dbUser) {
        // Store in cache for 5 minutes
        await ctx.services.cache.set(cacheKey, JSON.stringify(dbUser), 300);
        user = dbUser;
      }
    } else {
      user = JSON.parse(user);
    }

    if (!user) {
      throw new NotFoundError('User not found');
    }

    return { success: true, user };
  },
});
```

**Invalidate cache on update:**

```typescript
import { createPutRoute } from 'blaizejs';
import { z } from 'zod';
import { users } from '../../database/schema';
import { eq } from 'drizzle-orm';

const updateUserSchema = z.object({
  name: z.string().min(2).max(100),
  email: z.string().email(),
});

export const updateUser = createPutRoute({
  schema: {
    params: z.object({ userId: z.string() }),
    body: updateUserSchema,
  },
  handler: async (ctx, params) => {
    const userId = parseInt(params.userId);

    // Update database
    const [user] = await ctx.services.db
      .update(users)
      .set(ctx.request.body)
      .where(eq(users.id, userId))
      .returning();

    // Invalidate cache
    await ctx.services.cache.delete(`user:${userId}`);

    // Emit event for multi-server coordination
    await ctx.eventBus.publish('user:updated', { userId });

    return { success: true, user };
  },
});
```

---

## üîó Related documentation

- [Plugin system](./plugins) ‚Äî Deep dive into plugin architecture with factory functions
- [EventBus](./eventbus) ‚Äî Real-time event coordination
- [Server-Sent Events](./sse) ‚Äî Real-time updates to clients
- [Middleware](./middleware) ‚Äî Request/response processing

---

## ‚úÖ Summary

You've learned:

- ‚úÖ How to create a database plugin with lifecycle management
- ‚úÖ How to export factory functions for safe service access
- ‚úÖ How to inject services with full type safety
- ‚úÖ How to use database in routes, jobs, and utilities
- ‚úÖ How to handle connections and cleanup properly
- ‚úÖ How to publish events for real-time updates
- ‚úÖ How to coordinate across multiple servers
- ‚úÖ How to optimize queries and implement caching

**This same pattern works for any external service** ‚Äî Redis, message queues, search engines, or custom integrations. You now have the power to integrate anything into BlaizeJS!

---

**Next steps:**

1. Choose your ORM ([Drizzle](#drizzle-integration) recommended)
2. Follow the integration guide
3. Add real-time updates with EventBus
4. Implement caching for performance
5. Deploy with confidence!