# ğŸ”Œ Plugins Guide

> Manage expensive resources with lifecycle hooksâ€”connect once at startup, clean up at shutdown, provide typed access everywhere through middleware and factory functions

Plugins are BlaizeJS's answer to resource management. While middleware runs on every request, plugins handle the heavy lifting: database connections, cache clients, external servicesâ€”anything that's expensive to create and needs proper cleanup. Plugins provide **two access patterns**: `ctx.services` for route handlers and factory functions for job handlers, utilities, and worker processes.

---

## ğŸ“‹ Table of Contents

- [What is a Plugin?](#-what-is-a-plugin)
- [Plugins vs Middleware](#-plugins-vs-middleware)
- [Your First Plugin](#-your-first-plugin)
- [Understanding Service Access](#-understanding-service-access)
- [Understanding the Lifecycle](#-understanding-the-lifecycle)
- [Type-Safe Plugins](#-type-safe-plugins)
- [Common Patterns](#-common-patterns)
- [Configuration](#-configuration)
- [Adding Routes from Plugins](#-adding-routes-from-plugins)
- [Advanced Patterns](#-advanced-patterns)
- [Testing Plugins](#-testing-plugins)
- [Best Practices](#-best-practices)

---

## ğŸ¯ What is a Plugin?

A plugin is a reusable module that **manages resources with lifecycle hooks**. Think of plugins as the infrastructure layer of your application:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Application Startup                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Plugin setup() runs                      â”‚
â”‚  2. Plugin register() adds middleware        â”‚
â”‚  3. Plugin initialize() connects resources   â”‚
â”‚  4. Server starts listening                  â”‚
â”‚  5. Plugin onServerStart() verifies setup    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Requests Processing                â”‚
â”‚  â†’ Middleware provides ctx.services access   â”‚
â”‚  â†’ Factory functions provide direct access   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Application Shutdown               â”‚
â”‚  1. Plugin onServerStop() stops new work     â”‚
â”‚  2. Plugin terminate() cleans up             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Common plugin use cases:**
- ğŸ—„ï¸ Database connection pools
- ğŸ’¾ Redis/cache clients
- ğŸ“§ Email service connections
- ğŸ“Š Metrics collection
- âš™ï¸ Background job queues
- ğŸ” Search service clients
- ğŸ“¦ Storage service clients (S3, R2)

---

## ğŸ¤” Plugins vs Middleware

This is the **most important decision** to understand:

| Need | Use Middleware | Use Plugin |
|------|----------------|------------|
| Run logic on every request | âœ… | âŒ |
| Connect to database once | âŒ | âœ… |
| Add data to `ctx.state` | âœ… | Via middleware |
| Manage connection pools | âŒ | âœ… |
| Validate authentication | âœ… | âŒ |
| Clean up on server shutdown | âŒ | âœ… |
| Add routes dynamically | âŒ | âœ… |

### The Key Difference

**Middleware** runs on **every request** â€” it's for per-request logic:
- Authentication
- Logging
- Rate limiting
- Request validation

**Plugins** run **once at startup/shutdown** â€” they're for managing expensive resources:
- Database connections
- Cache clients
- External service connections
- Background workers

### Example: The Wrong Way vs The Right Way

```typescript
// âŒ WRONG: Creating connection on every request
const dbMiddleware = createMiddleware({
  handler: async ({ ctx, next }) => {
    // Connect on EVERY REQUEST â€” Expensive!
    ctx.services.db = await Database.connect();
    
    await next();
    
    // Close on EVERY REQUEST â€” Wasteful!
    await ctx.services.db.close();
  },
});
```

```typescript
// âœ… CORRECT: Plugin connects once, factory provides safe access
// Internal singleton (private)
let _db: Database | null = null;

// Factory function for external access (public)
export function getDatabase(): Database {
  if (!_db) {
    throw new Error(
      'Database not initialized. ' +
      'Make sure you have registered the database plugin.'
    );
  }
  return _db;
}

const databasePlugin = createPlugin<
  { connectionString: string }, // Config
  {},                           // State (usually empty)
  { db: Database }             // Services
>({
  name: 'database',
  version: '1.0.0',
  
  setup: ({ config }) => {
    return {
      register: async (server) => {
        // Middleware provides reference via factory
        server.use(
          createMiddleware<{}, { db: Database }>({
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase(); // Use factory
              await next();
            },
          })
        );
      },
      
      initialize: async () => {
        // Connect ONCE at startup (only place to assign _db)
        _db = await Database.connect(config.connectionString);
      },
      
      terminate: async () => {
        // Clean up ONCE at shutdown
        const db = getDatabase();
        await db.close();
        _db = null; // Only place to clear _db
      },
    };
  },
});
```

---

## ğŸš€ Your First Plugin

Let's create a simple plugin that manages a Redis connection:

```typescript
// src/plugins/redis.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { Redis } from 'ioredis';

interface RedisConfig {
  url: string;
  maxRetries?: number;
}

// 1ï¸âƒ£ Internal singleton (private)
let _redis: Redis | null = null;

// 2ï¸âƒ£ Factory function for external access (public)
/**
 * Get the Redis instance
 * 
 * Safe for use in:
 * - Job handlers
 * - Utility functions
 * - Worker processes
 * - Anywhere outside route handlers
 * 
 * @throws {Error} If called before Redis plugin is initialized
 * 
 * @example In job handlers
 * ```typescript
 * import { getRedis } from '../../plugins/redis';
 * 
 * export const cacheWarmer = createHandler(queues, 'maintenance', 'cache-warm',
 *   async (data, ctx) => {
 *     const redis = getRedis();
 *     await redis.set('cache:key', value);
 *   }
 * );
 * ```
 */
export function getRedis(): Redis {
  if (!_redis) {
    throw new Error(
      'Redis not initialized. ' +
      'Make sure you have registered the Redis plugin.'
    );
  }
  return _redis;
}

// 3ï¸âƒ£ Optional initialization check
export function isRedisInitialized(): boolean {
  return _redis !== null;
}

// 4ï¸âƒ£ Plugin factory
export const createRedisPlugin = createPlugin<
  RedisConfig,      // Config type
  {},               // State (none)
  { redis: Redis }  // Services (what we provide)
>({
  name: 'redis',
  version: '1.0.0',
  
  // Default configuration
  defaultConfig: {
    url: 'redis://localhost:6379',
    maxRetries: 3,
  },
  
  setup: ({ config, logger }) => {
    return {
      // 5ï¸âƒ£ Register middleware for typed access in routes
      register: async (server) => {
        logger.debug('Registering Redis middleware');
        
        server.use(
          createMiddleware<{}, { redis: Redis }>({
            name: 'redis',
            handler: async ({ ctx, next }) => {
              ctx.services.redis = getRedis(); // Use factory
              await next();
            },
          })
        );
      },
      
      // 6ï¸âƒ£ Initialize resource (only place to assign _redis)
      initialize: async () => {
        logger.info('Connecting to Redis', { url: config.url });
        
        _redis = new Redis(config.url, {
          maxRetriesPerRequest: config.maxRetries,
        });
        
        // Verify connection
        await _redis.ping();
        logger.info('Redis connected');
      },
      
      // 7ï¸âƒ£ Clean up resource (only place to clear _redis)
      terminate: async () => {
        logger.info('Disconnecting from Redis');
        const redis = getRedis();
        await redis.quit();
        _redis = null;
        logger.info('Redis disconnected');
      },
    };
  },
});
```

**Add it to your server:**

```typescript
// src/app.ts
import { Blaize } from 'blaizejs';
import { createRedisPlugin } from './plugins/redis';

const server = Blaize.createServer({
  port: 7485,
  routesDir: './src/routes',
  plugins: [
    createRedisPlugin({
      url: 'redis://localhost:6379',
    }),
  ],
});

await server.listen();
```

**Use it in routes:**

```typescript
// src/routes/cache.ts
import { route } from '../app';

export const getCachedValue = route.get({
  handler: async ({ ctx }) => {
    // TypeScript knows redis is available via ctx.services!
    const value = await ctx.services.redis.get('my-key');
    return { value };
  },
});
```

**Use it in job handlers:**

```typescript
// src/queues/cache-warmer.ts
import { getRedis } from '../plugins/redis';

export const cacheWarmer = createHandler(queues, 'maintenance', 'cache-warm',
  async (data, ctx) => {
    // Use factory function outside routes
    const redis = getRedis();
    await redis.set('cache:key', data.value);
  }
);
```

---

## ğŸ”‘ Understanding Service Access

BlaizeJS plugins provide **two ways** to access services, each optimized for different contexts:

| Context | Access Method | Example |
|---------|---------------|---------|
| **Route handlers** | `ctx.services.serviceName` | `await ctx.services.redis.get(...)` |
| **Job handlers** | `getServiceName()` | `const redis = getRedis()` |
| **Utility functions** | `getServiceName()` | `const redis = getRedis()` |
| **Worker processes** | `getServiceName()` | `const redis = getRedis()` |
| **Plugin internals** | `getServiceName()` | Use for consistency |

### Why Two Patterns?

**Route handlers** receive context via middleware â†’ use `ctx.services.serviceName`

**Everything else** doesn't have context â†’ use factory functions

```typescript
// âœ… In route handlers - use ctx.services
export const POST = createRoute({
  handler: async ({ ctx }) => {
    const value = await ctx.services.redis.get('key');
    return { value };
  }
});

// âœ… In job handlers - use factory function
import { getRedis } from '../../plugins/redis';

export const processJob = createHandler(queues, 'jobs', 'process',
  async (data, ctx) => {
    const redis = getRedis();
    await redis.set('result', data.result);
  }
);

// âœ… In utility functions - use factory function
import { getRedis } from '../plugins/redis';

export async function getCachedUser(userId: string) {
  const redis = getRedis();
  const cached = await redis.get(`user:${userId}`);
  return cached ? JSON.parse(cached) : null;
}
```

### Factory Function Benefits

1. **Clear error messages** â€” "Redis not initialized..." instead of "Cannot read property of null"
2. **Explicit intent** â€” `getRedis()` shows you're retrieving a service
3. **Easy testing** â€” Mock the factory function, not the instance
4. **Safety checks** â€” Factory verifies initialization state
5. **Consistency** â€” Same pattern across all plugins

### Naming Conventions

Follow these patterns for consistency:

| Service Type | Factory Function | Check Function | Private Variable |
|--------------|------------------|----------------|------------------|
| `Database` | `getDatabase()` | `isDatabaseInitialized()` | `_db` |
| `Redis` | `getRedis()` | `isRedisInitialized()` | `_redis` |
| `EmailService` | `getEmailService()` | `isEmailServiceInitialized()` | `_emailService` |
| `CacheService` | `getCacheService()` | `isCacheServiceInitialized()` | `_cache` |
| `QueueService` | `getQueueService()` | `isQueueServiceInitialized()` | `_queueService` |

**Pattern:** `get[ServiceName]()` where ServiceName is PascalCase

---

## ğŸ”„ Understanding the Lifecycle

Plugins have **five lifecycle hooks** that run at specific times:

| Hook | When It Runs | Use For | Required |
|------|--------------|---------|----------|
| `register` | During `server.register()` | Adding middleware, routes | âœ… Yes |
| `initialize` | Before `server.listen()` | Connecting to resources | âŒ No |
| `onServerStart` | After server is listening | Verifying connections | âŒ No |
| `onServerStop` | When server begins shutdown | Stopping new work | âŒ No |
| `terminate` | During server shutdown | Closing connections | âŒ No |

### Lifecycle Execution Order

```
Server Startup:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ createServer() called               â”‚
  â”‚  â†“                                  â”‚
  â”‚ plugin1.register() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
  â”‚ plugin2.register() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ plugin3.register() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
  â”‚  â†“                                  â”‚
  â”‚ server.listen() called              â”‚
  â”‚  â†“                                  â”‚
  â”‚ plugin1.initialize() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
  â”‚ plugin2.initialize() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ plugin3.initialize() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
  â”‚  â†“                                  â”‚
  â”‚ Server starts listening             â”‚
  â”‚  â†“                                  â”‚
  â”‚ plugin1.onServerStart() â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
  â”‚ plugin2.onServerStart() â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ plugin3.onServerStart() â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Server Shutdown (REVERSE ORDER):
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ server.close() called               â”‚
  â”‚  â†“                                  â”‚
  â”‚ plugin3.onServerStop() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
  â”‚ plugin2.onServerStop() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ plugin1.onServerStop() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
  â”‚  â†“                                  â”‚
  â”‚ plugin3.terminate() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
  â”‚ plugin2.terminate() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ plugin1.terminate() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why reverse order for shutdown?** Resources registered last may depend on resources registered first. Shutting down in reverse ensures dependencies are available during cleanup.

### Lifecycle Hook Examples

```typescript
// Internal singleton
let _pool: ConnectionPool | null = null;

// Factory function
export function getDatabase(): ConnectionPool {
  if (!_pool) {
    throw new Error('Database not initialized.');
  }
  return _pool;
}

const databasePlugin = createPlugin<DatabaseConfig, {}, { db: Database }>({
  name: 'database',
  version: '1.0.0',
  
  setup: ({ config, logger }) => {
    return {
      // 1. REGISTER - Add middleware to server
      register: async (server) => {
        server.use(
          createMiddleware<{}, { db: Database }>({
            name: 'database',
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase(); // Use factory
              await next();
            },
          })
        );
        
        logger.debug('Database middleware registered');
      },
      
      // 2. INITIALIZE - Connect to resources (ONLY place to assign _pool)
      initialize: async () => {
        logger.info('Creating database pool...');
        
        _pool = await ConnectionPool.create({
          host: config.host,
          port: config.port,
          max: config.poolSize,
        });
        
        logger.info('Database pool created');
      },
      
      // 3. ON_SERVER_START - Verify everything works
      onServerStart: async () => {
        const pool = getDatabase();
        await pool.query('SELECT 1'); // Health check
        logger.info('Database connection verified');
      },
      
      // 4. ON_SERVER_STOP - Stop accepting new work
      onServerStop: async () => {
        const pool = getDatabase();
        pool.stopAcceptingQueries();
        logger.info('Draining database connections...');
      },
      
      // 5. TERMINATE - Clean up resources (ONLY place to clear _pool)
      terminate: async () => {
        const pool = getDatabase();
        await pool.close();
        _pool = null;
        logger.info('Database pool closed');
      },
    };
  },
});
```

---

## ğŸ¨ Type-Safe Plugins

BlaizeJS plugins support full type compositionâ€”your routes automatically know what services are available.

### Plugin Type Parameters

```typescript
createPlugin<TConfig, TState, TServices>({ ... })
```

| Generic | Purpose | Typical Usage |
|---------|---------|---------------|
| `TConfig` | Shape of configuration options | `{ host: string; port: number }` |
| `TState` | What plugin adds to `ctx.state` | Usually `{}` â€” plugins rarely add state |
| `TServices` | What plugin adds to `ctx.services` | `{ db: Database; cache: Cache }` |

### Type Flow Example

```typescript
// 1. Define types
interface CacheConfig {
  maxSize: number;
  ttl: number;
}

interface CacheService {
  get(key: string): Promise<unknown | null>;
  set(key: string, value: unknown, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
}

// 2. Internal singleton + factory
let _cache: CacheService | null = null;

export function getCacheService(): CacheService {
  if (!_cache) {
    throw new Error('Cache not initialized.');
  }
  return _cache;
}

// 3. Create typed plugin
const cachePlugin = createPlugin<
  CacheConfig,              // Config
  {},                       // State (none)
  { cache: CacheService }   // Services
>({
  name: 'cache',
  version: '1.0.0',
  
  defaultConfig: {
    maxSize: 1000,
    ttl: 3600,
  },
  
  setup: ({ config, logger }) => {
    return {
      register: async (server) => {
        server.use(
          createMiddleware<{}, { cache: CacheService }>({
            name: 'cache',
            handler: async ({ ctx, next }) => {
              ctx.services.cache = getCacheService(); // Use factory
              await next();
            },
          })
        );
      },
      
      initialize: async () => {
        _cache = new CacheService(config);
      },
      
      terminate: async () => {
        const cache = getCacheService();
        await cache.cleanup();
        _cache = null;
      },
    };
  },
});

// 4. Register plugin
const app = Blaize.createServer().register(cachePlugin({ maxSize: 5000 }));

// 5. Extract types
type AppContext = InferContext<typeof app>;
// AppContext['services'] = { cache: CacheService }

// 6. Routes get types automatically
export const GET = route.get({
  handler: async ({ ctx }) => {
    // TypeScript knows cache is available!
    const value = await ctx.services.cache.get('key');
    return { value };
  },
});
```

### Multiple Plugins Compose Types

```typescript
const server = Blaize.createServer()
  .register(databasePlugin({ host: 'localhost' }))
  .register(cachePlugin({ maxSize: 1000 }))
  .register(queuePlugin({ queues: {} }));

type AppContext = InferContext<typeof server>;

// AppContext['services'] = {
//   db: Database;
//   cache: CacheService;
//   queue: QueueService;
// }

// All routes see all services!
export const GET = route.get({
  handler: async ({ ctx }) => {
    ctx.services.db;    // âœ… Database
    ctx.services.cache; // âœ… CacheService
    ctx.services.queue; // âœ… QueueService
  },
});
```

---

## ğŸ’¡ Common Patterns

### Pattern: Database Connection Pool

```typescript
// plugins/database.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { Pool } from 'pg';

interface DatabaseConfig {
  connectionString: string;
  poolSize?: number;
}

// Internal singleton
let _pool: Pool | null = null;

// Factory function
export function getDatabase(): Pool {
  if (!_pool) {
    throw new Error(
      'Database not initialized. ' +
      'Make sure you have registered the database plugin.'
    );
  }
  return _pool;
}

export function isDatabaseInitialized(): boolean {
  return _pool !== null;
}

export const createDatabasePlugin = createPlugin<
  DatabaseConfig,
  {},
  { db: Pool }
>({
  name: 'database',
  version: '1.0.0',
  
  defaultConfig: {
    connectionString: 'postgresql://localhost:5432/app',
    poolSize: 10,
  },
  
  setup: ({ config, logger }) => {
    return {
      register: async (server) => {
        server.use(
          createMiddleware<{}, { db: Pool }>({
            name: 'database',
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase(); // Use factory
              await next();
            },
          })
        );
      },
      
      initialize: async () => {
        logger.info('Creating database pool', {
          poolSize: config.poolSize,
        });
        
        _pool = new Pool({
          connectionString: config.connectionString,
          max: config.poolSize,
        });
        
        // Verify connection
        const client = await _pool.connect();
        await client.query('SELECT 1');
        client.release();
        
        logger.info('Database pool created');
      },
      
      onServerStart: async () => {
        // Run migrations or verify schema
        logger.info('Database ready');
      },
      
      onServerStop: async () => {
        // Stop accepting new queries
        logger.info('Draining database connections...');
      },
      
      terminate: async () => {
        const pool = getDatabase();
        await pool.end();
        _pool = null;
        logger.info('Database pool closed');
      },
    };
  },
});
```

**Usage in routes:**
```typescript
const server = Blaize.createServer({
  plugins: [
    createDatabasePlugin({
      connectionString: process.env.DATABASE_URL,
      poolSize: 20,
    }),
  ],
});

// In routes:
export const getUsers = route.get({
  handler: async ({ ctx }) => {
    // Use ctx.services in routes
    const result = await ctx.services.db.query('SELECT * FROM users');
    return { users: result.rows };
  },
});
```

**Usage in job handlers:**
```typescript
import { getDatabase } from '../plugins/database';

export const cleanupHandler = createHandler(queues, 'maintenance', 'cleanup',
  async (data, ctx) => {
    // Use factory function in jobs
    const db = getDatabase();
    await db.query('DELETE FROM sessions WHERE expires_at < NOW()');
  }
);
```

**Usage in utilities:**
```typescript
import { getDatabase } from '../plugins/database';

export async function getUserStats(userId: string) {
  // Use factory function in utilities
  const db = getDatabase();
  const result = await db.query(
    'SELECT COUNT(*) FROM user_actions WHERE user_id = $1',
    [userId]
  );
  return result.rows[0].count;
}
```

### Pattern: Redis Cache

```typescript
// plugins/cache.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import { Redis } from 'ioredis';

interface CacheConfig {
  url: string;
  ttl?: number;
}

interface CacheService {
  get(key: string): Promise<string | null>;
  set(key: string, value: string, ttl?: number): Promise<void>;
  del(key: string): Promise<void>;
}

// Internal singletons
let _redis: Redis | null = null;
let _cache: CacheService | null = null;

// Factory function
export function getCacheService(): CacheService {
  if (!_cache) {
    throw new Error('Cache not initialized.');
  }
  return _cache;
}

export const createCachePlugin = createPlugin<
  CacheConfig,
  {},
  { cache: CacheService }
>({
  name: 'cache',
  version: '1.0.0',
  
  defaultConfig: {
    url: 'redis://localhost:6379',
    ttl: 3600,
  },
  
  setup: ({ config, logger }) => {
    const cache: CacheService = {
      get: async (key) => {
        if (!_redis) throw new Error('Redis not initialized');
        return _redis.get(key);
      },
      
      set: async (key, value, ttl = config.ttl) => {
        if (!_redis) throw new Error('Redis not initialized');
        await _redis.setex(key, ttl, value);
      },
      
      del: async (key) => {
        if (!_redis) throw new Error('Redis not initialized');
        await _redis.del(key);
      },
    };
    
    return {
      register: async (server) => {
        server.use(
          createMiddleware<{}, { cache: CacheService }>({
            name: 'cache',
            handler: async ({ ctx, next }) => {
              ctx.services.cache = getCacheService();
              await next();
            },
          })
        );
      },
      
      initialize: async () => {
        logger.info('Connecting to Redis', { url: config.url });
        
        _redis = new Redis(config.url);
        
        // Wait for ready
        await new Promise((resolve) => _redis!.on('ready', resolve));
        
        _cache = cache;
        logger.info('Redis connected');
      },
      
      terminate: async () => {
        if (_redis) {
          await _redis.quit();
          _redis = null;
        }
        _cache = null;
        logger.info('Redis disconnected');
      },
    };
  },
});
```

### Pattern: Email Service

```typescript
// plugins/email.ts
import { createPlugin, createMiddleware } from 'blaizejs';
import nodemailer from 'nodemailer';

interface EmailConfig {
  host: string;
  port: number;
  user: string;
  pass: string;
  from: string;
}

interface EmailService {
  send(to: string, subject: string, body: string): Promise<void>;
}

// Internal singletons
let _transporter: nodemailer.Transporter | null = null;
let _emailService: EmailService | null = null;

// Factory function
export function getEmailService(): EmailService {
  if (!_emailService) {
    throw new Error('Email service not initialized.');
  }
  return _emailService;
}

export const createEmailPlugin = createPlugin<
  EmailConfig,
  {},
  { email: EmailService }
>({
  name: 'email',
  version: '1.0.0',
  
  setup: ({ config, logger }) => {
    const emailService: EmailService = {
      send: async (to, subject, body) => {
        if (!_transporter) throw new Error('Email transporter not initialized');
        
        logger.info('Sending email', { to, subject });
        
        await _transporter.sendMail({
          from: config.from,
          to,
          subject,
          html: body,
        });
        
        logger.info('Email sent', { to, subject });
      },
    };
    
    return {
      register: async (server) => {
        server.use(
          createMiddleware<{}, { email: EmailService }>({
            name: 'email',
            handler: async ({ ctx, next }) => {
              ctx.services.email = getEmailService();
              await next();
            },
          })
        );
      },
      
      initialize: async () => {
        logger.info('Creating email transporter');
        
        _transporter = nodemailer.createTransport({
          host: config.host,
          port: config.port,
          auth: {
            user: config.user,
            pass: config.pass,
          },
        });
        
        // Verify connection
        await _transporter.verify();
        
        _emailService = emailService;
        logger.info('Email service ready');
      },
      
      terminate: async () => {
        if (_transporter) {
          _transporter.close();
          _transporter = null;
        }
        _emailService = null;
        logger.info('Email service closed');
      },
    };
  },
});
```

### Pattern: Background Worker

```typescript
// plugins/worker.ts
import { createPlugin } from 'blaizejs';

interface WorkerConfig {
  interval: number;
  enabled?: boolean;
}

export const createWorkerPlugin = createPlugin<WorkerConfig, {}, {}>({
  name: 'worker',
  version: '1.0.0',
  
  defaultConfig: {
    interval: 60000, // 1 minute
    enabled: true,
  },
  
  setup: ({ config, logger }) => {
    let intervalId: NodeJS.Timeout | null = null;
    
    async function doWork() {
      logger.info('Worker running...');
      try {
        // Do background work here
        await processBackgroundTasks();
        logger.info('Worker completed');
      } catch (error) {
        logger.error('Worker failed', { error });
      }
    }
    
    return {
      onServerStart: async () => {
        if (!config.enabled) {
          logger.info('Worker disabled');
          return;
        }
        
        logger.info('Starting background worker', {
          interval: config.interval,
        });
        
        // Run immediately, then on interval
        await doWork();
        
        intervalId = setInterval(doWork, config.interval);
      },
      
      onServerStop: async () => {
        if (intervalId) {
          logger.info('Stopping background worker...');
          clearInterval(intervalId);
          intervalId = null;
          logger.info('Background worker stopped');
        }
      },
    };
  },
});
```

---

## âš™ï¸ Configuration

### Default Configuration

Plugins can provide default values:

```typescript
const plugin = createPlugin<{ port: number; host: string }, {}, {}>({
  name: 'api',
  version: '1.0.0',
  
  defaultConfig: {
    port: 3000,
    host: 'localhost',
  },
  
  setup: ({ config, logger }) => {
    logger.info('Config', {
      port: config.port,    // Always defined (from default or user)
      host: config.host,    // Always defined
    });
    
    return {};
  },
});

// Use defaults
const server = Blaize.createServer({
  plugins: [plugin()], // Uses port: 3000, host: 'localhost'
});

// Override some defaults
const server2 = Blaize.createServer({
  plugins: [
    plugin({ port: 8080 }), // port: 8080, host: 'localhost'
  ],
});
```

### Environment-Based Configuration

```typescript
const databasePlugin = createPlugin<DatabaseConfig, {}, { db: Pool }>({
  name: 'database',
  version: '1.0.0',
  
  defaultConfig: {
    connectionString: process.env.DATABASE_URL || 'postgresql://localhost:5432/app',
    poolSize: parseInt(process.env.DB_POOL_SIZE || '10', 10),
  },
  
  setup: ({ config }) => {
    // Config is already merged with env vars
    let pool: Pool;
    
    return {
      initialize: async () => {
        pool = new Pool({
          connectionString: config.connectionString,
          max: config.poolSize,
        });
      },
      
      terminate: async () => {
        await pool.end();
      },
    };
  },
});
```

---

## ğŸ›£ï¸ Adding Routes from Plugins

Plugins can add routes dynamically:

```typescript
// plugins/health.ts
import { createPlugin } from 'blaizejs';

export const createHealthPlugin = createPlugin<{}, {}, {}>({
  name: 'health',
  version: '1.0.0',
  
  setup: ({ logger }) => {
    return {
      register: async (server) => {
        logger.debug('Adding health check route');
        
        server.router.addRoute({
          path: '/health',
          GET: {
            handler: async ({ ctx }) => {
              return {
                status: 'ok',
                timestamp: Date.now(),
                uptime: process.uptime(),
              };
            },
          },
        });
        
        logger.info('Health check route added');
      },
    };
  },
});
```

### Adding Multiple Routes

```typescript
let _collector: MetricsCollector | null = null;

export function getMetricsCollector(): MetricsCollector {
  if (!_collector) {
    throw new Error('Metrics collector not initialized.');
  }
  return _collector;
}

const metricsPlugin = createPlugin<{ path?: string }, {}, {}>({
  name: 'metrics',
  version: '1.0.0',
  
  defaultConfig: {
    path: '/metrics',
  },
  
  setup: ({ config, logger }) => {
    return {
      register: async (server) => {
        // Metrics endpoint
        server.router.addRoute({
          path: config.path,
          GET: {
            handler: async ({ ctx }) => {
              const metrics = await getMetricsCollector().export();
              ctx.response.header('Content-Type', 'text/plain');
              return metrics;
            },
          },
        });
        
        // Debug endpoint
        server.router.addRoute({
          path: `${config.path}/debug`,
          GET: {
            handler: async ({ ctx }) => {
              return getMetricsCollector().getDebugInfo();
            },
          },
        });
      },
      
      initialize: async () => {
        _collector = new MetricsCollector();
        _collector.start();
      },
      
      terminate: async () => {
        const collector = getMetricsCollector();
        collector.stop();
        _collector = null;
      },
    };
  },
});
```

### Adding Route Directories

```typescript
const apiPlugin = createPlugin<{ prefix?: string }, {}, {}>({
  name: 'api',
  version: '1.0.0',
  
  defaultConfig: {
    prefix: '/api/v1',
  },
  
  setup: ({ config, logger }) => {
    return {
      initialize: async (server) => {
        logger.info('Loading API routes', { prefix: config.prefix });
        
        await server.router.addRouteDirectory('./api-routes', {
          prefix: config.prefix,
        });
        
        logger.info('API routes loaded');
      },
    };
  },
});
```

---

## ğŸš€ Advanced Patterns

### Pattern: Plugin with Health Checks

```typescript
interface HealthCheckable {
  name: string;
  check(): Promise<{ healthy: boolean; details?: any }>;
}

let _pool: Pool | null = null;

export function getDatabase(): Pool {
  if (!_pool) throw new Error('Database not initialized.');
  return _pool;
}

const databasePlugin = createPlugin<DatabaseConfig, {}, { db: Pool }>({
  name: 'database',
  version: '1.0.0',
  
  setup: ({ config, logger }) => {
    const healthCheck: HealthCheckable = {
      name: 'database',
      check: async () => {
        try {
          const pool = getDatabase();
          const client = await pool.connect();
          await client.query('SELECT 1');
          client.release();
          
          return {
            healthy: true,
            details: { poolSize: pool.totalCount },
          };
        } catch (error) {
          return {
            healthy: false,
            details: { error: error.message },
          };
        }
      },
    };
    
    return {
      register: async (server) => {
        // Register middleware
        server.use(
          createMiddleware<{}, { db: Pool }>({
            name: 'database',
            handler: async ({ ctx, next }) => {
              ctx.services.db = getDatabase();
              await next();
            },
          })
        );
        
        // Add health check route
        server.router.addRoute({
          path: '/health/database',
          GET: {
            handler: async ({ ctx }) => {
              const result = await healthCheck.check();
              
              if (!result.healthy) {
                ctx.response.status(503);
              }
              
              return result;
            },
          },
        });
      },
      
      initialize: async () => {
        _pool = new Pool({
          connectionString: config.connectionString,
        });
      },
      
      terminate: async () => {
        const pool = getDatabase();
        await pool.end();
        _pool = null;
      },
    };
  },
});
```

### Pattern: Plugin with Graceful Shutdown

```typescript
let _queueService: QueueService | null = null;

export function getQueueService(): QueueService {
  if (!_queueService) throw new Error('Queue not initialized.');
  return _queueService;
}

const queuePlugin = createPlugin<QueueConfig, {}, { queue: QueueService }>({
  name: 'queue',
  version: '1.0.0',
  
  setup: ({ config, logger }) => {
    let activeJobs = 0;
    
    return {
      register: async (server) => {
        server.use(
          createMiddleware<{}, { queue: QueueService }>({
            name: 'queue',
            handler: async ({ ctx, next }) => {
              ctx.services.queue = getQueueService();
              await next();
            },
          })
        );
      },
      
      initialize: async () => {
        _queueService = new QueueService(config);
        
        _queueService.on('job:start', () => {
          activeJobs++;
        });
        
        _queueService.on('job:complete', () => {
          activeJobs--;
        });
        
        await _queueService.start();
      },
      
      onServerStop: async () => {
        logger.info('Stopping queue (graceful)', { activeJobs });
        
        const queueService = getQueueService();
        
        // Stop accepting new jobs
        await queueService.pause();
        
        // Wait for active jobs to complete (with timeout)
        const timeout = 30000; // 30 seconds
        const start = Date.now();
        
        while (activeJobs > 0 && Date.now() - start < timeout) {
          logger.debug('Waiting for jobs to complete', { activeJobs });
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        if (activeJobs > 0) {
          logger.warn('Forcing shutdown with active jobs', { activeJobs });
        }
        
        logger.info('Queue stopped');
      },
      
      terminate: async () => {
        const queueService = getQueueService();
        await queueService.stop();
        _queueService = null;
      },
    };
  },
});
```

### Pattern: Plugin with Event Bus Integration

```typescript
let _analyticsClient: AnalyticsClient | null = null;

export function getAnalyticsClient(): AnalyticsClient {
  if (!_analyticsClient) throw new Error('Analytics not initialized.');
  return _analyticsClient;
}

const analyticsPlugin = createPlugin<AnalyticsConfig, {}, {}>({
  name: 'analytics',
  version: '1.0.0',
  
  setup: ({ config, logger }) => {
    return {
      initialize: async () => {
        _analyticsClient = new AnalyticsClient(config.apiKey);
      },
      
      onServerStart: async (server) => {
        logger.info('Subscribing to analytics events');
        
        const client = getAnalyticsClient();
        
        // Subscribe to event bus
        server.eventBus.subscribe('user:*', (event) => {
          client.track({
            event: event.type,
            userId: event.data.userId,
            timestamp: event.timestamp,
            metadata: event.data,
          });
        });
        
        server.eventBus.subscribe('order:*', (event) => {
          client.track({
            event: event.type,
            orderId: event.data.orderId,
            timestamp: event.timestamp,
            revenue: event.data.total,
          });
        });
      },
      
      terminate: async () => {
        const client = getAnalyticsClient();
        await client.flush();
        await client.close();
        _analyticsClient = null;
      },
    };
  },
});
```

### Pattern: Conditional Plugin Features

```typescript
const featureFlagsPlugin = createPlugin<
  { features: Record<string, boolean> },
  { features: Record<string, boolean> },
  {}
>({
  name: 'feature-flags',
  version: '1.0.0',
  
  defaultConfig: {
    features: {},
  },
  
  setup: ({ config, logger }) => {
    return {
      register: async (server) => {
        // Add middleware to expose features
        server.use(
          createMiddleware<{ features: Record<string, boolean> }, {}>({
            name: 'feature-flags',
            handler: async ({ ctx, next }) => {
              ctx.state.features = { ...config.features };
              await next();
            },
          })
        );
        
        // Conditionally add debug routes
        if (config.features.debugRoutes) {
          logger.info('Adding debug routes (feature flag enabled)');
          
          server.router.addRoute({
            path: '/debug/features',
            GET: {
              handler: async ({ ctx }) => {
                return { features: config.features };
              },
            },
          });
        }
      },
    };
  },
});
```

---

## ğŸ§ª Testing Plugins

### Testing Factory Functions

The factory function pattern makes testing easy:

```typescript
// plugins/redis.test.ts
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { createRedisPlugin, getRedis, isRedisInitialized } from './redis';

describe('Redis Plugin', () => {
  let plugin: ReturnType<typeof createRedisPlugin>;
  
  beforeEach(() => {
    plugin = createRedisPlugin({
      url: 'redis://localhost:6379',
    });
  });
  
  afterEach(async () => {
    // Clean up
    if (plugin.terminate) {
      await plugin.terminate({} as any);
    }
  });
  
  it('should throw before initialization', () => {
    expect(() => getRedis()).toThrow('Redis not initialized');
    expect(isRedisInitialized()).toBe(false);
  });
  
  it('should register middleware', async () => {
    const server = {
      use: vi.fn(),
      router: { addRoute: vi.fn() },
    };
    
    await plugin.register(server as any);
    
    expect(server.use).toHaveBeenCalledTimes(1);
  });
  
  it('should initialize Redis connection', async () => {
    const server = { eventBus: {} };
    
    await plugin.register(server as any);
    await plugin.initialize?.(server as any);
    
    // Factory should now work
    expect(() => getRedis()).not.toThrow();
    expect(isRedisInitialized()).toBe(true);
  });
  
  it('should handle initialization errors', async () => {
    const badPlugin = createRedisPlugin({
      url: 'redis://invalid:9999',
    });
    
    const server = { eventBus: {} };
    
    await badPlugin.register(server as any);
    
    await expect(
      badPlugin.initialize?.(server as any)
    ).rejects.toThrow();
  });
  
  it('should clean up on terminate', async () => {
    const server = { eventBus: {} };
    
    await plugin.register(server as any);
    await plugin.initialize?.(server as any);
    
    // Should not throw
    await expect(plugin.terminate?.(server as any)).resolves.toBeUndefined();
    
    // Factory should throw after cleanup
    expect(() => getRedis()).toThrow('Redis not initialized');
    expect(isRedisInitialized()).toBe(false);
  });
});
```

### Mocking Factory Functions in Route Tests

```typescript
// test/routes/cache.test.ts
import { vi } from 'vitest';

// Mock the factory function
vi.mock('../../plugins/redis', () => ({
  getRedis: vi.fn(() => mockRedis),
  isRedisInitialized: vi.fn(() => true),
}));

const mockRedis = {
  get: vi.fn().mockResolvedValue('cached-value'),
  set: vi.fn().mockResolvedValue(undefined),
};

test('gets cached value', async () => {
  const response = await request(app)
    .get('/cache/my-key');

  expect(mockRedis.get).toHaveBeenCalledWith('my-key');
  expect(response.status).toBe(200);
  expect(response.body.value).toBe('cached-value');
});
```

### Testing Plugin Middleware

```typescript
describe('Redis Plugin Middleware', () => {
  it('should inject redis service into context', async () => {
    const plugin = createRedisPlugin({ url: 'redis://localhost:6379' });
    const server = { use: vi.fn(), eventBus: {} };
    
    await plugin.register(server as any);
    await plugin.initialize?.(server as any);
    
    // Extract middleware
    const middleware = server.use.mock.calls[0][0];
    
    // Create mock context
    const ctx = createTestContext();
    const next = vi.fn();
    
    // Execute middleware
    await middleware.execute({
      ctx,
      next,
      logger: createMockLogger(),
      eventBus: createMockEventBus(),
    });
    
    // Verify redis was injected
    expect(ctx.services.redis).toBeDefined();
    expect(next).toHaveBeenCalled();
  });
});
```

---

## âœ… Best Practices

### 1. Always Clean Up Resources

**âœ… Good:**
```typescript
let _connection: Connection | null = null;

export function getConnection(): Connection {
  if (!_connection) throw new Error('Not initialized');
  return _connection;
}

const plugin = createPlugin<{}, {}, {}>({
  name: 'clean',
  version: '1.0.0',
  
  setup: () => {
    return {
      initialize: async () => {
        _connection = await connect();
      },
      
      terminate: async () => {
        const connection = getConnection();
        await connection.close();
        _connection = null; // â† Always clear!
      },
    };
  },
});
```

**âŒ Bad:**
```typescript
let _connection: Connection | null = null;

const plugin = createPlugin<{}, {}, {}>({
  name: 'leaky',
  version: '1.0.0',
  
  setup: () => {
    return {
      initialize: async () => {
        _connection = await connect();
      },
      // Missing terminate! Resource leak!
    };
  },
});
```

### 2. Use Factory Pattern for External Access

**âœ… Good:**
```typescript
// Internal singleton
let _service: Service | null = null;

// Public factory
export function getService(): Service {
  if (!_service) {
    throw new Error('Service not initialized.');
  }
  return _service;
}

setup: ({ config }) => {
  return {
    register: async (server) => {
      server.use(
        createMiddleware<{}, { service: Service }>({
          handler: async ({ ctx, next }) => {
            ctx.services.service = getService(); // Use factory
            await next();
          },
        })
      );
    },
    
    initialize: async () => {
      _service = new Service(config);
    },
    
    terminate: async () => {
      const service = getService();
      await service.cleanup();
      _service = null;
    },
  };
}
```

**âŒ Bad:**
```typescript
// Direct export (no safety checks)
export let service: Service;

setup: ({ config }) => {
  return {
    initialize: async () => {
      service = new Service(config);
    },
    // Users access `service` directly, might be undefined!
  };
}
```

### 3. Register Middleware in `register` Hook

**âœ… Good:**
```typescript
setup: () => {
  let service: Service;
  
  return {
    register: async (server) => {
      server.use(
        createMiddleware({
          handler: async ({ ctx, next }) => {
            ctx.services.myService = service;
            await next();
          },
        })
      );
    },
    
    initialize: async () => {
      service = new Service();
    },
  };
}
```

**âŒ Bad:**
```typescript
setup: (server) => { // Wrong signature!
  let service: Service;
  
  // Wrong! Don't register middleware in setup body
  server.use(
    createMiddleware({
      handler: async ({ ctx, next }) => {
        ctx.services.myService = service;
        await next();
      },
    })
  );
  
  return {
    initialize: async () => {
      service = new Service();
    },
  };
}
```

### 4. Use Only Exported Factory Functions

**âœ… Good:**
```typescript
// In job handler
import { getDatabase } from '../../plugins/database';

export const handler = async (data) => {
  const db = getDatabase(); // Safe!
  await db.query(...);
};
```

**âŒ Bad:**
```typescript
// In job handler
import { _db } from '../../plugins/database'; // Don't import internal!

export const handler = async (data) => {
  await _db.query(...); // Might be null!
};
```

### 5. Provide Meaningful Defaults

**âœ… Good:**
```typescript
const plugin = createPlugin<Config, {}, {}>({
  name: 'cache',
  version: '1.0.0',
  
  defaultConfig: {
    maxSize: 1000,
    ttl: 3600,
    url: 'redis://localhost:6379',
  },
  
  setup: ({ config }) => {
    // All config values are always defined
  },
});
```

**âŒ Bad:**
```typescript
const plugin = createPlugin<Config, {}, {}>({
  name: 'cache',
  version: '1.0.0',
  
  // No defaults!
  
  setup: ({ config }) => {
    // Have to check every value
    const maxSize = config.maxSize ?? 1000;
    const ttl = config.ttl ?? 3600;
    // ...
  },
});
```

### 6. Capture Type Information

**âœ… Good:**
```typescript
const app = Blaize.createServer()
  .register(databasePlugin()) // â† Capture return
  .register(cachePlugin());    // â† Capture return

type AppContext = InferContext<typeof app>;
// services = { db: Database; cache: Cache } âœ…
```

**âŒ Bad:**
```typescript
const server = Blaize.createServer();
server.register(databasePlugin()); // â† Types lost!
server.register(cachePlugin());    // â† Types lost!

type AppContext = InferContext<typeof server>;
// services = {} âŒ
```

### 7. Use Semantic Versioning

**âœ… Good:**
```typescript
const plugin = createPlugin({
  name: 'my-plugin',
  version: '2.1.0', // â† Semantic version
  // ...
});
```

**âŒ Bad:**
```typescript
const plugin = createPlugin({
  name: 'my-plugin',
  version: 'latest', // âŒ Not semantic!
  // ...
});
```

### 8. Log Important Lifecycle Events

**âœ… Good:**
```typescript
setup: ({ config, logger }) => {
  return {
    initialize: async () => {
      logger.info('Connecting to database', { host: config.host });
      // connect...
      logger.info('Database connected');
    },
    
    terminate: async () => {
      logger.info('Closing database connection');
      // close...
      logger.info('Database closed');
    },
  };
}
```

### 9. Handle Errors Gracefully

**âœ… Good:**
```typescript
setup: ({ logger }) => {
  return {
    initialize: async () => {
      try {
        await riskyOperation();
      } catch (error) {
        logger.error('Initialization failed', { error });
        throw error; // Re-throw for framework to handle
      }
    },
  };
}
```

### 10. Test Factory Functions

**âœ… Good:**
```typescript
test('factory throws before initialization', () => {
  expect(() => getDatabase()).toThrow('Database not initialized');
});

test('factory works after initialization', async () => {
  await plugin.initialize();
  expect(() => getDatabase()).not.toThrow();
});

test('factory throws after cleanup', async () => {
  await plugin.initialize();
  await plugin.terminate();
  expect(() => getDatabase()).toThrow('Database not initialized');
});
```

---

## ğŸ”— Related Documentation

- **[Middleware Guide](./middleware.md)** â€” For per-request logic
- **[Type System Guide](../architecture/type-system.md)** â€” How types flow through plugins
- **[Context Guide](../architecture/context.md)** â€” Understanding `ctx.services`
- **[Database Integration](./database-integration.md)** â€” Using database plugins with factory pattern
- **[Testing Guide](./testing.md)** â€” Testing plugins and middleware

---

**Questions or feedback?** Open an issue on GitHub or join our Discord community.